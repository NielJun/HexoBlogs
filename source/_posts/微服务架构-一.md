---
title: 微服务架构 [一] 微服务框架
date: 2020-02-06 12:41:14
tags: [Go,微服务,Micro Service]
categories: Go栈
---

![](/start.png)

## 微服务

要理解微服务，首先要先理解不是微服务的那些。通常跟微服务相对的是单体应用，即将所有功能都打包成在一个独立单元的应用程序。从单体应用到微服务并不是一蹴而就的，这是一个逐渐演变的过程。

### 微服务和单体应用

**单体应用**设计是在微服务之前普遍的软件设计思路，他所有的逻辑、业务、操作、数据管理、传输等都是在一个程序提里面完成。最典型的是操作系统。操作系统作为一个非常庞杂的单体应用，它本身只是一个非常大的代码库，拥有非常强的耦合性，即使在操作系统内核业务分层的情况下，即使各个部件的功能再单一，操作系统相对微服务应用也是强耦合的。

![](/4.jpg)

就Windows操作系统而言，Windows已经将近1000万行代码，想要一个人去把整个系统每行读懂是不太可能的，而且对于系统的维护和开发而是相当困难，迭代速度也会变得比较慢，最难的是很多时候单体应用会牵一发而动全身。

**微服务**   为了避免单体应用非常强的耦合性，微服务应用把程序中最小的逻辑分局变成一个微服务，每个服务都像是Linux下面 ls 工具那么简单，每个服务的职责也很单一，这样维护起来也很简单。

微服务架构还有一个技术外的好处，它使整个系统的分工更加明确，责任更加清晰，每个人专心负责为其他人提供更好的服务。在单体应用的时代，公共的业务功能经常没有明确的归属。最后要么各做各的，每个人都重新实现了一遍；要么是随机一个人（一般是能力比较强或者比较热心的人）做到他负责的应用里面。在后者的情况下，这个人在负责自己应用之外，还要额外负责给别人提供这些公共的功能——而这个功能本来是无人负责的，仅仅因为他能力较强/比较热心，就莫名地背锅（这种情况还被美其名曰能者多劳）。结果最后大家都不愿意提供公共的功能。长此以往，团队里的人渐渐变得各自为政，不再关心全局的架构设计。

从这个角度上看，使用微服务架构同时也需要组织结构做相应的调整。所以说做微服务改造需要管理者的支持。

微服务的主要优势有：

- 迭代周期短，极大提升开发效率
- 独立部署，独立开发
- 弹性伸缩，可对应服务伸缩
- 鼓掌隔离，互不影响

但是微服务也不是处处是优点，他的缺点只要在：

- 设计架构的复杂度增加，一个请求往往会经过很多个服务，请求链路比较长
- 监控和定位问题困难
- 服务管理比较复杂

## 微服务架构

微服务落地需要相关的关键服务因素的支持：

### **配套设施**

​	对于微服务应用必须有必要的配套设施落地才能支持微服务应用

- 微服务框架研发与维护
- 打包，版本管理，上线平台支持
- 硬件层支持，容器和容器调度
- 服务治理平台支持，比如分笔试链路追踪和监控
- 测试自动化支持，比如上线前自动化case

### **组织架构**

​	相对单体应用的架构，微服务的组织如下

- 微服务框架研发团队
- 私有云研发团队
- 测试平台研发团队

### 微服务生态

![](/1.png)

微服务生态主要的分层包括：**硬件层，通信层，应用平台层，微服务层**。

#### 硬件层

硬件层只要负责 **物理服务器的管理、操作系统管理、配置管理、资源隔离和抽象、主机监控和日志**等。

架构：

![](/2.png)

- 在基础设施层里面我们会选择**EC2、虚拟机、云服务器等机器资源作为基础设施**
- 上面**使用ubuntu、redhat、centerOS、coreOS等操作系统作为资源调度管理**
- 但是**不同的机器和操作系统**我需要用到**Docker做容器虚拟化**调度，让上层的**软件系统调用无平台差异**
- 但是容器间的通信映射等通过**kubernetes**进行管理和分配
- 最上层是**图形化的弹性分配**，可以**分配微服务资源**

#### 通信层

通信层是对服务之间的的交流做支持，包括各种服务的注册、发现、消息传递等。

- 网络传输
- RPC (包括 RPC Clinet 和 RPC Server)
- 服务发现
- 服务注册
- 负载均衡
- 消息传递

#### 网络传输层

网络传输层是用对应的协议支持，来保证传输。

- HTTP+RESTFUL
  - GET、POST、PUT、DELETE
- TCP RPC调用
  - Thrift协议
  - Dubbox
  - Grpc
- 消息传递
  - json
  - thrift
  - protobuf

#### 另外一个角度的微服务 [ 程序架构 ]

![](/3.jpg)

在不同的客户端 [ web、app、pc端等 ]通过Internet访问API网关，然后API网关在访问相对应的微服务，其中每个服务都是通过接口来进行调用，而不是数据，这点非常重要。

#### 微服务的组成

Core部分：单体应用部分

微服务部分： 每个服务都有自己的服务和数据，数据和数据之间都是完全隔离的。每个微服务的网络交互都是通过 **api** **网关**来进行传输控制，包括**限流和熔断**等机制。

其实初期的微服务最好是每个机器单独部署服务，这样是最清爽的，但是很多时候，资源都被浪费了。所以新的Docker，K8s技术等出现就弥补了这个缺口。

好啦，这次先到这啦～

