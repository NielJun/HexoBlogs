{"meta":{"version":1,"warehouse":"3.0.1"},"models":{"Asset":[{"_id":"themes/hexo-theme-matery/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/matery.css","path":"css/matery.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/my.css","path":"css/my.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/matery.js","path":"js/matery.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/comment_bg.png","path":"medias/comment_bg.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/icp.png","path":"medias/icp.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/logo.png","path":"medias/logo.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/canvas-nest.js","path":"libs/background/canvas-nest.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-dynamic.js","path":"libs/background/ribbon-dynamic.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-refresh.min.js","path":"libs/background/ribbon-refresh.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon.min.js","path":"libs/background/ribbon.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/instantpage/instantpage.js","path":"libs/instantpage/instantpage.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/cover.jpg","path":"medias/cover.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/26.jpg","path":"medias/featureimages/26.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/30.jpg","path":"medias/featureimages/30.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/reward/wechat.jpg","path":"medias/reward/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jquery/jquery.min.js","path":"libs/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.ttf","path":"libs/awesome/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff2","path":"libs/awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff","path":"libs/awesome/webfonts/fa-regular-400.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/25.jpg","path":"medias/featureimages/25.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/32.jpg","path":"medias/featureimages/32.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff2","path":"libs/awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.eot","path":"libs/awesome/webfonts/fa-regular-400.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff2","path":"libs/awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff","path":"libs/awesome/webfonts/fa-solid-900.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/28.jpg","path":"medias/featureimages/28.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/29.jpg","path":"medias/featureimages/29.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/all.css","path":"libs/awesome/css/all.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.eot","path":"libs/awesome/webfonts/fa-brands-400.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff","path":"libs/awesome/webfonts/fa-brands-400.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.ttf","path":"libs/awesome/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.svg","path":"libs/awesome/webfonts/fa-regular-400.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.ttf","path":"libs/awesome/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/31.jpg","path":"medias/featureimages/31.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.eot","path":"libs/awesome/webfonts/fa-solid-900.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/27.jpg","path":"medias/featureimages/27.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/24.jpg","path":"medias/featureimages/24.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.svg","path":"libs/awesome/webfonts/fa-brands-400.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.svg","path":"libs/awesome/webfonts/fa-solid-900.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/7.jpg","path":"medias/banner/7.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"e93d0e929f4c3d5e0c345288b5ea04089de31106","modified":1582955841325},{"_id":"themes/hexo-theme-matery/.DS_Store","hash":"f89a79af7677f85075fd13eee1a9373252a677fc","modified":1581318192275},{"_id":"themes/hexo-theme-matery/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1581040893737},{"_id":"themes/hexo-theme-matery/.gitignore","hash":"727607929a51db7ea10968f547c26041eee9cfff","modified":1581040893737},{"_id":"themes/hexo-theme-matery/README.md","hash":"1c9c512aeafc29afef0a2ffab2aa53ea48b6bc72","modified":1581040893738},{"_id":"themes/hexo-theme-matery/_config.yml","hash":"3118f1176b53b37db61845780d402c3626a299da","modified":1581133617396},{"_id":"themes/hexo-theme-matery/README_CN.md","hash":"e7565b179024ef8043d34c7b8468dc5f16ba366c","modified":1581040893738},{"_id":"themes/hexo-theme-matery/package.json","hash":"de1213382a47878d440fcc231cecad61b25bb00e","modified":1581049847848},{"_id":"source/_posts/Delve调试工具.md","hash":"0bb5e2638e8da72f0271e7e2db7b2a7fdbbbf93e","modified":1581132041455},{"_id":"source/_posts/Go-ProtoBuf-和其他传输数据协议.md","hash":"ca80dc80e82c361fcf3fb724ed45b11d86adbdf6","modified":1581056740494},{"_id":"source/_posts/Go-defer-详解.md","hash":"c8cc77b6b4778cb606b36fbfa42d8f4c084bdf4a","modified":1581132083318},{"_id":"source/_posts/.DS_Store","hash":"a5b4078b1d16ac63e659c78cdd808190ed732cee","modified":1582955823517},{"_id":"source/_posts/Go单元测试和压力测试.md","hash":"0f788bc902de17a84c4a164a9de96bb9916ab24e","modified":1581132117499},{"_id":"source/_posts/Go常用语法糖炮弹工具集.md","hash":"0cb0d986deb619f0c3f3f1fa7d6973601aea57fe","modified":1581056795926},{"_id":"source/_posts/Go并发编程初探.md","hash":"dead5a28cc75580f82358b31a7b928adb6fbc928","modified":1581053557310},{"_id":"source/_posts/Go语言基础之并发.md","hash":"61b6a599d0d24129881b0b1ec7e5966e5abb7c8b","modified":1581320831897},{"_id":"source/_posts/Kubernetes第一章-组件简介.md","hash":"7ff0702ad7b9eb77517f438cc951de4635ece324","modified":1581132146522},{"_id":"source/_posts/Hexo博客搭建.md","hash":"fdc50a48ed36299116df42de5cf5482ecb5c096e","modified":1581132215849},{"_id":"source/_posts/Mac设置文件权限问题.md","hash":"fb3447de017a2ef467fb405b11d3f4ac6f075a64","modified":1581130792096},{"_id":"source/_posts/ShaderGraph学习之二-让粒子更亮.md","hash":"5562d8feff0076eb2cf028a51e63c217d8b24304","modified":1579863281000},{"_id":"source/_posts/Nginx安装.md","hash":"5f872057ea4f78d3fd0d2c5059eb853c347dc1fc","modified":1581053621776},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰.md","hash":"80b304849cceaed1cecf9b1af016821c230429ad","modified":1579851130000},{"_id":"source/_posts/VMware-Fusion-11-购买的序列号.md","hash":"a2360244036ddef87edeec68924413bd13328e9b","modified":1581321328728},{"_id":"source/_posts/blender-学习章.md","hash":"ccd7ebe12f0ef266cc2db8618c19481721e27615","modified":1581132227442},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议.md","hash":"859713bbac6c89b30315dd3c1d0b81f76102a738","modified":1582953914889},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解.md","hash":"660a1473576fefe6d623959c816ac04c682f4fc3","modified":1582954084734},{"_id":"source/_posts/大话Tcp-Ip协议栈.md","hash":"4047f0993b6fc95baad24adb43ba5de3eee25993","modified":1582954397815},{"_id":"source/_posts/微服务架构-一.md","hash":"6340269bf86fe6e7365599e39ba54ea00f1226c2","modified":1581303537769},{"_id":"source/_posts/微服务架构-三-Raft协议.md","hash":"838773ed2db6ccfa17825a76bda7b6c5b116709f","modified":1581308491610},{"_id":"source/_posts/微服务架构-二-微服务注册和发现.md","hash":"b882bf3f77b6bb0310d91f41c20c3a4d68694351","modified":1581304370317},{"_id":"source/_posts/服务器平滑升级-柔性重启.md","hash":"3dac4238f312a34417ba93e0924eb5219dd1feaf","modified":1581320874918},{"_id":"source/_posts/游戏中的四元数.md","hash":"8af4fa1f2bb55c86dfe8af8d8dee4729607a9eff","modified":1581053651980},{"_id":"source/_posts/网络协议基础.md","hash":"7ddba53331f60eaa102dc3264c77b09c5f398e5a","modified":1581474452528},{"_id":"source/_data/friends.json","hash":"9ae290e7c489d0a2db2c879d58d0d960463e5222","modified":1581041479981},{"_id":"source/_data/music.json","hash":"1eef1e517fb8171a6f69840ad5313b9311c3237b","modified":1581050019077},{"_id":"source/about/index.md","hash":"ba273d35e4349cf1e97ccb79c54785729a97b405","modified":1581041319030},{"_id":"source/categories/index.md","hash":"7c84982ddea479a2cee6e69a0ac5a6f0ba9f3f76","modified":1581041210805},{"_id":"source/contact/index.md","hash":"fea97fdbc51cb560970bf93896dfa2eb455d29bb","modified":1581041361299},{"_id":"source/friends/index.md","hash":"725653a3c2ae6757e8f7c3900296fa6e28d2af7c","modified":1581041399831},{"_id":"source/tags/index.md","hash":"9f14525108d88eae62c2e085f44330b7ec04a3e4","modified":1581041281099},{"_id":"themes/hexo-theme-matery/layout/about.ejs","hash":"99825631ba38205c079246384fd2123ceb868430","modified":1581040893744},{"_id":"themes/hexo-theme-matery/layout/archive.ejs","hash":"2f1f2045cf724ba9e77b30c0b06a98e341bd59c1","modified":1581040893744},{"_id":"themes/hexo-theme-matery/layout/categories.ejs","hash":"8e54665cc25d7c333da7d9f312987190be6215da","modified":1581040893745},{"_id":"themes/hexo-theme-matery/layout/category.ejs","hash":"70d0e6ade3baffb0e39b17cb74bff33114f542f2","modified":1581040893745},{"_id":"themes/hexo-theme-matery/layout/index.ejs","hash":"ebc537a94430646817709e93db4a1d670f71aebc","modified":1581040893745},{"_id":"themes/hexo-theme-matery/layout/contact.ejs","hash":"c3396cc5b1cbb102f500554f76946f5b45ee6d54","modified":1581040893745},{"_id":"themes/hexo-theme-matery/layout/friends.ejs","hash":"4cb216b2a650ad5d2942047a65d0883a188c2abb","modified":1581040893745},{"_id":"themes/hexo-theme-matery/layout/layout.ejs","hash":"44389011495deb73f7c9b8b9455abeb4f87f37fd","modified":1581040893745},{"_id":"themes/hexo-theme-matery/layout/post.ejs","hash":"14695375ba83ef0d8a8940891243a32906a20800","modified":1581040893745},{"_id":"themes/hexo-theme-matery/layout/tags.ejs","hash":"cf9517aa6a0111355121f44615d6923e312283c7","modified":1581040893746},{"_id":"themes/hexo-theme-matery/layout/tag.ejs","hash":"df5a0502374022c2aee1f37b77bcc8d20d22df65","modified":1581040893745},{"_id":"themes/hexo-theme-matery/languages/default.yml","hash":"54ccc01b097c5bf6820f0edfcece1a87b78ab32d","modified":1581040893739},{"_id":"themes/hexo-theme-matery/languages/zh-CN.yml","hash":"a957b05f70265a86a87d922e18488571809d2472","modified":1581040893739},{"_id":"themes/hexo-theme-matery/source/.DS_Store","hash":"0b9374d6da5c787368fef5468a583ef64cc257a5","modified":1581320754333},{"_id":"themes/hexo-theme-matery/source/favicon.png","hash":"b7c469c10c52906bfcb44841064b1fb9a0bd13e3","modified":1578232856000},{"_id":"source/_posts/Delve调试工具/.DS_Store","hash":"5c656f91ca547f5d8b7967e4d78ddc713f7d472e","modified":1579518442000},{"_id":"source/_posts/Delve调试工具/start.jpg","hash":"becb69160b2cd7636c8782b81e17c1fffffbcf2b","modified":1579518405000},{"_id":"source/_posts/Go-ProtoBuf-和其他传输数据协议/jpg3.jpg","hash":"22b9588fb38890bc09961cd736235abfbe052f64","modified":1579961623000},{"_id":"source/_posts/Go-ProtoBuf-和其他传输数据协议/png5.png","hash":"e35d9d610d73d16eb06d4ba1439664d298c87114","modified":1579963785000},{"_id":"source/_posts/Go-ProtoBuf-和其他传输数据协议/start.png","hash":"3905374e9eb53fe8d085f73b28ede75f0156e43d","modified":1579847114000},{"_id":"source/_posts/Go单元测试和压力测试/.DS_Store","hash":"6e261964e45d88aca3d5fb3b9f161e0928ed3119","modified":1579487658000},{"_id":"source/_posts/Go单元测试和压力测试/start.png","hash":"37aafce693f838527eb6576e7e3123a26b97da27","modified":1579487576000},{"_id":"source/_posts/Go常用语法糖炮弹工具集/p1.jpg","hash":"c043e9409836ad2b85481cbd4e36f64d2f0897cb","modified":1578632767000},{"_id":"source/_posts/Go常用语法糖炮弹工具集/suga.jpg","hash":"85de5b1f120daaf1d9e7f35c3a3746c5f8eb15b1","modified":1578632200000},{"_id":"source/_posts/Go并发编程初探/.DS_Store","hash":"f35a26db132cb7e64e1209f4f102a4660bb073af","modified":1581037854554},{"_id":"source/_posts/Go并发编程初探/lock.jpg","hash":"8ec1b70d907e51ade9cd9754b90b90b6fcc13154","modified":1579596107000},{"_id":"source/_posts/Kubernetes第一章-组件简介/.DS_Store","hash":"8b273f72b51a56bebedb9429e3961e8f121bf054","modified":1580961868256},{"_id":"source/_posts/Kubernetes第一章-组件简介/mesos.jpg","hash":"e884cddb0a6f1f21429860881c31226651028389","modified":1580961685875},{"_id":"source/_posts/Hexo博客搭建/.DS_Store","hash":"3d61805de6ff12e2e622c86b7b0eb30cfa21b878","modified":1578581052000},{"_id":"source/_posts/Hexo博客搭建/Hexo.jpg","hash":"186afa4cc9bdab4df8e0739100047f01fdb5c3d6","modified":1578325340000},{"_id":"source/_posts/Hexo博客搭建/hexo_config.png","hash":"0927182659dae466545979bbafc2f69ca683d8a9","modified":1578327930000},{"_id":"source/_posts/Hexo博客搭建/hexothemes.jpg","hash":"9669f810d09e2dfa4b77c07192c9b65a665f4422","modified":1578325430000},{"_id":"source/_posts/Nginx安装/.DS_Store","hash":"ee6d2d8c8430e4d0a84120c66de3a357c44848d8","modified":1578323577000},{"_id":"source/_posts/Nginx安装/bash.png","hash":"ca14b543c91943baddf79f912d9fa74b0ed042c2","modified":1578269499000},{"_id":"source/_posts/Nginx安装/default.jpg","hash":"a78289374d26aeb00b6381075e2937c7c4d79634","modified":1578323910000},{"_id":"source/_posts/Nginx安装/nginx.jpg","hash":"4907f68f7b4dbc362d00920b90ea1bd6d6074660","modified":1578269271000},{"_id":"source/_posts/Nginx安装/start.png","hash":"f74662ea20a14977ee5bc8f1ba9690066c2b396a","modified":1578269578000},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/.DS_Store","hash":"84c4f00075718f3217e58324d0f667073f556b7d","modified":1579862956000},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png10.png","hash":"b008ff67ec27479bca9942e23b5b5f2798ffbba9","modified":1579850430000},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png9.png","hash":"826b72b8dc8deab6c77ca80135cfbdb8245df0b8","modified":1579850267000},{"_id":"source/_posts/blender-学习章/end.jpg","hash":"400cff8af3b1f098dd1857ffb7a0267008a7165e","modified":1579964633000},{"_id":"source/_posts/blender-学习章/start.jpg","hash":"8d8519843c530e1bd284d94fcc459ca4796961d2","modified":1579964468000},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/14.jpg","hash":"2cb36467a433df6e8df9b59b899c86f08cd76a54","modified":1582949851439},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/15.jpg","hash":"6c74f0271191d8bf89660a6a54852225e52f37db","modified":1582949861879},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/16.jpg","hash":"06f1b0dd293bd4583109ddbea5a8f9b940cb95a0","modified":1582950196637},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/18.jpg","hash":"5f36b7b76b9b10b33ed8a903bea8df8300356bba","modified":1582951493132},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/19.jpg","hash":"5f36b7b76b9b10b33ed8a903bea8df8300356bba","modified":1582951536851},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/20.jpg","hash":"a72a7e627cc1cbdbaf48c487738747c0ef2d1b7c","modified":1582951545882},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/22.jpg","hash":"7859cfdcd540935311500125d760609775e0bbe0","modified":1582951764767},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/23.jpg","hash":"5bd5fac6f20eff324ed8aba28940ec14258d9e6f","modified":1582951777220},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/24.jpg","hash":"20273f4c1eef920897c91866ab23c77602ad9744","modified":1582951909565},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/25.jpg","hash":"39de267af45f843045c1823e83081e3e2d9770eb","modified":1582952038545},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/10.jpg","hash":"9439e78df88951cd376ffb71f25c4d1ecc731852","modified":1582947666913},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/11.jpg","hash":"3978baf16d88f165984785a99310cc6a9bb70646","modified":1582947820517},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/12.jpg","hash":"227c9accc2a5b2af1624f2a103a2558d1161722e","modified":1582948833948},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/.DS_Store","hash":"cf98d351490b7a37f54e2427d647e3be9aae6044","modified":1582955818512},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/13.jpg","hash":"b738ef01bc4289b979c484eeef7766c722c135b1","modified":1582949234043},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/3.jpg","hash":"2632b0faba9e551590fcc921bac8be9f4952cd0b","modified":1582943559224},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/.DS_Store","hash":"45d8610cb9413fc9f6c9d007f95b9cc37ac7cf54","modified":1582955805781},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/4.jpg","hash":"7797dd81eb530df18ae72a4f566d64c79f2fda58","modified":1582943636014},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/5.jpg","hash":"77e3f6f5461c8d2ae701a98b7064a37bf1768924","modified":1582943643110},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/6.jpg","hash":"8b21c0ece27b328deab9d5e0ec1c3169e33750dd","modified":1582945209417},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/7.jpg","hash":"cd91e304f1d4392e703f33714d35c1f68a2ba3d3","modified":1582945636157},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/8.jpg","hash":"530b5659da060f076c5222813157c3a262027c04","modified":1582945858717},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/9.jpg","hash":"3fb4a489e0fdc0232649e0a615c566dc327bd2b1","modified":1582946748708},{"_id":"source/_posts/大话Tcp-Ip协议栈/1.jpg","hash":"dc9af39084ca0e8d68979d49535607517a8b7067","modified":1582941244466},{"_id":"source/_posts/大话Tcp-Ip协议栈/2.jpg","hash":"6646278265c4ae4bf1a7164cf97e1d1a21bba8d0","modified":1582942778720},{"_id":"source/_posts/大话Tcp-Ip协议栈/.DS_Store","hash":"3a25505afe9536fc9d7dfa1b1de528171031f510","modified":1582955823516},{"_id":"source/_posts/微服务架构-一/1.png","hash":"4ebd81e0e9585f85ecc992e251f05a7822dacc3d","modified":1580966021017},{"_id":"source/_posts/微服务架构-一/3.jpg","hash":"19d14d61ee142323fcec64eff48da2b50080ee6a","modified":1580967331279},{"_id":"source/_posts/微服务架构-一/4.jpg","hash":"f4e1940920285220c3e4289c77d1379473e5f5e7","modified":1580967630742},{"_id":"source/_posts/微服务架构-一/start.png","hash":"3905374e9eb53fe8d085f73b28ede75f0156e43d","modified":1580218558538},{"_id":"source/_posts/微服务架构-三-Raft协议/10.png","hash":"948c71db7cbfa4f2625ea25edeb81dd965c72c19","modified":1580980664364},{"_id":"source/_posts/微服务架构-三-Raft协议/11.png","hash":"630f4d51b52f8a0153727bd26c46bd8bea0875a1","modified":1580980729836},{"_id":"source/_posts/微服务架构-三-Raft协议/12.png","hash":"0e4e58294322f7c3a6f940657b2a8b97d7c51467","modified":1580980927969},{"_id":"source/_posts/微服务架构-三-Raft协议/13.png","hash":"d41312b7f6a16a770b149763cf9691d12d47d245","modified":1580981097073},{"_id":"source/_posts/微服务架构-三-Raft协议/15.png","hash":"bc6be7d9ed07c306ae7b70be865f1f95306b362f","modified":1581305662782},{"_id":"source/_posts/微服务架构-三-Raft协议/16.png","hash":"08d48b726addcc4d56e8b8b5cb7a6fa1bed5248c","modified":1581307027339},{"_id":"source/_posts/微服务架构-三-Raft协议/4.png","hash":"c3868acd64a252f61dc14ddc0dfb31d8a7e231a9","modified":1580973871673},{"_id":"source/_posts/微服务架构-三-Raft协议/5.png","hash":"03186422a97304d3a4c067e82a9e0dea88536b67","modified":1580974146978},{"_id":"source/_posts/微服务架构-三-Raft协议/6.png","hash":"bdac5843c1b97b0e18491db85bee9fba2273162d","modified":1580974673274},{"_id":"source/_posts/微服务架构-三-Raft协议/7.png","hash":"89b677f9397af758e432c18c1003b973348cfb6b","modified":1580979677203},{"_id":"source/_posts/微服务架构-三-Raft协议/8.png","hash":"ea858d0f59ee367cd074ae472a3afa7c12d4d903","modified":1580980591437},{"_id":"source/_posts/微服务架构-二-微服务注册和发现/.DS_Store","hash":"e7218d09d9f924c8076f2e76928d7e065749a3c1","modified":1581304397876},{"_id":"source/_posts/微服务架构-二-微服务注册和发现/1.png","hash":"ae67b2330378f1af8970048f4872534626b8daa8","modified":1580971500092},{"_id":"source/_posts/微服务架构-二-微服务注册和发现/2.png","hash":"4192c91a5cb167675bb14f6ea313969798225319","modified":1580972202194},{"_id":"source/_posts/微服务架构-二-微服务注册和发现/3.jpg","hash":"9851637d1d50206f46d433c659859dff0a611389","modified":1580973571568},{"_id":"source/_posts/游戏中的四元数/.DS_Store","hash":"9feb9bbdac899d7cc9cd5849777d144914f43511","modified":1578388921000},{"_id":"source/_posts/游戏中的四元数/rotation.jpg","hash":"bba16c4a2da4d34752ec5c8aafef7a16dac38893","modified":1578383294000},{"_id":"source/_posts/游戏中的四元数/show.jpg","hash":"0a573bfa5770eefe77e7c4a464dfd0ff3d024856","modified":1578382458000},{"_id":"source/_posts/游戏中的四元数/show1.png","hash":"f578efe5743487b247b53e601cb50cb83f6bc252","modified":1578383924000},{"_id":"source/_posts/游戏中的四元数/show2.png","hash":"f49bc631cb1da8911ea02521e00493917a0d70a2","modified":1578384182000},{"_id":"source/_posts/游戏中的四元数/show3.png","hash":"aba465a243788cbbafdf2e129fdfbf4f8bd12b0a","modified":1578384350000},{"_id":"source/_posts/游戏中的四元数/show4.png","hash":"fc585c865439b0668c307d8a232ce8b1de621a6e","modified":1578384682000},{"_id":"source/_posts/游戏中的四元数/show5.png","hash":"29589e5423fe79d5688f19f36bd2dd3833097bff","modified":1578384903000},{"_id":"source/_posts/游戏中的四元数/show6.png","hash":"f28b5bfb97439afdfb67aef54181f00467dbdca2","modified":1578384997000},{"_id":"source/_posts/游戏中的四元数/show7.jpg","hash":"a522f843b0cdaeef76702a9169b211b4e96b1b0b","modified":1578385048000},{"_id":"source/_posts/游戏中的四元数/show8.png","hash":"327fb889891ad8b831ff964a9ce6114d8635fb08","modified":1578385086000},{"_id":"source/_posts/游戏中的四元数/show9.png","hash":"c294f7d09091befc5df41bd9e2013f72c8849d17","modified":1578385148000},{"_id":"source/_posts/游戏中的四元数/start.png","hash":"f9de6983b5bdbe8879bfdadd1e00968b7d859caa","modified":1579847459000},{"_id":"source/_posts/网络协议基础/.DS_Store","hash":"6803ab0017805b8f9f5b3526a44eb1c300502e58","modified":1579652257000},{"_id":"source/_posts/网络协议基础/a.jpg","hash":"602b0f814328dafbd5544337fdd779045726499d","modified":1579611849000},{"_id":"source/_posts/网络协议基础/http.jpg","hash":"2b1f33e5e9ceb8f9569ea4ceeb60e985a6330929","modified":1579611821000},{"_id":"source/_posts/网络协议基础/level.jpg","hash":"823e8c68e9cc18e86433d9a8fe23d28f852dc418","modified":1579604784000},{"_id":"themes/hexo-theme-matery/layout/_partial/back-top.ejs","hash":"47ee36a042bb6d52bbe1d0f329637e8ffcf1d0aa","modified":1581040893739},{"_id":"themes/hexo-theme-matery/layout/_partial/baidu-analytics.ejs","hash":"3bbcdb474ca1dcad514bdc4b7763e17c55df04fd","modified":1581040893739},{"_id":"themes/hexo-theme-matery/layout/_partial/baidu-push.ejs","hash":"2cebcc5ea3614d7f76ec36670e68050cbe611202","modified":1581040893739},{"_id":"themes/hexo-theme-matery/layout/_partial/bg-cover-content.ejs","hash":"f52c9d581e99dc247f06805651423005bac4a5d3","modified":1581060589543},{"_id":"themes/hexo-theme-matery/layout/_partial/bg-cover.ejs","hash":"02191109712f61c0e487b8f0b8466597181a9004","modified":1581040893739},{"_id":"themes/hexo-theme-matery/layout/_partial/disqus.ejs","hash":"a0f53d1a9b579d52e52ccad8c6e330bf3b89547e","modified":1581040893740},{"_id":"themes/hexo-theme-matery/layout/_partial/footer.ejs","hash":"8e7185fb455a6de7ac488e035fddbefc19c0139f","modified":1581057940774},{"_id":"themes/hexo-theme-matery/layout/_partial/gitalk.ejs","hash":"9500f32a8e6dc9c7cc4bec49cac39a33efc0298d","modified":1581040893740},{"_id":"themes/hexo-theme-matery/layout/_partial/github-link.ejs","hash":"3aeb581bd78ab8e15b858e4c44c03bcf92f20b9e","modified":1581040893740},{"_id":"themes/hexo-theme-matery/layout/_partial/gitment.ejs","hash":"c6eb3a14decccf01630ba5e22bfcdb8a7e9943e7","modified":1581040893740},{"_id":"themes/hexo-theme-matery/layout/_partial/google-analytics.ejs","hash":"5f4992205617da5f8cc5863c62b5ec46e414e2fb","modified":1581040893740},{"_id":"themes/hexo-theme-matery/layout/_partial/head.ejs","hash":"e5d764cb6dd7700a2edc4d5f9d5f4b525a14b6b5","modified":1581040893740},{"_id":"themes/hexo-theme-matery/layout/_partial/header.ejs","hash":"a7896a007118b7bea4685714f0f2fa88978d71d2","modified":1581040893740},{"_id":"themes/hexo-theme-matery/layout/_partial/index-cover.ejs","hash":"be9476fe658c0d5201843bf0bc543aa832a378de","modified":1581040893741},{"_id":"themes/hexo-theme-matery/layout/_partial/livere.ejs","hash":"9c3401b42ea7f26410a5593bae93ada7e57b43be","modified":1581040893741},{"_id":"themes/hexo-theme-matery/layout/_partial/mobile-nav.ejs","hash":"54d158ed075349ffac6b53b6d295224b2e162d37","modified":1581508857851},{"_id":"themes/hexo-theme-matery/layout/_partial/navigation.ejs","hash":"5ff6fdfe973619120a9eda4505bbff4545e39ff0","modified":1581040893741},{"_id":"themes/hexo-theme-matery/layout/_partial/paging.ejs","hash":"e2df12cf92a82b1a7a7add2eac1db1d954bc5511","modified":1581040893741},{"_id":"themes/hexo-theme-matery/layout/_partial/post-cover.ejs","hash":"6ecd4275fdd7585fee872545a1eab5d2417adec0","modified":1581040893741},{"_id":"themes/hexo-theme-matery/layout/_partial/post-detail-toc.ejs","hash":"e64819596a61293f9880ee16feaa3c1677d228b8","modified":1581040893741},{"_id":"themes/hexo-theme-matery/layout/_partial/post-detail.ejs","hash":"2d20e5dcf172c1e6b5853d8c24b0670fafe48dbf","modified":1581040893741},{"_id":"themes/hexo-theme-matery/layout/_partial/post-statis.ejs","hash":"04889f9031743c6b081d02fa4027b0dbfcc45ecf","modified":1581040893742},{"_id":"themes/hexo-theme-matery/layout/_partial/prev-next.ejs","hash":"0e95dcbadc8fd7e945b799923674b694ddc3ad9c","modified":1581040893742},{"_id":"themes/hexo-theme-matery/layout/_partial/reprint-statement.ejs","hash":"01f5eef82bbcb9d432631dbb78dd51d4d4b3b8b5","modified":1581040893742},{"_id":"themes/hexo-theme-matery/layout/_partial/reward.ejs","hash":"39b570b9446a7897063fdd6d538ad476fd84f17f","modified":1581040893742},{"_id":"themes/hexo-theme-matery/layout/_partial/search.ejs","hash":"b72ae1de86cc6828b7ff1570d02b784167ef0fff","modified":1581040893742},{"_id":"themes/hexo-theme-matery/layout/_partial/share.ejs","hash":"36fb0d22d50a9d348fc72ea0fb6c071f2c25b95b","modified":1581040893742},{"_id":"themes/hexo-theme-matery/layout/_partial/social-link.ejs","hash":"6f871bd3a70f720e4e451f1f4f625cbc6d8994a4","modified":1581040893742},{"_id":"themes/hexo-theme-matery/layout/_partial/valine.ejs","hash":"5a5945ef60b0f8af76406ffe9850009c9fdb2c4b","modified":1581040893743},{"_id":"themes/hexo-theme-matery/layout/_widget/category-cloud.ejs","hash":"424ef5db791264a79c1f3338e7c43a2f445cb2ab","modified":1581040893743},{"_id":"themes/hexo-theme-matery/layout/_widget/category-radar.ejs","hash":"383a4501d42df2dadb254f2ae6facc1886605497","modified":1581040893743},{"_id":"themes/hexo-theme-matery/layout/_widget/dream.ejs","hash":"ba83115ce66f4328601e567aa30f50d1410b9bfa","modified":1581040893743},{"_id":"themes/hexo-theme-matery/layout/_widget/music.ejs","hash":"7c6a7287a8d09a0bb54e0a3d305238ff129f995f","modified":1581040893743},{"_id":"themes/hexo-theme-matery/layout/_widget/my-gallery.ejs","hash":"b74d861fa175a494d4f7caf791024119cacc997a","modified":1581040893743},{"_id":"themes/hexo-theme-matery/layout/_widget/my-projects.ejs","hash":"dbd8df5146bd6e873535e24f09dd7cf04e17a4e4","modified":1581040893743},{"_id":"themes/hexo-theme-matery/layout/_widget/my-skills.ejs","hash":"89a0092df72d23093128f2fbbdc8ca7f83ebcfd9","modified":1581040893743},{"_id":"themes/hexo-theme-matery/layout/_widget/post-calendar.ejs","hash":"3fa9ceb2a28929b14002d59e2d96cc4bac39eb7b","modified":1581040893744},{"_id":"themes/hexo-theme-matery/layout/_widget/post-charts.ejs","hash":"bff6033f89daa925e2d44c28b1dd4d21fb773dd8","modified":1581040893744},{"_id":"themes/hexo-theme-matery/layout/_widget/recommend.ejs","hash":"a40f466dc96cedfcde66b89acdc0a2fa8a8dfefe","modified":1581040893744},{"_id":"themes/hexo-theme-matery/layout/_widget/tag-cloud.ejs","hash":"fc42b72cddc231f7485cdc1fd6852b66be6add26","modified":1581040893744},{"_id":"themes/hexo-theme-matery/layout/_widget/tag-wordcloud.ejs","hash":"70fc118bcc8705f47580e3c190bb486d94982032","modified":1581040893744},{"_id":"themes/hexo-theme-matery/layout/_widget/video.ejs","hash":"d752c9f54300a9d762433ac4a00de3cc7e79d584","modified":1581040893744},{"_id":"themes/hexo-theme-matery/source/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1581040893746},{"_id":"themes/hexo-theme-matery/source/css/matery.css","hash":"aef647fafa622074fd45532588595773ce43848d","modified":1581077084372},{"_id":"themes/hexo-theme-matery/source/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1581048285690},{"_id":"themes/hexo-theme-matery/source/css/my.css","hash":"10577fbc30f241b126d1b51b1f56136ecba86b19","modified":1581040893747},{"_id":"themes/hexo-theme-matery/source/js/matery.js","hash":"07ed4f743a497d7850b3fdda2a5d9beccc5a8fb5","modified":1581040893747},{"_id":"themes/hexo-theme-matery/source/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1581040893748},{"_id":"themes/hexo-theme-matery/source/medias/.DS_Store","hash":"e002c889d688487f8a4e4ac475587007bafbf1d7","modified":1581319846620},{"_id":"themes/hexo-theme-matery/source/medias/avatar.jpg","hash":"b7c469c10c52906bfcb44841064b1fb9a0bd13e3","modified":1578232856000},{"_id":"themes/hexo-theme-matery/source/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1581040893787},{"_id":"themes/hexo-theme-matery/source/medias/icp.png","hash":"5d1a1f3051c8a4ad70afa0a5488dfa7f0bb27bd5","modified":1581040893793},{"_id":"source/_posts/Go-ProtoBuf-和其他传输数据协议/png1.png","hash":"94263b02f079b432a4fc45d063c3f8b5bc269e9c","modified":1579960489000},{"_id":"source/_posts/Go-ProtoBuf-和其他传输数据协议/png2.png","hash":"266b97b8af3004ded22cd9e734371879aaf5d986","modified":1579961370000},{"_id":"source/_posts/Go-ProtoBuf-和其他传输数据协议/png4.png","hash":"fee2b06a8de41af030d3039835ed493ccf76ca6f","modified":1579961727000},{"_id":"source/_posts/Go单元测试和压力测试/png1.png","hash":"ed03bed2eba867c4a8faf451e386d04d48101474","modified":1579486396000},{"_id":"source/_posts/Go单元测试和压力测试/png2.png","hash":"3f06e21e1b137c326595ba9afc14db122a6356bd","modified":1579486618000},{"_id":"source/_posts/Go单元测试和压力测试/png3.png","hash":"67a3b4127552aaadd706e9083a4503585a187d99","modified":1579486694000},{"_id":"source/_posts/Go单元测试和压力测试/png4.png","hash":"1e4e88982491cfbace05ef41dfad33842321210a","modified":1579487484000},{"_id":"source/_posts/Kubernetes第一章-组件简介/dockerswarm.png","hash":"3015a60d6403ae9534d78d2593b2193c827b4612","modified":1580961060701},{"_id":"source/_posts/Hexo博客搭建/start.png","hash":"88e7db3c41cc1b3d352b64a8a3018fdc303c1374","modified":1578327156000},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png2.png","hash":"c1710db52cb8ed01945f02bee568a0bdd6382a57","modified":1579848501000},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png3.png","hash":"5399fa0cd4515358e46635562b48a13f74f7a9ff","modified":1579849041000},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png6.png","hash":"2dac271d1705b1d6f380f42271029f01dcd3f9ff","modified":1579849267000},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png7.png","hash":"eddbb4873872f4f552d7f74a545f7b8dd1894295","modified":1579849692000},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/17.jpg","hash":"67dc86ef74db3a33ef3ab009afd21209e758566e","modified":1582951433073},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/21.jpg","hash":"833096336da3e83fee3f5b3c2611e50734c4bd0b","modified":1582951612026},{"_id":"source/_posts/微服务架构-三-Raft协议/9.png","hash":"9eae587c93e502ab4bc1e5b8bbb3578abc3052c9","modified":1580980102844},{"_id":"source/_posts/微服务架构-二-微服务注册和发现/start.png","hash":"b10e7416a9aca816adc196ebc7fedba4d595b3ba","modified":1580218719800},{"_id":"source/_posts/网络协议基础/tcp.jpg","hash":"b273ed148690779dae4dc9b4e15e986c8afe8da9","modified":1579604629000},{"_id":"themes/hexo-theme-matery/source/medias/logo.png","hash":"79c588ec260b7d9a22cb4997acedaa182cf0542f","modified":1581319814998},{"_id":"source/_posts/Go并发编程初探/png6.png","hash":"e01af0187ae42f4b12a3564f81af3c247f2b9988","modified":1579583357000},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/pn4.png","hash":"09d83c5099bc52dd28f2aca57e0573bbcdb537dc","modified":1579849165000},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png8.png","hash":"fa3cf2a6fe7af287fbedab5808c00b91d908b9b4","modified":1579849796000},{"_id":"themes/hexo-theme-matery/source/css/.idea/misc.xml","hash":"7df46872d1421797d543d0323da2e81710cc573d","modified":1581048439669},{"_id":"themes/hexo-theme-matery/source/css/.idea/css.iml","hash":"5859c9883f46f9f77ccdd22e90f71b82ef890b22","modified":1581048439657},{"_id":"themes/hexo-theme-matery/source/css/.idea/modules.xml","hash":"a53ab996f29b0771fbb8aafe049d697ed4627ca2","modified":1581048439673},{"_id":"themes/hexo-theme-matery/source/css/.idea/vcs.xml","hash":"2d907a36075e3eccb23ee1a5a91887aefb425ed1","modified":1581048439666},{"_id":"themes/hexo-theme-matery/source/css/.idea/workspace.xml","hash":"9a46c7043dd61b5b24a1fc32d3ff36c56382e7e8","modified":1581048613998},{"_id":"themes/hexo-theme-matery/source/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1581040893748},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1581040893748},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1581040893749},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1581040893749},{"_id":"themes/hexo-theme-matery/source/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1581040893769},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1581040893769},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1581040893769},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1581040893769},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1581040893769},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1581040893769},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1581040893769},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1581040893769},{"_id":"themes/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1581040893770},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1581040893770},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1581040893774},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1581040893775},{"_id":"themes/hexo-theme-matery/source/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1581040893776},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1581040893776},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1581040893776},{"_id":"themes/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1581040893778},{"_id":"themes/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1581040893780},{"_id":"themes/hexo-theme-matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1581040893780},{"_id":"themes/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1581040893780},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1581040893782},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1581040893782},{"_id":"themes/hexo-theme-matery/source/medias/banner/.DS_Store","hash":"99a3634a26c4966562d3707f5782cb51299d2862","modified":1581058431524},{"_id":"themes/hexo-theme-matery/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1581040893787},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/.DS_Store","hash":"a51fbdf4bd580b75581a32513bce826ffbb1341e","modified":1581055123804},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/16.jpg","hash":"9cac6b80b0cc8959fc8aabfbd1adcab79ebebfc9","modified":1581040893789},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/23.jpg","hash":"ed5ac9f616d3b99af5188a10b1761884c37e93e5","modified":1581040893791},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/26.jpg","hash":"f9de6983b5bdbe8879bfdadd1e00968b7d859caa","modified":1580218522702},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/30.jpg","hash":"3905374e9eb53fe8d085f73b28ede75f0156e43d","modified":1580218558538},{"_id":"themes/hexo-theme-matery/source/medias/reward/wechat.jpg","hash":"c04e0c1cbb0b230885a86c2cf5f1e70878ae51b1","modified":1578232965000},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png5.png","hash":"5574107b11f4514b021142ef1aaa0617b926ce07","modified":1579849236000},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1581040893748},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1581040893776},{"_id":"themes/hexo-theme-matery/source/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1581040893777},{"_id":"themes/hexo-theme-matery/source/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1581040893783},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/10.jpg","hash":"838e704942de076c60894d14e5f280e2724b6f68","modified":1581040893788},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/13.jpg","hash":"66706dfde7d910182c2f1dbadd0e9e917630b8dd","modified":1581040893789},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/15.jpg","hash":"5cf9fc64d5d74ab6ba69bb8bff580fdc22ba32d0","modified":1581040893789},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/19.jpg","hash":"57bc7c804b78b5cceb4eb1f9e51b734b75151b71","modified":1581040893790},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/2.jpg","hash":"16f1d89cdba4dce935ac0f12599e0fcfda543a93","modified":1581040893790},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/20.jpg","hash":"8271c4a327632b566ea62f546c083d08a0528e72","modified":1581040893791},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/21.jpg","hash":"d70b088850c3565e5b5bb9eb8fe4abe688c964cf","modified":1581040893791},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/22.jpg","hash":"bf5b59d193e5ca089a7fff034c222bfa2c4dc41f","modified":1581040893791},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/4.jpg","hash":"4eea5bdb5724ef1ed65790e481eda0d2fb176bf0","modified":1581040893792},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/5.jpg","hash":"c3c1f36a1b1886037db604f151f335cd4599e970","modified":1581040893792},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/6.jpg","hash":"c63ff64bdd5f6c82da8804c7248fc519d23eaf0b","modified":1581040893792},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/7.jpg","hash":"a0246a4a560438938489cdd154e35f172b3f31b0","modified":1581040893792},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/8.jpg","hash":"5a46ca4ab4c4ab2101a2af77a31a8878bccc483c","modified":1581040893793},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/9.jpg","hash":"815c84778b721e3606c2bd7c099c7de7c53251ba","modified":1581040893793},{"_id":"themes/hexo-theme-matery/source/medias/reward/alipay.jpg","hash":"0bdcf3d38b52d7a5d77a342f510f82c9b72bc368","modified":1578276441000},{"_id":"source/_posts/Go并发编程初探/png1.png","hash":"88ba01b39a1676816b0d810d1cd091db622da59c","modified":1579520435000},{"_id":"source/_posts/Go并发编程初探/png9.png","hash":"62b92366c6771a4807f7d1021745599c9ce0de6c","modified":1579592834000},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png11.png","hash":"c1001d91b583fe9ebb19c4e222157967a0e340c7","modified":1579850852000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1581040893761},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1581040893762},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1581040893761},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1581040893771},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1581040893777},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1581040893777},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1581040893777},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1581040893777},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1581040893777},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1581040893778},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1581040893778},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1581040893778},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1581040893778},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1581040893778},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.css","hash":"80ae4aa0dba3634dd9bf59586d541d2dd8d8191c","modified":1581040893779},{"_id":"themes/hexo-theme-matery/source/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1581040893781},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1581040893781},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1581040893781},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","hash":"f0a1b849868a6bf351ff98dc3924a4e7254eb88b","modified":1581040893781},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1581040893781},{"_id":"themes/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1581040893782},{"_id":"themes/hexo-theme-matery/source/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1581040893782},{"_id":"themes/hexo-theme-matery/source/medias/banner/0.jpg","hash":"1f2ec55fe7825475fde2601573bb622f0bf2acba","modified":1581040893784},{"_id":"themes/hexo-theme-matery/source/medias/banner/2.jpg","hash":"8d3c8391ff161eec70f66d69e5545a9468cc52ef","modified":1581040893785},{"_id":"themes/hexo-theme-matery/source/medias/banner/3.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1581040893785},{"_id":"themes/hexo-theme-matery/source/medias/banner/5.jpg","hash":"4a08deec1dd5b4f1490e8fc23adfb75a0f88b0c4","modified":1581040893786},{"_id":"themes/hexo-theme-matery/source/medias/banner/6.jpg","hash":"62e9586a8cec91a160f147c424a3d1d1aea360f9","modified":1581040893787},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/0.jpg","hash":"2066cdda98ad0035071cd4aa7bd696eb078c0b6d","modified":1581040893787},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/11.jpg","hash":"9ed45f95b83626e3d91d6c405eb8bfe6fcb9736a","modified":1581040893788},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/12.jpg","hash":"047be4239dd7e0be83243ee6b49a392a61f16b9a","modified":1581040893788},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/14.jpg","hash":"8aeb816faca2d5eaea4cce9e881d6ff87b8c7cf1","modified":1581040893789},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/18.jpg","hash":"ae23fdfaa59bc57b7ed49e90c5d59e4b68e1eea5","modified":1581040893790},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/25.jpg","hash":"fc6f993913242d60f432aa1bbc0c429bffbeca01","modified":1580218514295},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/3.jpg","hash":"5e879652e032f02961a331b598a50b60ebe80a39","modified":1581040893791},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/32.jpg","hash":"b10e7416a9aca816adc196ebc7fedba4d595b3ba","modified":1580218719800},{"_id":"source/_posts/Go-defer-详解/defer.png","hash":"bd2fe0c9e28ac0292b87114cbcbda4fa080f69af","modified":1578403348000},{"_id":"source/_posts/Go并发编程初探/png2.png","hash":"2537171b1e88b443639a3abc5760521156fa0e72","modified":1579520442000},{"_id":"source/_posts/Go并发编程初探/png8.png","hash":"ea50108ab28ac6bd186bfb6f599cea155a807c26","modified":1579583762000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1581040893760},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1581040893760},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1581040893768},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1581040893768},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","hash":"734f56442e62fe55f677e8ccae7f175445667767","modified":1581040893775},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1581040893780},{"_id":"themes/hexo-theme-matery/source/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1581040893784},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/1.jpg","hash":"d16e28bd23ea3a63643826dde5eea6b7a9bdda5d","modified":1581040893788},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/17.jpg","hash":"f168ca5b046d10a878a7b0bcfab540e2c4428887","modified":1581040893789},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/28.jpg","hash":"0a6ac6ba82e9d6eed2ddaa40872356354d362780","modified":1580218718880},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/29.jpg","hash":"a05bbcb30e9d8c1e21954688b55c28e8129309e8","modified":1580218520864},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1581040893749},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1581040893750},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1581040893759},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1581040893759},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.svg","hash":"229afff648cbd17de80176e0feb969c7f514be7e","modified":1581040893761},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1581040893768},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/31.jpg","hash":"96265df01e5142e9e498631280bb315eb69998fb","modified":1580218552338},{"_id":"source/_posts/Go并发编程初探/png7.png","hash":"45af7c7495850c7cc9605c5d4a99fb0c4e7fb05c","modified":1579583546000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1581040893763},{"_id":"themes/hexo-theme-matery/source/medias/banner/1.jpg","hash":"c3d5ab183b39a7140941b8375e29498f9d24f343","modified":1581040893785},{"_id":"themes/hexo-theme-matery/source/medias/banner/4.jpg","hash":"56850c3139cbd72a0eff0c35d8fac32c9c66dd6a","modified":1581040893786},{"_id":"source/_posts/微服务架构-一/2.png","hash":"d8d9e76b9afca962bbf282c363ac3342ee7c15d4","modified":1580965480384},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/27.jpg","hash":"736b064aafddd0feb215648af8490add58a890f3","modified":1580218556184},{"_id":"source/_posts/Go语言基础之并发/1.png","hash":"d3e3ac103f33968d2ad0089bc080dbee2a090e36","modified":1581130682353},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/24.jpg","hash":"d146931089a9cfed501215b460152bb69ff4bb20","modified":1580218569320},{"_id":"source/_posts/Delve调试工具/png10.png","hash":"9634ebcb0b797c3e63d881e96b36b985e9143b05","modified":1579517590000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.svg","hash":"25612c76ded31c497effe46454d8d2bb36fb99d6","modified":1581040893754},{"_id":"themes/hexo-theme-matery/source/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1581040893774},{"_id":"source/_posts/Mac设置文件权限问题/1.png","hash":"adcaf427dcd232956eb17694f8f06794c5e0939d","modified":1581129567929},{"_id":"source/_posts/服务器平滑升级-柔性重启/png1.png","hash":"0fc8edaf4f7bc5b254d2c4f01db0349b636400e5","modified":1579847389000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.svg","hash":"2c026711e4dd6b6d805cc19c0e4a572e6239a05b","modified":1581040893767},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png1.png","hash":"f1740108a7750c912824e4e336e97591ef616e5a","modified":1579858682000},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png12.png","hash":"eca43a9e2ddc407d1a7cf3cb070b31e0493cc099","modified":1579858803000},{"_id":"themes/hexo-theme-matery/source/medias/banner/7.jpg","hash":"abcf234e549e72dae1c17d4cdc6fff65c1454ee0","modified":1580916190000},{"_id":"public/search.xml","hash":"a8e7921bf3c06195eee5fd09ae13e9b00068aae1","modified":1582955860442},{"_id":"public/about/index.html","hash":"2c8ac05a3fe6f42c321a0320384d3be82253ac63","modified":1582955860442},{"_id":"public/categories/index.html","hash":"9172c99b3758a54898b8065fb6afd1f764c8163a","modified":1582955860442},{"_id":"public/contact/index.html","hash":"188f4919260b5e45fbfa69b864101907c8071ca0","modified":1582955860442},{"_id":"public/friends/index.html","hash":"b8de4f70f6a678ddc0fafe810d479131891d54a3","modified":1582955860442},{"_id":"public/tags/index.html","hash":"e1bcb7404a1574ac9e7001ca16ee0cc0ae1c7f97","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/index.html","hash":"f17ea32d51f00290cecff83795314b8371284e1f","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-zhan/index.html","hash":"c47aa9a866ee8cc31204d586b612e331b54bbbe4","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/index.html","hash":"e04ae1744cbd205b15a904e204851f29464c93f9","modified":1582955860442},{"_id":"public/2020/02/10/vmware-fusion-11-gou-mai-de-xu-lie-hao/index.html","hash":"6c89ef944c289467b8292314fedf64deb85208d3","modified":1582955860442},{"_id":"public/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/index.html","hash":"f96f25861c064d301780a5105968c157a3d86505","modified":1582955860442},{"_id":"public/2020/02/08/mac-she-zhi-wen-jian-quan-xian-wen-ti/index.html","hash":"695412e6321392bc1d1697800e126744244989f0","modified":1582955860442},{"_id":"public/2020/02/08/go-yu-yan-ji-chu-zhi-bing-fa/index.html","hash":"138f8e31e81515ce67ce66814981e5e086c785c0","modified":1582955860442},{"_id":"public/2020/02/06/wei-fu-wu-jia-gou-er-wei-fu-wu-zhu-ce-he-fa-xian/index.html","hash":"0f03ab9b3543346ac4e9a91f5d9e79b44e237152","modified":1582955860442},{"_id":"public/2020/02/06/wei-fu-wu-jia-gou-yi/index.html","hash":"d968d9517bd95aea7187bf2d16a4bd5ce932f93c","modified":1582955860442},{"_id":"public/2020/02/05/kubernetes-di-yi-zhang-zu-jian-jian-jie/index.html","hash":"2e95ba65eab05dcc975c98f6c24267974509422c","modified":1582955860442},{"_id":"public/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/index.html","hash":"b61719279d966e8973c52e7e1341d4ebe2d8f65f","modified":1582955860442},{"_id":"public/2020/01/25/fu-wu-qi-ping-hua-sheng-ji-rou-xing-chong-qi/index.html","hash":"6a78ba9c82d3faeca20ae7b380dfeab26a5542ae","modified":1582955860442},{"_id":"public/2020/01/24/shadergraph-xue-xi-zhi-er-rang-li-zi-geng-liang/index.html","hash":"41056f2e9363b4f551d675e75d7d1ac2232be6a2","modified":1582955860442},{"_id":"public/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/index.html","hash":"05a560e678e2bc1ce94b3db7a879acc038e659fa","modified":1582955860442},{"_id":"public/2020/01/21/wang-luo-xie-yi-ji-chu/index.html","hash":"9fc6f8fdea014970d1adf8d5e14cbfce68c26bea","modified":1582955860442},{"_id":"public/2020/01/20/go-bing-fa-bian-cheng-chu-tan/index.html","hash":"8c021b717be8cd9a532bd91fba33ea4795f37c0c","modified":1582955860442},{"_id":"public/2020/01/20/delve-diao-shi-gong-ju/index.html","hash":"47b21f288f8620293ff3e2e74646df50e49e5cce","modified":1582955860442},{"_id":"public/2020/01/20/go-dan-yuan-ce-shi-he-ya-li-ce-shi/index.html","hash":"ea1507b00f808c928babc374291be79c5a52e229","modified":1582955860442},{"_id":"public/2020/01/10/go-chang-yong-yu-fa-tang-pao-dan-gong-ju-ji/index.html","hash":"524cec786534a42b0e41e6b053f07e7cf03618ed","modified":1582955860442},{"_id":"public/2020/01/07/you-xi-zhong-de-si-yuan-shu/index.html","hash":"e70f66521fd74ef37496e99162de04ee4b76570e","modified":1582955860442},{"_id":"public/2020/01/07/nginx-an-zhuang/index.html","hash":"0a5928ef9740b4a1637c8b606deff655fa8261ea","modified":1582955860442},{"_id":"public/2019/07/10/blender-xue-xi-zhang/index.html","hash":"ede5b1d1d4160291c6927e47b803a73f947d4c79","modified":1582955860442},{"_id":"public/2019/04/21/go-defer-xiang-jie/index.html","hash":"ca77930e472f0e1a19a505a5887feab6aaedf05b","modified":1582955860442},{"_id":"public/2018/01/06/hexo-bo-ke-da-jian/index.html","hash":"a775e4c04d7794691a83876afdc3e50b2af730b1","modified":1582955860442},{"_id":"public/index.html","hash":"d6c8cb52343cac1fddd4b6995bb5f701213e37d0","modified":1582955860442},{"_id":"public/page/2/index.html","hash":"2cee2fb5d8b81ebfc74da21fa0f3428542940470","modified":1582955860442},{"_id":"public/categories/Go栈/index.html","hash":"e7f44e30c3004c731a2a0a9cfea4641c43bcf10b","modified":1582955860442},{"_id":"public/categories/Go栈/page/2/index.html","hash":"505cf9a5604f8e1a5cf77bfa52ef1c3cacbd3f19","modified":1582955860442},{"_id":"public/categories/Tips/index.html","hash":"e9780661b44579f736d728e6fd5b2aa7b5abadf0","modified":1582955860442},{"_id":"public/categories/游戏栈/index.html","hash":"4c5699557ea802a31943b705984bbbf42d9ba363","modified":1582955860442},{"_id":"public/categories/tcp-ip协议/index.html","hash":"125aee4374108221f388dcc3f263074658847224","modified":1582955860442},{"_id":"public/archives/index.html","hash":"9fb7b49083008e85cc80f3b14227c71727441f84","modified":1582955860442},{"_id":"public/archives/page/2/index.html","hash":"dc25d76ad0baf667013a3ac582fcd4e954218c73","modified":1582955860442},{"_id":"public/archives/page/3/index.html","hash":"af7e3cb4146364953e8edb7189649f058577449f","modified":1582955860442},{"_id":"public/archives/2018/index.html","hash":"0cbc976260ef074d04a40e214df2a01fe348a796","modified":1582955860442},{"_id":"public/archives/2018/01/index.html","hash":"e2614ec1f44c0704b7f466eb5b800fd35dfb09de","modified":1582955860442},{"_id":"public/archives/2019/index.html","hash":"ee30bff25581ce2c9bbfa9e2903dced232e98be0","modified":1582955860442},{"_id":"public/archives/2019/04/index.html","hash":"fa663acbddf83c4e2dac37d4038cd4e0b5cb2c43","modified":1582955860442},{"_id":"public/archives/2019/07/index.html","hash":"5be67b409d9b9dad195f68f069db3f661140aa4f","modified":1582955860442},{"_id":"public/archives/2020/index.html","hash":"d2da6ee3a515df33ef25f7aa09d51f0f37a9e440","modified":1582955860442},{"_id":"public/archives/2020/page/2/index.html","hash":"dfc58dff23a86e39d587f13354b817d42ed3a370","modified":1582955860442},{"_id":"public/archives/2020/page/3/index.html","hash":"d20d2e7c980022fac8fed2db70b8ca101fd650e2","modified":1582955860442},{"_id":"public/archives/2020/01/index.html","hash":"ca5c95cd07106e4d650ef58e024a39af7ce83ccb","modified":1582955860442},{"_id":"public/archives/2020/01/page/2/index.html","hash":"39662ae32ed97ee713890bf259b81531d0aaa3e5","modified":1582955860442},{"_id":"public/archives/2020/02/index.html","hash":"92a2939eb0a37936005378afb6b36bc36868eb65","modified":1582955860442},{"_id":"public/tags/Go/index.html","hash":"47548af5925f37d6ee25d455c7f10cc07bad9350","modified":1582955860442},{"_id":"public/tags/Go/page/2/index.html","hash":"3da0abf3d965d9de2ce971ecb4658d1eed30673f","modified":1582955860442},{"_id":"public/tags/服务端开发/index.html","hash":"e5ca0dadf4d7f07423c4b411393a3f204f481dd4","modified":1582955860442},{"_id":"public/tags/网络协议/index.html","hash":"c5ea5c85c5837992439963c6e00719b1b3966723","modified":1582955860442},{"_id":"public/tags/软件测试/index.html","hash":"8f950b0e0622e08912541664631b3a1ee52f7586","modified":1582955860442},{"_id":"public/tags/并发编程/index.html","hash":"4504634d0de723499cc66828d70909e3f7cac320","modified":1582955860442},{"_id":"public/tags/服务器编程/index.html","hash":"9bc92cd3079311e6ee72b688d266bfc329f6df89","modified":1582955860442},{"_id":"public/tags/并发/index.html","hash":"2fbb45d11ec3d75daf19b2118f63871eac600359","modified":1582955860442},{"_id":"public/tags/Kubernetes/index.html","hash":"de93e0ecb8cac2900ae31100a7026856484d6f82","modified":1582955860442},{"_id":"public/tags/Micro-Service/index.html","hash":"d070e42733a342608aaa8ac3d8127a6fa62ca96e","modified":1582955860442},{"_id":"public/tags/微服务/index.html","hash":"4a9631e30f67b07fc2212f92c9171df7c1145c23","modified":1582955860442},{"_id":"public/tags/Mac/index.html","hash":"089afb06ba998d2ad7fcc387f6ce7d03584f819c","modified":1582955860442},{"_id":"public/tags/文件权限/index.html","hash":"1785b63a92fed4c5465e3ecd292a45207c2ae9c8","modified":1582955860442},{"_id":"public/tags/Ngix/index.html","hash":"703017df54b464fc8b34ddd30623988b1260d827","modified":1582955860442},{"_id":"public/tags/VMware-fusion/index.html","hash":"5a83a9fef8f327fe104ba27bbecc83d9d450f45f","modified":1582955860442},{"_id":"public/tags/游戏美术/index.html","hash":"8e14139e7cc0ff59893a45faa1223d58e4763c39","modified":1582955860442},{"_id":"public/tags/建模/index.html","hash":"b4a418b96eac1cb7d4a63ad5599fb8e30cd80952","modified":1582955860442},{"_id":"public/tags/tcp-ip协议/index.html","hash":"759708246b6c824fc95e6a87dc0250db59bac493","modified":1582955860442},{"_id":"public/tags/Unity/index.html","hash":"4b46966bc1fdd335cf48df428f5876935a806ac3","modified":1582955860442},{"_id":"public/tags/游戏开发/index.html","hash":"99faa343577cbe1379c659eb60bad411a3c60655","modified":1582955860442},{"_id":"public/tags/图形学/index.html","hash":"f0fb06955d21a7eb5087ae8493cf7627c22b2b09","modified":1582955860442},{"_id":"public/favicon.png","hash":"b7c469c10c52906bfcb44841064b1fb9a0bd13e3","modified":1582955860442},{"_id":"public/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1582955860442},{"_id":"public/medias/icp.png","hash":"5d1a1f3051c8a4ad70afa0a5488dfa7f0bb27bd5","modified":1582955860442},{"_id":"public/medias/featureimages/16.jpg","hash":"9cac6b80b0cc8959fc8aabfbd1adcab79ebebfc9","modified":1582955860442},{"_id":"public/medias/featureimages/23.jpg","hash":"ed5ac9f616d3b99af5188a10b1761884c37e93e5","modified":1582955860442},{"_id":"public/medias/featureimages/26.jpg","hash":"f9de6983b5bdbe8879bfdadd1e00968b7d859caa","modified":1582955860442},{"_id":"public/medias/featureimages/30.jpg","hash":"3905374e9eb53fe8d085f73b28ede75f0156e43d","modified":1582955860442},{"_id":"public/medias/reward/wechat.jpg","hash":"c04e0c1cbb0b230885a86c2cf5f1e70878ae51b1","modified":1582955860442},{"_id":"public/medias/featureimages/13.jpg","hash":"66706dfde7d910182c2f1dbadd0e9e917630b8dd","modified":1582955860442},{"_id":"public/medias/featureimages/15.jpg","hash":"5cf9fc64d5d74ab6ba69bb8bff580fdc22ba32d0","modified":1582955860442},{"_id":"public/medias/featureimages/2.jpg","hash":"16f1d89cdba4dce935ac0f12599e0fcfda543a93","modified":1582955860442},{"_id":"public/medias/featureimages/22.jpg","hash":"bf5b59d193e5ca089a7fff034c222bfa2c4dc41f","modified":1582955860442},{"_id":"public/medias/featureimages/21.jpg","hash":"d70b088850c3565e5b5bb9eb8fe4abe688c964cf","modified":1582955860442},{"_id":"public/medias/featureimages/5.jpg","hash":"c3c1f36a1b1886037db604f151f335cd4599e970","modified":1582955860442},{"_id":"public/medias/featureimages/7.jpg","hash":"a0246a4a560438938489cdd154e35f172b3f31b0","modified":1582955860442},{"_id":"public/medias/featureimages/8.jpg","hash":"5a46ca4ab4c4ab2101a2af77a31a8878bccc483c","modified":1582955860442},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1582955860442},{"_id":"public/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1582955860442},{"_id":"public/medias/reward/alipay.jpg","hash":"0bdcf3d38b52d7a5d77a342f510f82c9b72bc368","modified":1582955860442},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1582955860442},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1582955860442},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1582955860442},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1582955860442},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1582955860442},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1582955860442},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1582955860442},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1582955860442},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1582955860442},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1582955860442},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1582955860442},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"f0a1b849868a6bf351ff98dc3924a4e7254eb88b","modified":1582955860442},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1582955860442},{"_id":"public/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1582955860442},{"_id":"public/2020/01/10/go-chang-yong-yu-fa-tang-pao-dan-gong-ju-ji/suga.jpg","hash":"85de5b1f120daaf1d9e7f35c3a3746c5f8eb15b1","modified":1582955860442},{"_id":"public/2020/01/20/delve-diao-shi-gong-ju/start.jpg","hash":"becb69160b2cd7636c8782b81e17c1fffffbcf2b","modified":1582955860442},{"_id":"public/2020/01/10/go-chang-yong-yu-fa-tang-pao-dan-gong-ju-ji/p1.jpg","hash":"c043e9409836ad2b85481cbd4e36f64d2f0897cb","modified":1582955860442},{"_id":"public/2020/02/05/kubernetes-di-yi-zhang-zu-jian-jian-jie/mesos.jpg","hash":"e884cddb0a6f1f21429860881c31226651028389","modified":1582955860442},{"_id":"public/2019/07/10/blender-xue-xi-zhang/end.jpg","hash":"400cff8af3b1f098dd1857ffb7a0267008a7165e","modified":1582955860442},{"_id":"public/2019/07/10/blender-xue-xi-zhang/start.jpg","hash":"8d8519843c530e1bd284d94fcc459ca4796961d2","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-zhan/1.jpg","hash":"dc9af39084ca0e8d68979d49535607517a8b7067","modified":1582955860442},{"_id":"public/2018/01/06/hexo-bo-ke-da-jian/Hexo.jpg","hash":"186afa4cc9bdab4df8e0739100047f01fdb5c3d6","modified":1582955860442},{"_id":"public/2018/01/06/hexo-bo-ke-da-jian/hexothemes.jpg","hash":"9669f810d09e2dfa4b77c07192c9b65a665f4422","modified":1582955860442},{"_id":"public/2018/01/06/hexo-bo-ke-da-jian/hexo_config.png","hash":"0927182659dae466545979bbafc2f69ca683d8a9","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-zhan/2.jpg","hash":"6646278265c4ae4bf1a7164cf97e1d1a21bba8d0","modified":1582955860442},{"_id":"public/2020/01/07/nginx-an-zhuang/nginx.jpg","hash":"4907f68f7b4dbc362d00920b90ea1bd6d6074660","modified":1582955860442},{"_id":"public/2020/01/07/nginx-an-zhuang/bash.png","hash":"ca14b543c91943baddf79f912d9fa74b0ed042c2","modified":1582955860442},{"_id":"public/2020/01/07/nginx-an-zhuang/default.jpg","hash":"a78289374d26aeb00b6381075e2937c7c4d79634","modified":1582955860442},{"_id":"public/2020/01/07/nginx-an-zhuang/start.png","hash":"f74662ea20a14977ee5bc8f1ba9690066c2b396a","modified":1582955860442},{"_id":"public/2020/02/06/wei-fu-wu-jia-gou-er-wei-fu-wu-zhu-ce-he-fa-xian/1.png","hash":"ae67b2330378f1af8970048f4872534626b8daa8","modified":1582955860442},{"_id":"public/2020/02/06/wei-fu-wu-jia-gou-er-wei-fu-wu-zhu-ce-he-fa-xian/2.png","hash":"4192c91a5cb167675bb14f6ea313969798225319","modified":1582955860442},{"_id":"public/2020/02/06/wei-fu-wu-jia-gou-er-wei-fu-wu-zhu-ce-he-fa-xian/3.jpg","hash":"9851637d1d50206f46d433c659859dff0a611389","modified":1582955860442},{"_id":"public/2020/01/21/wang-luo-xie-yi-ji-chu/a.jpg","hash":"602b0f814328dafbd5544337fdd779045726499d","modified":1582955860442},{"_id":"public/2020/01/21/wang-luo-xie-yi-ji-chu/level.jpg","hash":"823e8c68e9cc18e86433d9a8fe23d28f852dc418","modified":1582955860442},{"_id":"public/2020/01/21/wang-luo-xie-yi-ji-chu/http.jpg","hash":"2b1f33e5e9ceb8f9569ea4ceeb60e985a6330929","modified":1582955860442},{"_id":"public/2020/01/20/go-dan-yuan-ce-shi-he-ya-li-ce-shi/start.png","hash":"37aafce693f838527eb6576e7e3123a26b97da27","modified":1582955860442},{"_id":"public/2020/02/06/wei-fu-wu-jia-gou-yi/1.png","hash":"4ebd81e0e9585f85ecc992e251f05a7822dacc3d","modified":1582955860442},{"_id":"public/2020/02/06/wei-fu-wu-jia-gou-yi/3.jpg","hash":"19d14d61ee142323fcec64eff48da2b50080ee6a","modified":1582955860442},{"_id":"public/2020/02/06/wei-fu-wu-jia-gou-yi/4.jpg","hash":"f4e1940920285220c3e4289c77d1379473e5f5e7","modified":1582955860442},{"_id":"public/2020/02/06/wei-fu-wu-jia-gou-yi/start.png","hash":"3905374e9eb53fe8d085f73b28ede75f0156e43d","modified":1582955860442},{"_id":"public/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/jpg3.jpg","hash":"22b9588fb38890bc09961cd736235abfbe052f64","modified":1582955860442},{"_id":"public/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/png5.png","hash":"e35d9d610d73d16eb06d4ba1439664d298c87114","modified":1582955860442},{"_id":"public/2020/01/20/go-bing-fa-bian-cheng-chu-tan/lock.jpg","hash":"8ec1b70d907e51ade9cd9754b90b90b6fcc13154","modified":1582955860442},{"_id":"public/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/start.png","hash":"3905374e9eb53fe8d085f73b28ede75f0156e43d","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/10.jpg","hash":"9439e78df88951cd376ffb71f25c4d1ecc731852","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/11.jpg","hash":"3978baf16d88f165984785a99310cc6a9bb70646","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/12.jpg","hash":"227c9accc2a5b2af1624f2a103a2558d1161722e","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/13.jpg","hash":"b738ef01bc4289b979c484eeef7766c722c135b1","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/4.jpg","hash":"7797dd81eb530df18ae72a4f566d64c79f2fda58","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/3.jpg","hash":"2632b0faba9e551590fcc921bac8be9f4952cd0b","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/5.jpg","hash":"77e3f6f5461c8d2ae701a98b7064a37bf1768924","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/6.jpg","hash":"8b21c0ece27b328deab9d5e0ec1c3169e33750dd","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/7.jpg","hash":"cd91e304f1d4392e703f33714d35c1f68a2ba3d3","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/8.jpg","hash":"530b5659da060f076c5222813157c3a262027c04","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/9.jpg","hash":"3fb4a489e0fdc0232649e0a615c566dc327bd2b1","modified":1582955860442},{"_id":"public/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png10.png","hash":"b008ff67ec27479bca9942e23b5b5f2798ffbba9","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/14.jpg","hash":"2cb36467a433df6e8df9b59b899c86f08cd76a54","modified":1582955860442},{"_id":"public/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png9.png","hash":"826b72b8dc8deab6c77ca80135cfbdb8245df0b8","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/15.jpg","hash":"6c74f0271191d8bf89660a6a54852225e52f37db","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/18.jpg","hash":"5f36b7b76b9b10b33ed8a903bea8df8300356bba","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/16.jpg","hash":"06f1b0dd293bd4583109ddbea5a8f9b940cb95a0","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/20.jpg","hash":"a72a7e627cc1cbdbaf48c487738747c0ef2d1b7c","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/19.jpg","hash":"5f36b7b76b9b10b33ed8a903bea8df8300356bba","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/23.jpg","hash":"5bd5fac6f20eff324ed8aba28940ec14258d9e6f","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/22.jpg","hash":"7859cfdcd540935311500125d760609775e0bbe0","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/24.jpg","hash":"20273f4c1eef920897c91866ab23c77602ad9744","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/25.jpg","hash":"39de267af45f843045c1823e83081e3e2d9770eb","modified":1582955860442},{"_id":"public/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/10.png","hash":"948c71db7cbfa4f2625ea25edeb81dd965c72c19","modified":1582955860442},{"_id":"public/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/11.png","hash":"630f4d51b52f8a0153727bd26c46bd8bea0875a1","modified":1582955860442},{"_id":"public/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/12.png","hash":"0e4e58294322f7c3a6f940657b2a8b97d7c51467","modified":1582955860442},{"_id":"public/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/13.png","hash":"d41312b7f6a16a770b149763cf9691d12d47d245","modified":1582955860442},{"_id":"public/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/15.png","hash":"bc6be7d9ed07c306ae7b70be865f1f95306b362f","modified":1582955860442},{"_id":"public/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/4.png","hash":"c3868acd64a252f61dc14ddc0dfb31d8a7e231a9","modified":1582955860442},{"_id":"public/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/5.png","hash":"03186422a97304d3a4c067e82a9e0dea88536b67","modified":1582955860442},{"_id":"public/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/16.png","hash":"08d48b726addcc4d56e8b8b5cb7a6fa1bed5248c","modified":1582955860442},{"_id":"public/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/6.png","hash":"bdac5843c1b97b0e18491db85bee9fba2273162d","modified":1582955860442},{"_id":"public/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/7.png","hash":"89b677f9397af758e432c18c1003b973348cfb6b","modified":1582955860442},{"_id":"public/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/8.png","hash":"ea858d0f59ee367cd074ae472a3afa7c12d4d903","modified":1582955860442},{"_id":"public/2020/01/07/you-xi-zhong-de-si-yuan-shu/show.jpg","hash":"0a573bfa5770eefe77e7c4a464dfd0ff3d024856","modified":1582955860442},{"_id":"public/2020/01/07/you-xi-zhong-de-si-yuan-shu/show1.png","hash":"f578efe5743487b247b53e601cb50cb83f6bc252","modified":1582955860442},{"_id":"public/2020/01/07/you-xi-zhong-de-si-yuan-shu/rotation.jpg","hash":"bba16c4a2da4d34752ec5c8aafef7a16dac38893","modified":1582955860442},{"_id":"public/2020/01/07/you-xi-zhong-de-si-yuan-shu/show2.png","hash":"f49bc631cb1da8911ea02521e00493917a0d70a2","modified":1582955860442},{"_id":"public/2020/01/07/you-xi-zhong-de-si-yuan-shu/show3.png","hash":"aba465a243788cbbafdf2e129fdfbf4f8bd12b0a","modified":1582955860442},{"_id":"public/2020/01/07/you-xi-zhong-de-si-yuan-shu/show4.png","hash":"fc585c865439b0668c307d8a232ce8b1de621a6e","modified":1582955860442},{"_id":"public/2020/01/07/you-xi-zhong-de-si-yuan-shu/show5.png","hash":"29589e5423fe79d5688f19f36bd2dd3833097bff","modified":1582955860442},{"_id":"public/2020/01/07/you-xi-zhong-de-si-yuan-shu/show6.png","hash":"f28b5bfb97439afdfb67aef54181f00467dbdca2","modified":1582955860442},{"_id":"public/2020/01/07/you-xi-zhong-de-si-yuan-shu/show7.jpg","hash":"a522f843b0cdaeef76702a9169b211b4e96b1b0b","modified":1582955860442},{"_id":"public/2020/01/07/you-xi-zhong-de-si-yuan-shu/show8.png","hash":"327fb889891ad8b831ff964a9ce6114d8635fb08","modified":1582955860442},{"_id":"public/2020/01/07/you-xi-zhong-de-si-yuan-shu/show9.png","hash":"c294f7d09091befc5df41bd9e2013f72c8849d17","modified":1582955860442},{"_id":"public/2020/01/07/you-xi-zhong-de-si-yuan-shu/start.png","hash":"f9de6983b5bdbe8879bfdadd1e00968b7d859caa","modified":1582955860442},{"_id":"public/css/prism-tomorrow.css","hash":"3b99487dfc9b4e51e9105a93743b92a761840e34","modified":1582955860442},{"_id":"public/medias/avatar.jpg","hash":"b7c469c10c52906bfcb44841064b1fb9a0bd13e3","modified":1582955860442},{"_id":"public/medias/logo.png","hash":"79c588ec260b7d9a22cb4997acedaa182cf0542f","modified":1582955860442},{"_id":"public/medias/featureimages/10.jpg","hash":"838e704942de076c60894d14e5f280e2724b6f68","modified":1582955860442},{"_id":"public/medias/featureimages/19.jpg","hash":"57bc7c804b78b5cceb4eb1f9e51b734b75151b71","modified":1582955860442},{"_id":"public/medias/featureimages/20.jpg","hash":"8271c4a327632b566ea62f546c083d08a0528e72","modified":1582955860442},{"_id":"public/medias/featureimages/4.jpg","hash":"4eea5bdb5724ef1ed65790e481eda0d2fb176bf0","modified":1582955860442},{"_id":"public/medias/featureimages/6.jpg","hash":"c63ff64bdd5f6c82da8804c7248fc519d23eaf0b","modified":1582955860442},{"_id":"public/medias/featureimages/9.jpg","hash":"815c84778b721e3606c2bd7c099c7de7c53251ba","modified":1582955860442},{"_id":"public/medias/banner/2.jpg","hash":"8d3c8391ff161eec70f66d69e5545a9468cc52ef","modified":1582955860442},{"_id":"public/medias/banner/0.jpg","hash":"1f2ec55fe7825475fde2601573bb622f0bf2acba","modified":1582955860442},{"_id":"public/medias/featureimages/0.jpg","hash":"2066cdda98ad0035071cd4aa7bd696eb078c0b6d","modified":1582955860442},{"_id":"public/medias/featureimages/11.jpg","hash":"9ed45f95b83626e3d91d6c405eb8bfe6fcb9736a","modified":1582955860442},{"_id":"public/medias/featureimages/12.jpg","hash":"047be4239dd7e0be83243ee6b49a392a61f16b9a","modified":1582955860442},{"_id":"public/medias/featureimages/14.jpg","hash":"8aeb816faca2d5eaea4cce9e881d6ff87b8c7cf1","modified":1582955860442},{"_id":"public/medias/featureimages/18.jpg","hash":"ae23fdfaa59bc57b7ed49e90c5d59e4b68e1eea5","modified":1582955860442},{"_id":"public/medias/featureimages/3.jpg","hash":"5e879652e032f02961a331b598a50b60ebe80a39","modified":1582955860442},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1582955860442},{"_id":"public/medias/featureimages/32.jpg","hash":"b10e7416a9aca816adc196ebc7fedba4d595b3ba","modified":1582955860442},{"_id":"public/medias/featureimages/25.jpg","hash":"fc6f993913242d60f432aa1bbc0c429bffbeca01","modified":1582955860442},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1582955860442},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1582955860442},{"_id":"public/medias/featureimages/17.jpg","hash":"f168ca5b046d10a878a7b0bcfab540e2c4428887","modified":1582955860442},{"_id":"public/medias/featureimages/1.jpg","hash":"d16e28bd23ea3a63643826dde5eea6b7a9bdda5d","modified":1582955860442},{"_id":"public/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1582955860442},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1582955860442},{"_id":"public/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1582955860442},{"_id":"public/medias/featureimages/31.jpg","hash":"96265df01e5142e9e498631280bb315eb69998fb","modified":1582955860442},{"_id":"public/2020/02/05/kubernetes-di-yi-zhang-zu-jian-jian-jie/dockerswarm.png","hash":"3015a60d6403ae9534d78d2593b2193c827b4612","modified":1582955860442},{"_id":"public/2018/01/06/hexo-bo-ke-da-jian/start.png","hash":"88e7db3c41cc1b3d352b64a8a3018fdc303c1374","modified":1582955860442},{"_id":"public/2020/02/06/wei-fu-wu-jia-gou-er-wei-fu-wu-zhu-ce-he-fa-xian/start.png","hash":"b10e7416a9aca816adc196ebc7fedba4d595b3ba","modified":1582955860442},{"_id":"public/2020/01/20/go-dan-yuan-ce-shi-he-ya-li-ce-shi/png2.png","hash":"3f06e21e1b137c326595ba9afc14db122a6356bd","modified":1582955860442},{"_id":"public/2020/01/21/wang-luo-xie-yi-ji-chu/tcp.jpg","hash":"b273ed148690779dae4dc9b4e15e986c8afe8da9","modified":1582955860442},{"_id":"public/2020/01/20/go-dan-yuan-ce-shi-he-ya-li-ce-shi/png1.png","hash":"ed03bed2eba867c4a8faf451e386d04d48101474","modified":1582955860442},{"_id":"public/2020/01/20/go-dan-yuan-ce-shi-he-ya-li-ce-shi/png3.png","hash":"67a3b4127552aaadd706e9083a4503585a187d99","modified":1582955860442},{"_id":"public/2020/01/20/go-dan-yuan-ce-shi-he-ya-li-ce-shi/png4.png","hash":"1e4e88982491cfbace05ef41dfad33842321210a","modified":1582955860442},{"_id":"public/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/png1.png","hash":"94263b02f079b432a4fc45d063c3f8b5bc269e9c","modified":1582955860442},{"_id":"public/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/png2.png","hash":"266b97b8af3004ded22cd9e734371879aaf5d986","modified":1582955860442},{"_id":"public/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/png4.png","hash":"fee2b06a8de41af030d3039835ed493ccf76ca6f","modified":1582955860442},{"_id":"public/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png2.png","hash":"c1710db52cb8ed01945f02bee568a0bdd6382a57","modified":1582955860442},{"_id":"public/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png6.png","hash":"2dac271d1705b1d6f380f42271029f01dcd3f9ff","modified":1582955860442},{"_id":"public/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png3.png","hash":"5399fa0cd4515358e46635562b48a13f74f7a9ff","modified":1582955860442},{"_id":"public/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png7.png","hash":"eddbb4873872f4f552d7f74a545f7b8dd1894295","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/17.jpg","hash":"67dc86ef74db3a33ef3ab009afd21209e758566e","modified":1582955860442},{"_id":"public/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/21.jpg","hash":"833096336da3e83fee3f5b3c2611e50734c4bd0b","modified":1582955860442},{"_id":"public/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/9.png","hash":"9eae587c93e502ab4bc1e5b8bbb3578abc3052c9","modified":1582955860442},{"_id":"public/css/my.css","hash":"10577fbc30f241b126d1b51b1f56136ecba86b19","modified":1582955860442},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1582955860442},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1582955860442},{"_id":"public/js/matery.js","hash":"07ed4f743a497d7850b3fdda2a5d9beccc5a8fb5","modified":1582955860442},{"_id":"public/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1582955860442},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1582955860442},{"_id":"public/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1582955860442},{"_id":"public/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1582955860442},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1582955860442},{"_id":"public/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1582955860442},{"_id":"public/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1582955860442},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1582955860442},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1582955860442},{"_id":"public/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1582955860442},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1582955860442},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1582955860442},{"_id":"public/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1582955860442},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1582955860442},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1582955860442},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1582955860442},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1582955860442},{"_id":"public/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1582955860442},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1582955860442},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1582955860442},{"_id":"public/css/matery.css","hash":"aef647fafa622074fd45532588595773ce43848d","modified":1582955860442},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1582955860442},{"_id":"public/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1582955860442},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1582955860442},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1582955860442},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1582955860442},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1582955860442},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1582955860442},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1582955860442},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1582955860442},{"_id":"public/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1582955860442},{"_id":"public/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1582955860442},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1582955860442},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1582955860442},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1582955860442},{"_id":"public/libs/materialize/materialize.min.css","hash":"580459a012f556fba86438953062013a94b201af","modified":1582955860442},{"_id":"public/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1582955860442},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1582955860442},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"734f56442e62fe55f677e8ccae7f175445667767","modified":1582955860442},{"_id":"public/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1582955860442},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1582955860442},{"_id":"public/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1582955860442},{"_id":"public/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1582955860442},{"_id":"public/medias/banner/5.jpg","hash":"4a08deec1dd5b4f1490e8fc23adfb75a0f88b0c4","modified":1582955860442},{"_id":"public/medias/banner/6.jpg","hash":"62e9586a8cec91a160f147c424a3d1d1aea360f9","modified":1582955860442},{"_id":"public/medias/banner/3.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1582955860442},{"_id":"public/medias/featureimages/28.jpg","hash":"0a6ac6ba82e9d6eed2ddaa40872356354d362780","modified":1582955860442},{"_id":"public/medias/featureimages/29.jpg","hash":"a05bbcb30e9d8c1e21954688b55c28e8129309e8","modified":1582955860442},{"_id":"public/libs/awesome/webfonts/fa-regular-400.svg","hash":"229afff648cbd17de80176e0feb969c7f514be7e","modified":1582955860442},{"_id":"public/medias/banner/1.jpg","hash":"c3d5ab183b39a7140941b8375e29498f9d24f343","modified":1582955860442},{"_id":"public/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png6.png","hash":"e01af0187ae42f4b12a3564f81af3c247f2b9988","modified":1582955860442},{"_id":"public/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/pn4.png","hash":"09d83c5099bc52dd28f2aca57e0573bbcdb537dc","modified":1582955860442},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1582955860442},{"_id":"public/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1582955860442},{"_id":"public/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png5.png","hash":"5574107b11f4514b021142ef1aaa0617b926ce07","modified":1582955860442},{"_id":"public/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png8.png","hash":"fa3cf2a6fe7af287fbedab5808c00b91d908b9b4","modified":1582955860442},{"_id":"public/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1582955860442},{"_id":"public/medias/featureimages/24.jpg","hash":"d146931089a9cfed501215b460152bb69ff4bb20","modified":1582955860442},{"_id":"public/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png1.png","hash":"88ba01b39a1676816b0d810d1cd091db622da59c","modified":1582955860442},{"_id":"public/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png9.png","hash":"62b92366c6771a4807f7d1021745599c9ce0de6c","modified":1582955860442},{"_id":"public/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png11.png","hash":"c1001d91b583fe9ebb19c4e222157967a0e340c7","modified":1582955860442},{"_id":"public/2019/04/21/go-defer-xiang-jie/defer.png","hash":"bd2fe0c9e28ac0292b87114cbcbda4fa080f69af","modified":1582955860442},{"_id":"public/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png7.png","hash":"45af7c7495850c7cc9605c5d4a99fb0c4e7fb05c","modified":1582955860442},{"_id":"public/medias/banner/4.jpg","hash":"56850c3139cbd72a0eff0c35d8fac32c9c66dd6a","modified":1582955860442},{"_id":"public/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png8.png","hash":"ea50108ab28ac6bd186bfb6f599cea155a807c26","modified":1582955860442},{"_id":"public/medias/featureimages/27.jpg","hash":"736b064aafddd0feb215648af8490add58a890f3","modified":1582955860442},{"_id":"public/2020/02/06/wei-fu-wu-jia-gou-yi/2.png","hash":"d8d9e76b9afca962bbf282c363ac3342ee7c15d4","modified":1582955860442},{"_id":"public/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png2.png","hash":"2537171b1e88b443639a3abc5760521156fa0e72","modified":1582955860442},{"_id":"public/2020/02/08/go-yu-yan-ji-chu-zhi-bing-fa/1.png","hash":"d3e3ac103f33968d2ad0089bc080dbee2a090e36","modified":1582955860442},{"_id":"public/2020/01/20/delve-diao-shi-gong-ju/png10.png","hash":"9634ebcb0b797c3e63d881e96b36b985e9143b05","modified":1582955860442},{"_id":"public/libs/awesome/webfonts/fa-brands-400.svg","hash":"25612c76ded31c497effe46454d8d2bb36fb99d6","modified":1582955860442},{"_id":"public/libs/awesome/webfonts/fa-solid-900.svg","hash":"2c026711e4dd6b6d805cc19c0e4a572e6239a05b","modified":1582955860442},{"_id":"public/2020/01/25/fu-wu-qi-ping-hua-sheng-ji-rou-xing-chong-qi/png1.png","hash":"0fc8edaf4f7bc5b254d2c4f01db0349b636400e5","modified":1582955860442},{"_id":"public/2020/02/08/mac-she-zhi-wen-jian-quan-xian-wen-ti/1.png","hash":"adcaf427dcd232956eb17694f8f06794c5e0939d","modified":1582955860442},{"_id":"public/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png12.png","hash":"eca43a9e2ddc407d1a7cf3cb070b31e0493cc099","modified":1582955860442},{"_id":"public/medias/banner/7.jpg","hash":"abcf234e549e72dae1c17d4cdc6fff65c1454ee0","modified":1582955860442},{"_id":"public/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png1.png","hash":"f1740108a7750c912824e4e336e97591ef616e5a","modified":1582955860442}],"Category":[{"name":"Go栈","_id":"ck7771rj00004zd5bbg119j56"},{"name":"Tips","_id":"ck7771rjg000tzd5b5iu3crqa"},{"name":"游戏栈","_id":"ck7771rjk0012zd5bb9ef4pn9"},{"name":"tcp/ip协议","_id":"ck7771rjo001hzd5bd5f718gk"}],"Data":[{"_id":"friends","data":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]},{"_id":"music","data":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}],"Page":[{"title":"about","date":"2020-02-07T02:08:04.000Z","type":"about","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-02-07 10:08:04\ntype: \"about\"\nlayout: \"about\"\n---\n","updated":"2020-02-07T02:08:39.030Z","path":"about/index.html","comments":1,"_id":"ck7771rix0001zd5bgm8021p2","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":""},{"title":"categories","date":"2020-02-07T02:05:42.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-02-07 10:05:42\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2020-02-07T02:06:50.805Z","path":"categories/index.html","comments":1,"_id":"ck7771riz0003zd5b25rleqsz","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":""},{"title":"contact","date":"2020-02-07T02:08:49.000Z","type":"contact","layout":"contact","_content":"","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2020-02-07 10:08:49\ntype: \"contact\"\nlayout: \"contact\"\n---\n","updated":"2020-02-07T02:09:21.299Z","path":"contact/index.html","comments":1,"_id":"ck7771rj20007zd5bh8nqhkpj","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":""},{"title":"friends","date":"2020-02-07T02:09:34.000Z","type":"friends","layout":"friends","_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2020-02-07 10:09:34\ntype: \"friends\"\nlayout: \"friends\"\n---\n","updated":"2020-02-07T02:09:59.831Z","path":"friends/index.html","comments":1,"_id":"ck7771rkn003yzd5b2mmc80f1","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":""},{"title":"tags","date":"2020-02-07T02:07:13.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-02-07 10:07:13\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2020-02-07T02:08:01.099Z","path":"tags/index.html","comments":1,"_id":"ck7771rko003zzd5bcozg36ee","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":""}],"Post":[{"title":"Delve调试工具","date":"2020-01-20T02:58:52.000Z","_content":"\n![](/start.jpg)\n\n# Delve调试工具\n\n​    为什么会选择delve呢，很多时候我们会把调试日志和运行时日志用自己能够处理的方式存储起来，比如说直接在开发阶段用log工具，在先上阶段使用日志库文件存储程序运行时的异常信息和不确定性的运行结果，或者是用kafka工具来接受导出管理日志。但是这一些都算是事后的事儿了，我们通过他们进行日志相关的查阅，像侦探一样一条一条的去发现线索。这个在一些特定情况下，比如无法重现，必须追踪调用栈，知道每个变量的运行时的值等一些列问题时，log工具显得有点手短了，而这一些delve工具可以很好的帮我们解决。\n\nDlv，也称为Delve，是Go语言的源码调试工具。由derekparker开发，开源在Github。在Mac上配置Go语言开发环境的时候，经常碰到的问题就是Dlv调用总是不成功，无法启动应用，无法调试等等。大部分的问题都与Mac的安全机制有关。Mac上使用codesign对应用进行签名，没有签名的程序会受到一些限制，例如无法作为调试程序。\n\nDelve是一个第三方的工具，所以我们需要事先准备好delve工具\n\n## Delve安装\n\n## Delve的使用\n\n比如我们现在有一个很简单的程序，做一个和运算。\n\n代码结构是：\n\n```go\nAdd.go  : func Add(a int,b int) int\nmain.go : main()-> c := Add(10,20)\n```\n\n在Add文件里面有Add函数，mian里面进行调用，此时，使用\n\n```go\ngo build\n```\n\n```go\n./Add\n```\n\n可以直接运行该程序，当然我们的重点在于如何使用delve来调试该程序。\n\n具体步骤：\n\n1. 使用dlv debug 命令调试该程序\n2. 使用 [   b   ] 命令设置断点，阻塞调试运行\n3. 在终端使用相关的命令行查看运行时程序的状态\n\n如:\n\n进入dlv调试模式，并且使用该项目作为调试对象\n\n```bash\ndlv debug github.com/daniel/Add\n```\n\n**b**  是对main包下面的main方法设置断点，\t\t\t【  breakpoint  】\n\n```\nb main.main\n```\n\n在调试模式下执行此程序， **c**\t\t\t\t\t\t\t\t【  continue  】\n\n```\nc\n```\n\n```go\n\t1 package main\n\t2 import \"fmt\"\n\t3\n=>4 func main(){\n\t5 var a = 10\n\t6 var b = 20\n\t7 c:=Add(a,b)\n\t8 fmt.Println(\"c:\",c)\n\t9 }\n```\n\n就会在命令行出现如上的代码运行时况，**next**是执行下一步指令\n\n```\nnext\n```\n\n```go\n\t1 package main\n\t2 import \"fmt\"\n\t3\n  4 func main(){\n=>5 var a = 10\n\t6 var b = 20\n\t7 c:=Add(a,b)\n\t8 fmt.Println(\"c:\",c)\n\t9 }\n```\n\n再执行 **next**指令 ，我们可以通过**p a**查看运行时**a变量**的值  【 print 】\n\n```\np a\n```\n\n出现如下，显示a变量的值为 10\n\n```\n(div) p a\n10\n```\n\n同理，当我们运行到函数Add所在行的时候，我们可以通过   **s**  命令进入该函数，查看运行状态。 【  step   】\n\n```\ns\n```\n\n显示函数内部相关的调试步骤。\n\n**r** 命令是重新执行该程序 【 run 】\n\n```\nr\n```\n\n总结一下，dlv的常用命令：\n\n- b 设置断点\n- c 直接运行到断点处\n- s 单步执行，遇到函数进入内部\n- next 逐行执行 遇到函数直接运行到函数返回，就是不进入内部\n- r 是重新执行该程序\n\n到这，如果觉得dlv不过如此的话，那就大错特错了，dlv强大之处它可以跨机器调试对应的进程。\n\n### Dlv调试正在运行的程序\n\n首先，新建一个程序，因为需要用dlv工具attach到该程序的进程，所以这程序得是一个能够在后台长时间驻留的程序。如下:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\n\tfor {\n\t\tvar times int\n\n\t\tvar currentTime time.Time\n\n\t\ttime.Sleep(3 * time.Second)\n\n\t\ttimes++\n\t\tcurrentTime = time.Now()\n\n\t\tfmt.Printf(\"process had runed %d times,current time is : %v \\n\", times, currentTime)\n\n\t}\n\n}\n```\n\n该程序可以模拟我们线上运行的程序，它每隔3秒打印一次运行次数和时间。\n\n```\nprocess had runed 1 times,current time is : 2018-04-07\n```\n\n在linux机器上可以通过： \n\n```bash\nps aux|grep dlv_attach\n```\n\n查看当前程序dlv_attack的进程情况。找到程序的进程id\n\n使用：dlv attack 进程id  将dlv调试工具套接到当前运行的程序上\n\n```bash\ndlv attack process_id\n```\n\n此时运行的程序会进入调试模式，然后可以通过相关命令进行查看程序运行状态。\n\n### Dlv多线程调试模式\n\n在我们启动多个**goroutine来并发执行**的时候，我们可以通过dlv工具动态的去调试对应的**goroutine**\n\n如下，我使用最经典的 生产者-消费者模型来使用dlv的多线程调试。\n\n生产者：\n\n```go\nfunc Multi_Productor(ch chan<- int) {\n\n\tvar i int = 2\n\tfor {\n\t\ti++\n\t\tif IsPrime(i) {\n\t\t\tch <- i\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\n\t}\n}\n```\n\n生产者附属生产方法:  不断的判断传入的数值是不是素数\n\n```go\nfunc IsPrime(number int) bool {\n\n\tfor i := 2; i < number; i++ {\n\t\tif number%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n```\n\n#### 消费者\n\n```go\nfunc Multi_Receiver(ch <-chan int) {\n\tfor value := range ch {\n\t\tfmt.Printf(\"%d is prime \\n\", value)\n\t}\n\n}\n```\n\n#### 主main函数\n\n```go\nfunc main() {\n\tch := make(chan int, 1000)\n\n\tgo Multi_Productor(ch)\n\tgo Multi_Receiver(ch)\n\ttime.Sleep(time.Hour)\n\n}\n```\n\n在主函数中，启用两个**goroutine**去生产和消费对象。在我们启动了以后，我们照旧可以用dlv debug 调试，同时在dlv中使用:\n\n```bash\ngoroutines\n```\n\n可显示程序中运行的所有线程，当然在go里面都是轻量级的线程由go内核进行管理。\n\n![调试查看所有的goroutine](/png10.png)\n\n里面显示的很多的是go内核的goroutine，而跳入到某个特定的goroutine只需要使用 \n\n```\ngoroutine 19.   //跳入到19号生产者线程 进行调试\n```\n\n查看调用堆栈，    **bt**    指令，会显示当前的goroutine调用的所有堆栈。\n\n好啦，delve工具就分享到这啦，后面如果还有新的会更新在这。","source":"_posts/Delve调试工具.md","raw":"---\ntitle: Delve调试工具\ndate: 2020-01-20 10:58:52\ntags: [Go,服务端开发]\ncategories: Go栈\n---\n\n![](/start.jpg)\n\n# Delve调试工具\n\n​    为什么会选择delve呢，很多时候我们会把调试日志和运行时日志用自己能够处理的方式存储起来，比如说直接在开发阶段用log工具，在先上阶段使用日志库文件存储程序运行时的异常信息和不确定性的运行结果，或者是用kafka工具来接受导出管理日志。但是这一些都算是事后的事儿了，我们通过他们进行日志相关的查阅，像侦探一样一条一条的去发现线索。这个在一些特定情况下，比如无法重现，必须追踪调用栈，知道每个变量的运行时的值等一些列问题时，log工具显得有点手短了，而这一些delve工具可以很好的帮我们解决。\n\nDlv，也称为Delve，是Go语言的源码调试工具。由derekparker开发，开源在Github。在Mac上配置Go语言开发环境的时候，经常碰到的问题就是Dlv调用总是不成功，无法启动应用，无法调试等等。大部分的问题都与Mac的安全机制有关。Mac上使用codesign对应用进行签名，没有签名的程序会受到一些限制，例如无法作为调试程序。\n\nDelve是一个第三方的工具，所以我们需要事先准备好delve工具\n\n## Delve安装\n\n## Delve的使用\n\n比如我们现在有一个很简单的程序，做一个和运算。\n\n代码结构是：\n\n```go\nAdd.go  : func Add(a int,b int) int\nmain.go : main()-> c := Add(10,20)\n```\n\n在Add文件里面有Add函数，mian里面进行调用，此时，使用\n\n```go\ngo build\n```\n\n```go\n./Add\n```\n\n可以直接运行该程序，当然我们的重点在于如何使用delve来调试该程序。\n\n具体步骤：\n\n1. 使用dlv debug 命令调试该程序\n2. 使用 [   b   ] 命令设置断点，阻塞调试运行\n3. 在终端使用相关的命令行查看运行时程序的状态\n\n如:\n\n进入dlv调试模式，并且使用该项目作为调试对象\n\n```bash\ndlv debug github.com/daniel/Add\n```\n\n**b**  是对main包下面的main方法设置断点，\t\t\t【  breakpoint  】\n\n```\nb main.main\n```\n\n在调试模式下执行此程序， **c**\t\t\t\t\t\t\t\t【  continue  】\n\n```\nc\n```\n\n```go\n\t1 package main\n\t2 import \"fmt\"\n\t3\n=>4 func main(){\n\t5 var a = 10\n\t6 var b = 20\n\t7 c:=Add(a,b)\n\t8 fmt.Println(\"c:\",c)\n\t9 }\n```\n\n就会在命令行出现如上的代码运行时况，**next**是执行下一步指令\n\n```\nnext\n```\n\n```go\n\t1 package main\n\t2 import \"fmt\"\n\t3\n  4 func main(){\n=>5 var a = 10\n\t6 var b = 20\n\t7 c:=Add(a,b)\n\t8 fmt.Println(\"c:\",c)\n\t9 }\n```\n\n再执行 **next**指令 ，我们可以通过**p a**查看运行时**a变量**的值  【 print 】\n\n```\np a\n```\n\n出现如下，显示a变量的值为 10\n\n```\n(div) p a\n10\n```\n\n同理，当我们运行到函数Add所在行的时候，我们可以通过   **s**  命令进入该函数，查看运行状态。 【  step   】\n\n```\ns\n```\n\n显示函数内部相关的调试步骤。\n\n**r** 命令是重新执行该程序 【 run 】\n\n```\nr\n```\n\n总结一下，dlv的常用命令：\n\n- b 设置断点\n- c 直接运行到断点处\n- s 单步执行，遇到函数进入内部\n- next 逐行执行 遇到函数直接运行到函数返回，就是不进入内部\n- r 是重新执行该程序\n\n到这，如果觉得dlv不过如此的话，那就大错特错了，dlv强大之处它可以跨机器调试对应的进程。\n\n### Dlv调试正在运行的程序\n\n首先，新建一个程序，因为需要用dlv工具attach到该程序的进程，所以这程序得是一个能够在后台长时间驻留的程序。如下:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\n\tfor {\n\t\tvar times int\n\n\t\tvar currentTime time.Time\n\n\t\ttime.Sleep(3 * time.Second)\n\n\t\ttimes++\n\t\tcurrentTime = time.Now()\n\n\t\tfmt.Printf(\"process had runed %d times,current time is : %v \\n\", times, currentTime)\n\n\t}\n\n}\n```\n\n该程序可以模拟我们线上运行的程序，它每隔3秒打印一次运行次数和时间。\n\n```\nprocess had runed 1 times,current time is : 2018-04-07\n```\n\n在linux机器上可以通过： \n\n```bash\nps aux|grep dlv_attach\n```\n\n查看当前程序dlv_attack的进程情况。找到程序的进程id\n\n使用：dlv attack 进程id  将dlv调试工具套接到当前运行的程序上\n\n```bash\ndlv attack process_id\n```\n\n此时运行的程序会进入调试模式，然后可以通过相关命令进行查看程序运行状态。\n\n### Dlv多线程调试模式\n\n在我们启动多个**goroutine来并发执行**的时候，我们可以通过dlv工具动态的去调试对应的**goroutine**\n\n如下，我使用最经典的 生产者-消费者模型来使用dlv的多线程调试。\n\n生产者：\n\n```go\nfunc Multi_Productor(ch chan<- int) {\n\n\tvar i int = 2\n\tfor {\n\t\ti++\n\t\tif IsPrime(i) {\n\t\t\tch <- i\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\n\t}\n}\n```\n\n生产者附属生产方法:  不断的判断传入的数值是不是素数\n\n```go\nfunc IsPrime(number int) bool {\n\n\tfor i := 2; i < number; i++ {\n\t\tif number%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n```\n\n#### 消费者\n\n```go\nfunc Multi_Receiver(ch <-chan int) {\n\tfor value := range ch {\n\t\tfmt.Printf(\"%d is prime \\n\", value)\n\t}\n\n}\n```\n\n#### 主main函数\n\n```go\nfunc main() {\n\tch := make(chan int, 1000)\n\n\tgo Multi_Productor(ch)\n\tgo Multi_Receiver(ch)\n\ttime.Sleep(time.Hour)\n\n}\n```\n\n在主函数中，启用两个**goroutine**去生产和消费对象。在我们启动了以后，我们照旧可以用dlv debug 调试，同时在dlv中使用:\n\n```bash\ngoroutines\n```\n\n可显示程序中运行的所有线程，当然在go里面都是轻量级的线程由go内核进行管理。\n\n![调试查看所有的goroutine](/png10.png)\n\n里面显示的很多的是go内核的goroutine，而跳入到某个特定的goroutine只需要使用 \n\n```\ngoroutine 19.   //跳入到19号生产者线程 进行调试\n```\n\n查看调用堆栈，    **bt**    指令，会显示当前的goroutine调用的所有堆栈。\n\n好啦，delve工具就分享到这啦，后面如果还有新的会更新在这。","slug":"Delve调试工具","published":1,"updated":"2020-02-08T03:20:41.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771ris0000zd5b7oe543tx","content":"<p><img src=\"/2020/01/20/delve-diao-shi-gong-ju/start.jpg\" alt></p>\n<h1 id=\"Delve调试工具\"><a href=\"#Delve调试工具\" class=\"headerlink\" title=\"Delve调试工具\"></a>Delve调试工具</h1><p>​    为什么会选择delve呢，很多时候我们会把调试日志和运行时日志用自己能够处理的方式存储起来，比如说直接在开发阶段用log工具，在先上阶段使用日志库文件存储程序运行时的异常信息和不确定性的运行结果，或者是用kafka工具来接受导出管理日志。但是这一些都算是事后的事儿了，我们通过他们进行日志相关的查阅，像侦探一样一条一条的去发现线索。这个在一些特定情况下，比如无法重现，必须追踪调用栈，知道每个变量的运行时的值等一些列问题时，log工具显得有点手短了，而这一些delve工具可以很好的帮我们解决。</p>\n<p>Dlv，也称为Delve，是Go语言的源码调试工具。由derekparker开发，开源在Github。在Mac上配置Go语言开发环境的时候，经常碰到的问题就是Dlv调用总是不成功，无法启动应用，无法调试等等。大部分的问题都与Mac的安全机制有关。Mac上使用codesign对应用进行签名，没有签名的程序会受到一些限制，例如无法作为调试程序。</p>\n<p>Delve是一个第三方的工具，所以我们需要事先准备好delve工具</p>\n<h2 id=\"Delve安装\"><a href=\"#Delve安装\" class=\"headerlink\" title=\"Delve安装\"></a>Delve安装</h2><h2 id=\"Delve的使用\"><a href=\"#Delve的使用\" class=\"headerlink\" title=\"Delve的使用\"></a>Delve的使用</h2><p>比如我们现在有一个很简单的程序，做一个和运算。</p>\n<p>代码结构是：</p>\n<pre class=\" language-go\"><code class=\"language-go\">Add<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span>  <span class=\"token punctuation\">:</span> <span class=\"token keyword\">func</span> <span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>a <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span>b <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span>\nmain<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span> c <span class=\"token operator\">:=</span> <span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span></code></pre>\n<p>在Add文件里面有Add函数，mian里面进行调用，此时，使用</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">go</span> build</code></pre>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>Add</code></pre>\n<p>可以直接运行该程序，当然我们的重点在于如何使用delve来调试该程序。</p>\n<p>具体步骤：</p>\n<ol>\n<li>使用dlv debug 命令调试该程序</li>\n<li>使用 [   b   ] 命令设置断点，阻塞调试运行</li>\n<li>在终端使用相关的命令行查看运行时程序的状态</li>\n</ol>\n<p>如:</p>\n<p>进入dlv调试模式，并且使用该项目作为调试对象</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">dlv debug github.com/daniel/Add</code></pre>\n<p><strong>b</strong>  是对main包下面的main方法设置断点，            【  breakpoint  】</p>\n<pre><code>b main.main</code></pre><p>在调试模式下执行此程序， <strong>c</strong>                                【  continue  】</p>\n<pre><code>c</code></pre><pre class=\" language-go\"><code class=\"language-go\">    <span class=\"token number\">1</span> <span class=\"token keyword\">package</span> main\n    <span class=\"token number\">2</span> <span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span>\n    <span class=\"token number\">3</span>\n<span class=\"token operator\">=</span><span class=\"token operator\">></span><span class=\"token number\">4</span> <span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token number\">5</span> <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n    <span class=\"token number\">6</span> <span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token number\">20</span>\n    <span class=\"token number\">7</span> c<span class=\"token operator\">:=</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n    <span class=\"token number\">8</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c:\"</span><span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">)</span>\n    <span class=\"token number\">9</span> <span class=\"token punctuation\">}</span></code></pre>\n<p>就会在命令行出现如上的代码运行时况，<strong>next</strong>是执行下一步指令</p>\n<pre><code>next</code></pre><pre class=\" language-go\"><code class=\"language-go\">    <span class=\"token number\">1</span> <span class=\"token keyword\">package</span> main\n    <span class=\"token number\">2</span> <span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span>\n    <span class=\"token number\">3</span>\n  <span class=\"token number\">4</span> <span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token operator\">=</span><span class=\"token operator\">></span><span class=\"token number\">5</span> <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n    <span class=\"token number\">6</span> <span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token number\">20</span>\n    <span class=\"token number\">7</span> c<span class=\"token operator\">:=</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n    <span class=\"token number\">8</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c:\"</span><span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">)</span>\n    <span class=\"token number\">9</span> <span class=\"token punctuation\">}</span></code></pre>\n<p>再执行 <strong>next</strong>指令 ，我们可以通过<strong>p a</strong>查看运行时<strong>a变量</strong>的值  【 print 】</p>\n<pre><code>p a</code></pre><p>出现如下，显示a变量的值为 10</p>\n<pre><code>(div) p a\n10</code></pre><p>同理，当我们运行到函数Add所在行的时候，我们可以通过   <strong>s</strong>  命令进入该函数，查看运行状态。 【  step   】</p>\n<pre><code>s</code></pre><p>显示函数内部相关的调试步骤。</p>\n<p><strong>r</strong> 命令是重新执行该程序 【 run 】</p>\n<pre><code>r</code></pre><p>总结一下，dlv的常用命令：</p>\n<ul>\n<li>b 设置断点</li>\n<li>c 直接运行到断点处</li>\n<li>s 单步执行，遇到函数进入内部</li>\n<li>next 逐行执行 遇到函数直接运行到函数返回，就是不进入内部</li>\n<li>r 是重新执行该程序</li>\n</ul>\n<p>到这，如果觉得dlv不过如此的话，那就大错特错了，dlv强大之处它可以跨机器调试对应的进程。</p>\n<h3 id=\"Dlv调试正在运行的程序\"><a href=\"#Dlv调试正在运行的程序\" class=\"headerlink\" title=\"Dlv调试正在运行的程序\"></a>Dlv调试正在运行的程序</h3><p>首先，新建一个程序，因为需要用dlv工具attach到该程序的进程，所以这程序得是一个能够在后台长时间驻留的程序。如下:</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"fmt\"</span>\n    <span class=\"token string\">\"time\"</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> times <span class=\"token builtin\">int</span>\n\n        <span class=\"token keyword\">var</span> currentTime time<span class=\"token punctuation\">.</span>Time\n\n        time<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span> <span class=\"token operator\">*</span> time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">)</span>\n\n        times<span class=\"token operator\">++</span>\n        currentTime <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span><span class=\"token function\">Now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"process had runed %d times,current time is : %v \\n\"</span><span class=\"token punctuation\">,</span> times<span class=\"token punctuation\">,</span> currentTime<span class=\"token punctuation\">)</span>\n\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<p>该程序可以模拟我们线上运行的程序，它每隔3秒打印一次运行次数和时间。</p>\n<pre><code>process had runed 1 times,current time is : 2018-04-07</code></pre><p>在linux机器上可以通过： </p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">ps</span> aux<span class=\"token operator\">|</span><span class=\"token function\">grep</span> dlv_attach</code></pre>\n<p>查看当前程序dlv_attack的进程情况。找到程序的进程id</p>\n<p>使用：dlv attack 进程id  将dlv调试工具套接到当前运行的程序上</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">dlv attack process_id</code></pre>\n<p>此时运行的程序会进入调试模式，然后可以通过相关命令进行查看程序运行状态。</p>\n<h3 id=\"Dlv多线程调试模式\"><a href=\"#Dlv多线程调试模式\" class=\"headerlink\" title=\"Dlv多线程调试模式\"></a>Dlv多线程调试模式</h3><p>在我们启动多个<strong>goroutine来并发执行</strong>的时候，我们可以通过dlv工具动态的去调试对应的<strong>goroutine</strong></p>\n<p>如下，我使用最经典的 生产者-消费者模型来使用dlv的多线程调试。</p>\n<p>生产者：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">Multi_Productor</span><span class=\"token punctuation\">(</span>ch <span class=\"token keyword\">chan</span><span class=\"token operator\">&lt;-</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">var</span> i <span class=\"token builtin\">int</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n        i<span class=\"token operator\">++</span>\n        <span class=\"token keyword\">if</span> <span class=\"token function\">IsPrime</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            ch <span class=\"token operator\">&lt;-</span> i\n            time<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>生产者附属生产方法:  不断的判断传入的数值是不是素数</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">IsPrime</span><span class=\"token punctuation\">(</span>number <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">bool</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> number<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> number<span class=\"token operator\">%</span>i <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h4><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">Multi_Receiver</span><span class=\"token punctuation\">(</span>ch <span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> value <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> ch <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d is prime \\n\"</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"主main函数\"><a href=\"#主main函数\" class=\"headerlink\" title=\"主main函数\"></a>主main函数</h4><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">go</span> <span class=\"token function\">Multi_Productor</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">go</span> <span class=\"token function\">Multi_Receiver</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span>\n    time<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>Hour<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<p>在主函数中，启用两个<strong>goroutine</strong>去生产和消费对象。在我们启动了以后，我们照旧可以用dlv debug 调试，同时在dlv中使用:</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">goroutines</code></pre>\n<p>可显示程序中运行的所有线程，当然在go里面都是轻量级的线程由go内核进行管理。</p>\n<p><img src=\"/2020/01/20/delve-diao-shi-gong-ju/png10.png\" alt=\"调试查看所有的goroutine\"></p>\n<p>里面显示的很多的是go内核的goroutine，而跳入到某个特定的goroutine只需要使用 </p>\n<pre><code>goroutine 19.   //跳入到19号生产者线程 进行调试</code></pre><p>查看调用堆栈，    <strong>bt</strong>    指令，会显示当前的goroutine调用的所有堆栈。</p>\n<p>好啦，delve工具就分享到这啦，后面如果还有新的会更新在这。</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<p><img src=\"/2020/01/20/delve-diao-shi-gong-ju/start.jpg\" alt></p>\n<h1 id=\"Delve调试工具\"><a href=\"#Delve调试工具\" class=\"headerlink\" title=\"Delve调试工具\"></a>Delve调试工具</h1><p>​    为什么会选择delve呢，很多时候我们会把调试日志和运行时日志用自己能够处理的方式存储起来，比如说直接在开发阶段用log工具，在先上阶段使用日志库文件存储程序运行时的异常信息和不确定性的运行结果，或者是用kafka工具来接受导出管理日志。但是这一些都算是事后的事儿了，我们通过他们进行日志相关的查阅，像侦探一样一条一条的去发现线索。这个在一些特定情况下，比如无法重现，必须追踪调用栈，知道每个变量的运行时的值等一些列问题时，log工具显得有点手短了，而这一些delve工具可以很好的帮我们解决。</p>\n<p>Dlv，也称为Delve，是Go语言的源码调试工具。由derekparker开发，开源在Github。在Mac上配置Go语言开发环境的时候，经常碰到的问题就是Dlv调用总是不成功，无法启动应用，无法调试等等。大部分的问题都与Mac的安全机制有关。Mac上使用codesign对应用进行签名，没有签名的程序会受到一些限制，例如无法作为调试程序。</p>\n<p>Delve是一个第三方的工具，所以我们需要事先准备好delve工具</p>\n<h2 id=\"Delve安装\"><a href=\"#Delve安装\" class=\"headerlink\" title=\"Delve安装\"></a>Delve安装</h2><h2 id=\"Delve的使用\"><a href=\"#Delve的使用\" class=\"headerlink\" title=\"Delve的使用\"></a>Delve的使用</h2><p>比如我们现在有一个很简单的程序，做一个和运算。</p>\n<p>代码结构是：</p>\n<pre><code class=\"go\">Add.go  : func Add(a int,b int) int\nmain.go : main()-&gt; c := Add(10,20)</code></pre>\n<p>在Add文件里面有Add函数，mian里面进行调用，此时，使用</p>\n<pre><code class=\"go\">go build</code></pre>\n<pre><code class=\"go\">./Add</code></pre>\n<p>可以直接运行该程序，当然我们的重点在于如何使用delve来调试该程序。</p>\n<p>具体步骤：</p>\n<ol>\n<li>使用dlv debug 命令调试该程序</li>\n<li>使用 [   b   ] 命令设置断点，阻塞调试运行</li>\n<li>在终端使用相关的命令行查看运行时程序的状态</li>\n</ol>\n<p>如:</p>\n<p>进入dlv调试模式，并且使用该项目作为调试对象</p>\n<pre><code class=\"bash\">dlv debug github.com/daniel/Add</code></pre>\n<p><strong>b</strong>  是对main包下面的main方法设置断点，            【  breakpoint  】</p>\n<pre><code>b main.main</code></pre><p>在调试模式下执行此程序， <strong>c</strong>                                【  continue  】</p>\n<pre><code>c</code></pre><pre><code class=\"go\">    1 package main\n    2 import &quot;fmt&quot;\n    3\n=&gt;4 func main(){\n    5 var a = 10\n    6 var b = 20\n    7 c:=Add(a,b)\n    8 fmt.Println(&quot;c:&quot;,c)\n    9 }</code></pre>\n<p>就会在命令行出现如上的代码运行时况，<strong>next</strong>是执行下一步指令</p>\n<pre><code>next</code></pre><pre><code class=\"go\">    1 package main\n    2 import &quot;fmt&quot;\n    3\n  4 func main(){\n=&gt;5 var a = 10\n    6 var b = 20\n    7 c:=Add(a,b)\n    8 fmt.Println(&quot;c:&quot;,c)\n    9 }</code></pre>\n<p>再执行 <strong>next</strong>指令 ，我们可以通过<strong>p a</strong>查看运行时<strong>a变量</strong>的值  【 print 】</p>\n<pre><code>p a</code></pre><p>出现如下，显示a变量的值为 10</p>\n<pre><code>(div) p a\n10</code></pre><p>同理，当我们运行到函数Add所在行的时候，我们可以通过   <strong>s</strong>  命令进入该函数，查看运行状态。 【  step   】</p>\n<pre><code>s</code></pre><p>显示函数内部相关的调试步骤。</p>\n<p><strong>r</strong> 命令是重新执行该程序 【 run 】</p>\n<pre><code>r</code></pre><p>总结一下，dlv的常用命令：</p>\n<ul>\n<li>b 设置断点</li>\n<li>c 直接运行到断点处</li>\n<li>s 单步执行，遇到函数进入内部</li>\n<li>next 逐行执行 遇到函数直接运行到函数返回，就是不进入内部</li>\n<li>r 是重新执行该程序</li>\n</ul>\n<p>到这，如果觉得dlv不过如此的话，那就大错特错了，dlv强大之处它可以跨机器调试对应的进程。</p>\n<h3 id=\"Dlv调试正在运行的程序\"><a href=\"#Dlv调试正在运行的程序\" class=\"headerlink\" title=\"Dlv调试正在运行的程序\"></a>Dlv调试正在运行的程序</h3><p>首先，新建一个程序，因为需要用dlv工具attach到该程序的进程，所以这程序得是一个能够在后台长时间驻留的程序。如下:</p>\n<pre><code class=\"go\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;time&quot;\n)\n\nfunc main() {\n\n    for {\n        var times int\n\n        var currentTime time.Time\n\n        time.Sleep(3 * time.Second)\n\n        times++\n        currentTime = time.Now()\n\n        fmt.Printf(&quot;process had runed %d times,current time is : %v \\n&quot;, times, currentTime)\n\n    }\n\n}</code></pre>\n<p>该程序可以模拟我们线上运行的程序，它每隔3秒打印一次运行次数和时间。</p>\n<pre><code>process had runed 1 times,current time is : 2018-04-07</code></pre><p>在linux机器上可以通过： </p>\n<pre><code class=\"bash\">ps aux|grep dlv_attach</code></pre>\n<p>查看当前程序dlv_attack的进程情况。找到程序的进程id</p>\n<p>使用：dlv attack 进程id  将dlv调试工具套接到当前运行的程序上</p>\n<pre><code class=\"bash\">dlv attack process_id</code></pre>\n<p>此时运行的程序会进入调试模式，然后可以通过相关命令进行查看程序运行状态。</p>\n<h3 id=\"Dlv多线程调试模式\"><a href=\"#Dlv多线程调试模式\" class=\"headerlink\" title=\"Dlv多线程调试模式\"></a>Dlv多线程调试模式</h3><p>在我们启动多个<strong>goroutine来并发执行</strong>的时候，我们可以通过dlv工具动态的去调试对应的<strong>goroutine</strong></p>\n<p>如下，我使用最经典的 生产者-消费者模型来使用dlv的多线程调试。</p>\n<p>生产者：</p>\n<pre><code class=\"go\">func Multi_Productor(ch chan&lt;- int) {\n\n    var i int = 2\n    for {\n        i++\n        if IsPrime(i) {\n            ch &lt;- i\n            time.Sleep(time.Second)\n        }\n\n    }\n}</code></pre>\n<p>生产者附属生产方法:  不断的判断传入的数值是不是素数</p>\n<pre><code class=\"go\">func IsPrime(number int) bool {\n\n    for i := 2; i &lt; number; i++ {\n        if number%i == 0 {\n            return false\n        }\n    }\n    return true\n}</code></pre>\n<h4 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h4><pre><code class=\"go\">func Multi_Receiver(ch &lt;-chan int) {\n    for value := range ch {\n        fmt.Printf(&quot;%d is prime \\n&quot;, value)\n    }\n\n}</code></pre>\n<h4 id=\"主main函数\"><a href=\"#主main函数\" class=\"headerlink\" title=\"主main函数\"></a>主main函数</h4><pre><code class=\"go\">func main() {\n    ch := make(chan int, 1000)\n\n    go Multi_Productor(ch)\n    go Multi_Receiver(ch)\n    time.Sleep(time.Hour)\n\n}</code></pre>\n<p>在主函数中，启用两个<strong>goroutine</strong>去生产和消费对象。在我们启动了以后，我们照旧可以用dlv debug 调试，同时在dlv中使用:</p>\n<pre><code class=\"bash\">goroutines</code></pre>\n<p>可显示程序中运行的所有线程，当然在go里面都是轻量级的线程由go内核进行管理。</p>\n<p><img src=\"/2020/01/20/delve-diao-shi-gong-ju/png10.png\" alt=\"调试查看所有的goroutine\"></p>\n<p>里面显示的很多的是go内核的goroutine，而跳入到某个特定的goroutine只需要使用 </p>\n<pre><code>goroutine 19.   //跳入到19号生产者线程 进行调试</code></pre><p>查看调用堆栈，    <strong>bt</strong>    指令，会显示当前的goroutine调用的所有堆栈。</p>\n<p>好啦，delve工具就分享到这啦，后面如果还有新的会更新在这。</p>\n"},{"title":"Go ProtoBuf 和其他传输数据协议","date":"2020-01-25T13:44:42.000Z","_content":"\n![](/start.png)\n\n## 常用的数据传输协议\n\n为什么要有数据传输协议呢，其实这个问题非常简单，像我们在做游戏开发的时候，比如游戏引擎层面的开发语言是用的Lua、C++或者C#等，但是往往在服务器上用的并不是对等的语言，可能会在小项目的时候用Java写服务器，随着规模的增大，我们可能会考虑升级到像C++或者Node等。这样者皆适用Socket在Tcp/Udp等协议的支持下，虽然说客户端和服务器连接不成问题，但是，客户端和服务器两种不同的语言的数据类型很不一样，直接用流式传输字节流已经显得力不从心了。\n\n假若我们采用一种统一的中间格式做数据中介，只是在传输钱序列化，在接受后反序列化成特定语言的类型就不会出现因为类型不匹配而出现的困扰了。\n\n### Json\n\n> JSON(JavaScript Object Notation,JavaScript对象表示法)是一种轻量级的、键值对的数据交换格式。结构由大括号’{}’，中括号’[]’，逗号’，’，冒号’;’，双引号’\"\"'组成，包含的数据类型有Object，Number,Boolean,String,Array, NULL等。\n\n![](/png4.png)\n\njson图示意：\n\n![](png1.png)\n\n\n\n#### json序列化\n\n> 将Go语言原数据转换成JSON格式字符串\n\n```go\n//传map,结构体,slice...,返回结果byte切片和error是否错误\nfunc Marshal(v interface{}) ([]byte, error)\n\n```\n\n#### 结构体转json\n\n```go\ntype Person struct{\n   Name string   //姓名\n   Age int       //年龄\n   Sex rune      //性别\n   Hobby []string  //爱好\n   Money float64   //钱\n}\n  \nperson:=Person{Name:\"张三\",Age:18,Sex:'男',Hobby:[]string{\"听音乐\",\"看书\",\"打篮球\"},Money:18.62}\nif bytes,err:=json.Marshal(person);err!=nil{\n  fmt.Println(\"编码错误\",err)\n}else{\n//{\"Name\":\"张三\",\"Age\":18,\"Sex\":30007,\"Hobby\":[\"听音乐\",\"看书\",\"打篮球\"],\"Money\":18.62}\n  fmt.Println(\"编码成功:\",string(bytes))\n}\n```\n\n#### Map转Json\n\n```go\n  p:=make([]map[string]interface{},0)\n  p1:=map[string]interface{}{\"name\":\"张三\",\"age\":18,\"sex\":'男',\"hobby\":[]string{\"听音乐\",\"看书\",\"打篮球\"},\"money\":18.62}\n  p2:=map[string]interface{}{\"name\":\"李四\",\"age\":19,\"sex\":'女',\"hobby\":[]string{\"听音乐\",\"看电影\",\"打足球\"},\"money\":1.62}\n  p=append(p,p1,p2)\n\n  if bytes,err:=json.Marshal(p);err!=nil{\n    fmt.Println(\"编码错误\",err)\n  }else{\n    fmt.Println(string(bytes))\n  }\n```\n\n### Json反序列化\n\n> 将JSON格式字符串转换成Go语言原数据\n\n```go\n//传入JSON字符串的byte字节和Go接收数据的类型指针，返回err错误，是否返回成功\nfunc Unmarshal(data []byte, v interface{}) error\n\n```\n\n#### Json转map\n\n```go\nstr:=`{\"Name\":\"张三\",\"Age\":18,\"Sex\":30007,\"Hobby\":[\"听音乐\",\"看书\",\"打篮球\"],\"Money\":18.62}`\n\np:=make(map[string]interface{}, 0)\nif err:=json.Unmarshal([]byte(str),&p);err!=nil{\n  fmt.Println(\"解码失败\",err)\n}else{\n  fmt.Println(\"解析成功\",p)\n}\n```\n\n#### Json转结构体\n\n```go\nstr:=`{\"Name\":\"张三\",\"Age\":18,\"Sex\":30007,\"Hobby\":[\"听音乐\",\"看书\",\"打篮球\"],\"Money\":18.62}`\nvar p Person\n\nif err:=json.Unmarshal([]byte(str),&p);err!=nil{\n  fmt.Println(\"解码失败\",err)\n}else{\n  fmt.Println(\"解析成功\",p)\n}\n```\n\n#### Json转切片\n\n```go\nstr:=`[{\"Hobby\":[\"听音乐\",\"看书\",\"打篮球\"]}]`\np:=make([]map[string]interface{}, 0)\n\nif err:=json.Unmarshal([]byte(str),&p);err!=nil{\n  fmt.Println(\"解码失败\",err)\n}else{\n  fmt.Println(\"解析成功\",p)\n}\n```\n\nJson的使用非常简便，使用的也是文本协议，人类直接可以读懂修改的文本段。\n\n### XML\n\nxml主要用于配置文件的编写，由于xml是第一代文本协议，解决了一些跨语言的难题，但是由于xml占用的空间比较大，资源利用率很低，所以只用在配置文件这种文件树相对简单，文件类型单一的使用上。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<persons>\n    <person name=\"polaris\" age=\"28\">\n        <career>无业游民</career>\n        <interests>\n            <interest>做游戏</interest>\n            <interest>打篮球</interest>\n        </interests>\n    </person>\n    <person name=\"studygolang\" age=\"27\">\n        <career>工程师</career>\n        <interests>\n            <interest>编程</interest>\n            <interest>下棋</interest>\n        </interests>\n    </person>\n</persons>\n```\n\n如上的xml文件如何解析呢？\n\n首先对应的结构体定义如下：\n\n```go\ntype Result struct {\n    XMLName xml.Name `xml:\"persons\"`//标签上的标签名\n    Persons []Person `xml:\"person\"`\n}\ntype Person struct {\n    Name string `xml:\"name,attr\"`//persion标签属性名为name的属性值\n    Age int `xml:\"age,attr\"`\n    Career string `xml:\"career\"`//persion中标签名为career的值\n    Interests []string `xml:\"interests>interest\"`//标签interests下的interest数组\n    //不写>当子标签为一个的时候回把它当做对象解析\n}\n```\n\n#### XML字符串读取\n\n##### 方法一：转对象\n\n\n\n```xml\ninput := `<Person><FirstName>Xu</FirstName><LastName>Xinhua</LastName></Person>`\nerr := xml.Unmarshal([]byte(input), &v)//将文件转化成对象\n```\n\n##### 方法二：遍历\n\n\n\n```go\npackage main\n\nimport (\n    \"encoding/xml\"\n    \"strings\"\n    \"fmt\"\n)\n\nfunc main() {\n    var t xml.Token\n    var err error\n\n    input := `<Person><FirstName>Xu</FirstName><LastName>Xinhua</LastName></Person>`\n    inputReader := strings.NewReader(input)\n\n    // 从文件读取，如可以如下：\n    // content, err := ioutil.ReadFile(\"studygolang.xml\")\n    // decoder := xml.NewDecoder(bytes.NewBuffer(content))\n\n    decoder := xml.NewDecoder(inputReader)\n    for t, err = decoder.Token(); err == nil; t, err = decoder.Token() {\n        switch token := t.(type) {\n        // 处理元素开始（标签）\n        case xml.StartElement:\n            name := token.Name.Local\n            fmt.Printf(\"Token name: %s\\n\", name)\n            for _, attr := range token.Attr {\n                attrName := attr.Name.Local\n                attrValue := attr.Value\n                fmt.Printf(\"An attribute is: %s %s\\n\", attrName, attrValue)\n            }\n        // 处理元素结束（标签）\n        case xml.EndElement:\n            fmt.Printf(\"Token of '%s' end\\n\", token.Name.Local)\n        // 处理字符数据（这里就是元素的文本）\n        case xml.CharData:\n            content := string([]byte(token))\n            fmt.Printf(\"This is the content: %v\\n\", content)\n        default:\n            // ...\n        }\n    }\n}\n```\n\n#### XML文件读取\n\n\n\n```go\n//从文件读取，如可以如下：\ncontent, err := ioutil.ReadFile(\"studygolang.xml\")\ndecoder := xml.NewDecoder(bytes.NewBuffer(content))\nxml.Unmarshal(content, &result)//将文件转化成对象\n```\n\n### 生成xml\n\n\n\n#### 对象转换为xml\n\n\n\n```go\npackage main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n    // \"os\"\n)\n\ntype Servers struct {\n    XMLName xml.Name `xml:\"servers\"`\n    Version string   `xml:\"version,attr\"`\n    Svs     []server `xml:\"server\"`\n}\n\ntype server struct {\n    ServerName string `xml:\"serverName\"`\n    ServerIP   string `xml:\"serverIP\"`\n}\n\nfunc main() {\n    v := &Servers{Version: \"1\"}\n    v.Svs = append(v.Svs, server{\"Shanghai_VPN\", \"127.0.0.1\"})\n    v.Svs = append(v.Svs, server{\"Beijing_VPN\", \"127.0.0.2\"})\n    output, err := xml.MarshalIndent(v, \"  \", \"    \")\n    if err != nil {\n        fmt.Printf(\"error: %v\\n\", err)\n    }\n    // os.Stdout.Write([]byte(xml.Header))\n\n    // os.Stdout.Write(output)\n    //将字节流转换成string输出\n    fmt.Println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"+string(output))\n}\n```\n\n### map与XML相互转换（只能解决简单的的xml）\n\n\n\n```go\npackage main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n    \"io\"\n)\n\ntype Map map[string]string\n\ntype xmlMapEntry struct {\n    XMLName xml.Name\n    Value   string `xml:\",chardata\"`\n}\n\n// MarshalXML marshals the map to XML, with each key in the map being a\n// tag and it's corresponding value being it's contents.\nfunc (m Map) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n    if len(m) == 0 {\n        return nil\n    }\n\n    err := e.EncodeToken(start)\n    if err != nil {\n        return err\n    }\n\n    for k, v := range m {\n        e.Encode(xmlMapEntry{XMLName: xml.Name{Local: k}, Value: v})\n    }\n\n    return e.EncodeToken(start.End())\n}\n\n// UnmarshalXML unmarshals the XML into a map of string to strings,\n// creating a key in the map for each tag and setting it's value to the\n// tags contents.\n//\n// The fact this function is on the pointer of Map is important, so that\n// if m is nil it can be initialized, which is often the case if m is\n// nested in another xml structurel. This is also why the first thing done\n// on the first line is initialize it.\nfunc (m *Map) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {\n    *m = Map{}\n    for {\n        var e xmlMapEntry\n\n        err := d.Decode(&e)\n        if err == io.EOF {\n            break\n        } else if err != nil {\n            return err\n        }\n\n        (*m)[e.XMLName.Local] = e.Value\n    }\n    return nil\n}\n\nfunc main() {\n    // The Map\n    m := map[string]string{\n        \"key_1\": \"Value One\",\n        \"key_2\": \"Value Two\",\n    }\n    fmt.Println(m)\n\n    // Encode to XML\n    x, _ := xml.MarshalIndent(Map(m), \"\", \"  \")\n    fmt.Println(string(x))\n\n    // Decode back from XML\n    var rm map[string]string\n    xml.Unmarshal(x, (*Map)(&rm))\n    fmt.Println(rm)\n}\n```\n\n### msgpack\n\nmsgpack是针对json做的优化传输，相当于是一个二进制的json。上面两种Json和Xml格式，都是文本格式的数据，好处在于能够方便的阅读。但是问题在于占用空间比较大。所以又出现了MsgPack这种格式，它是在json基础上转换为二进制进行传输的。对应关系像下面这个图：\n\n![](/png2.png)\n\nMsgPack并没有官方的包，我们需要使用一个第三方的包，[项目地址](https://github.com/vmihailenco/msgpack )\n\n使用:以下代码进行拉取相关依赖包。\n\n```bash\ngo get -u github.com/vmihailenco/msgpack \n```\n\n实现比较简单，将 json.Marshal 和 json.Unmarshal 中的【 json】替换为【 maspack】即可。\n\n### Proto Buff\n\n![](/jpg3.jpg)\n\nprotobuf是Google公司开发出的一种数据格式。[官方文档地址](https://developers.google.cn/protocol-buffers/ )。\n\n简单讲它使用了**IDL语言**作为中间语言来串联不同的编程语言。不同的语言可以根据生成的IDL中间语言，生成自己的语言。\n\n这样做有什么好处？ 举个例子：当我们在协作开发的时候，A部门使用的是Go语言、B部分使用的是Java语言，C部门使用的是C#语言，当他们之间进行数据交换的时候，都要各自维护自己的结构体，才能进行数据的\n\n序列化和反序列化，**使用protobuf的好处就是只需要一个IDL描述**，然后生成不同的语言的结构，这样维护一份就可以了。\n\n同时 prototbuf的性能也很好，这也是它的一个优势。IDL语言使用的变长编码（根据整数的范围 0-255 那么这个数字就占用1个字节 ，如果使用定长编码的话 一个整数可能就是 4个字节）所以它的空间利用率是很好的。\n\n那开发流程是怎样的？\n\nA. IDL编写\n\nB. 生成只定语言的代码\n\nC. 序列化和反序列化\n\n \n\n如何在Go中应用prototbuf\n\nA.安装protoc编译器，解压后拷贝到GOPATH/bin目录下, [下载地址](https://github.com/google/protobuf/releases) 这个是一个可执行程序。\n\nB.安装生成Go语言的插件\n\n执行命令：\n\n```bash\ngo get -u github.com/golang/protobuf/protoc-gen-go\n```\n\n创建简单的proto文件:\n\n```protobuf\n//指定版本\n//注意proto3与proto2的写法有些不同\nsyntax = \"proto3\";\n\n//包名，通过protoc生成时go文件时\npackage school;\n\n//性别\n//枚举类型第一个字段必须为0\nenum Sex {\n    male = 0;\n    female = 1;\n    other =2;\n}\n\n//学生\nmessage Student {\n    Sex sex = 1;\n    string Name = 2;\n    int32 Age =3;\n}\n\n//班级\nmessage Class{\n    repeated Student Students =1;\n    string Name = 2; \n}\n```\n\n message 就可以理解成类， repeated可以理解成数组。\n\nD.利用之前下载好的protoc.exe 生成一个Go的代码。 第一个【.】代表当前输出的目录，后面*.proto则是 proto文件的路径\n\n```bash\nprotoc --go_out=.  *.proto\n```\n\nprotoc --go_out=.\\school\\ .\\school.proto\n\n执行之后会生成如下的文件，这个go文件就可以直接使用了。\n\n ![](/png5.png)\n\nE. 使用生成的Go文件\n\n①使用 proto.Marshal() 执行序列化\n\n```go\nfunc writeProto(filename string) (err error) {\n    //创建学生信息\n    var students []*school.Student\n    for i := 0; i < 30; i++ {\n\n        var sex = (school.Sex)(i % 3)\n        student := &school.Student{\n            Name: fmt.Sprintf(\"Student_%d\", i),\n            Age:  15,\n            Sex:  sex,\n        }\n\n        students = append(students, student)\n    }\n\n    //创建班级信息\n    var myClass school.Class\n    myClass.Name = \"我的班级\"\n    myClass.Students = students\n\n    data, err := proto.Marshal(&myClass)\n    if err != nil {\n        fmt.Printf(\"marshal proto buf failed, err:%v\\n\", err)\n        return\n    }\n\n    err = ioutil.WriteFile(filename, data, 0755)\n    if err != nil {\n        fmt.Printf(\"write file failed, err:%v\\n\", err)\n        return\n    }\n    return\n}\n```\n\n②使用proto.Unmarshal(data, &mySchool)执行反序列化\n\n```go\nfunc readProto(filename string) (err error) {\n    var mySchool school.Class\n    data, err := ioutil.ReadFile(filename)\n    if err != nil {\n        return\n    }\n    err = proto.Unmarshal(data, &mySchool)\n    if err != nil {\n        return\n    }\n\n    fmt.Printf(\"proto:%v\\n\", mySchool)\n    return\n}\n```\n\n如果在使用protobuf生成的Go文件，出现了如下的异常：\n\n**undefined: proto.ProtoPackageIsVersion3**\n\n这个时候可能是由于**上面两步下载的protoc可执行文件 和 protobuf 的版本不一致**导致的。\n\n1. 可以**清空**下gopath下的 github.com\\golang\\protobuf 然后重新下载，并在github.com\\golang\\protobuf\\protoc-gen-go 执行 **go install** 命令。\n\n2. 检查一下是不是使用了 **godep** 等包管理工具，里面引用的版本和protoc可执行文件不一致造成的","source":"_posts/Go-ProtoBuf-和其他传输数据协议.md","raw":"---\ntitle: Go ProtoBuf 和其他传输数据协议\ndate: 2020-01-25 21:44:42\ntags: [Go,网络协议]\ncategories: Go栈\n---\n\n![](/start.png)\n\n## 常用的数据传输协议\n\n为什么要有数据传输协议呢，其实这个问题非常简单，像我们在做游戏开发的时候，比如游戏引擎层面的开发语言是用的Lua、C++或者C#等，但是往往在服务器上用的并不是对等的语言，可能会在小项目的时候用Java写服务器，随着规模的增大，我们可能会考虑升级到像C++或者Node等。这样者皆适用Socket在Tcp/Udp等协议的支持下，虽然说客户端和服务器连接不成问题，但是，客户端和服务器两种不同的语言的数据类型很不一样，直接用流式传输字节流已经显得力不从心了。\n\n假若我们采用一种统一的中间格式做数据中介，只是在传输钱序列化，在接受后反序列化成特定语言的类型就不会出现因为类型不匹配而出现的困扰了。\n\n### Json\n\n> JSON(JavaScript Object Notation,JavaScript对象表示法)是一种轻量级的、键值对的数据交换格式。结构由大括号’{}’，中括号’[]’，逗号’，’，冒号’;’，双引号’\"\"'组成，包含的数据类型有Object，Number,Boolean,String,Array, NULL等。\n\n![](/png4.png)\n\njson图示意：\n\n![](png1.png)\n\n\n\n#### json序列化\n\n> 将Go语言原数据转换成JSON格式字符串\n\n```go\n//传map,结构体,slice...,返回结果byte切片和error是否错误\nfunc Marshal(v interface{}) ([]byte, error)\n\n```\n\n#### 结构体转json\n\n```go\ntype Person struct{\n   Name string   //姓名\n   Age int       //年龄\n   Sex rune      //性别\n   Hobby []string  //爱好\n   Money float64   //钱\n}\n  \nperson:=Person{Name:\"张三\",Age:18,Sex:'男',Hobby:[]string{\"听音乐\",\"看书\",\"打篮球\"},Money:18.62}\nif bytes,err:=json.Marshal(person);err!=nil{\n  fmt.Println(\"编码错误\",err)\n}else{\n//{\"Name\":\"张三\",\"Age\":18,\"Sex\":30007,\"Hobby\":[\"听音乐\",\"看书\",\"打篮球\"],\"Money\":18.62}\n  fmt.Println(\"编码成功:\",string(bytes))\n}\n```\n\n#### Map转Json\n\n```go\n  p:=make([]map[string]interface{},0)\n  p1:=map[string]interface{}{\"name\":\"张三\",\"age\":18,\"sex\":'男',\"hobby\":[]string{\"听音乐\",\"看书\",\"打篮球\"},\"money\":18.62}\n  p2:=map[string]interface{}{\"name\":\"李四\",\"age\":19,\"sex\":'女',\"hobby\":[]string{\"听音乐\",\"看电影\",\"打足球\"},\"money\":1.62}\n  p=append(p,p1,p2)\n\n  if bytes,err:=json.Marshal(p);err!=nil{\n    fmt.Println(\"编码错误\",err)\n  }else{\n    fmt.Println(string(bytes))\n  }\n```\n\n### Json反序列化\n\n> 将JSON格式字符串转换成Go语言原数据\n\n```go\n//传入JSON字符串的byte字节和Go接收数据的类型指针，返回err错误，是否返回成功\nfunc Unmarshal(data []byte, v interface{}) error\n\n```\n\n#### Json转map\n\n```go\nstr:=`{\"Name\":\"张三\",\"Age\":18,\"Sex\":30007,\"Hobby\":[\"听音乐\",\"看书\",\"打篮球\"],\"Money\":18.62}`\n\np:=make(map[string]interface{}, 0)\nif err:=json.Unmarshal([]byte(str),&p);err!=nil{\n  fmt.Println(\"解码失败\",err)\n}else{\n  fmt.Println(\"解析成功\",p)\n}\n```\n\n#### Json转结构体\n\n```go\nstr:=`{\"Name\":\"张三\",\"Age\":18,\"Sex\":30007,\"Hobby\":[\"听音乐\",\"看书\",\"打篮球\"],\"Money\":18.62}`\nvar p Person\n\nif err:=json.Unmarshal([]byte(str),&p);err!=nil{\n  fmt.Println(\"解码失败\",err)\n}else{\n  fmt.Println(\"解析成功\",p)\n}\n```\n\n#### Json转切片\n\n```go\nstr:=`[{\"Hobby\":[\"听音乐\",\"看书\",\"打篮球\"]}]`\np:=make([]map[string]interface{}, 0)\n\nif err:=json.Unmarshal([]byte(str),&p);err!=nil{\n  fmt.Println(\"解码失败\",err)\n}else{\n  fmt.Println(\"解析成功\",p)\n}\n```\n\nJson的使用非常简便，使用的也是文本协议，人类直接可以读懂修改的文本段。\n\n### XML\n\nxml主要用于配置文件的编写，由于xml是第一代文本协议，解决了一些跨语言的难题，但是由于xml占用的空间比较大，资源利用率很低，所以只用在配置文件这种文件树相对简单，文件类型单一的使用上。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<persons>\n    <person name=\"polaris\" age=\"28\">\n        <career>无业游民</career>\n        <interests>\n            <interest>做游戏</interest>\n            <interest>打篮球</interest>\n        </interests>\n    </person>\n    <person name=\"studygolang\" age=\"27\">\n        <career>工程师</career>\n        <interests>\n            <interest>编程</interest>\n            <interest>下棋</interest>\n        </interests>\n    </person>\n</persons>\n```\n\n如上的xml文件如何解析呢？\n\n首先对应的结构体定义如下：\n\n```go\ntype Result struct {\n    XMLName xml.Name `xml:\"persons\"`//标签上的标签名\n    Persons []Person `xml:\"person\"`\n}\ntype Person struct {\n    Name string `xml:\"name,attr\"`//persion标签属性名为name的属性值\n    Age int `xml:\"age,attr\"`\n    Career string `xml:\"career\"`//persion中标签名为career的值\n    Interests []string `xml:\"interests>interest\"`//标签interests下的interest数组\n    //不写>当子标签为一个的时候回把它当做对象解析\n}\n```\n\n#### XML字符串读取\n\n##### 方法一：转对象\n\n\n\n```xml\ninput := `<Person><FirstName>Xu</FirstName><LastName>Xinhua</LastName></Person>`\nerr := xml.Unmarshal([]byte(input), &v)//将文件转化成对象\n```\n\n##### 方法二：遍历\n\n\n\n```go\npackage main\n\nimport (\n    \"encoding/xml\"\n    \"strings\"\n    \"fmt\"\n)\n\nfunc main() {\n    var t xml.Token\n    var err error\n\n    input := `<Person><FirstName>Xu</FirstName><LastName>Xinhua</LastName></Person>`\n    inputReader := strings.NewReader(input)\n\n    // 从文件读取，如可以如下：\n    // content, err := ioutil.ReadFile(\"studygolang.xml\")\n    // decoder := xml.NewDecoder(bytes.NewBuffer(content))\n\n    decoder := xml.NewDecoder(inputReader)\n    for t, err = decoder.Token(); err == nil; t, err = decoder.Token() {\n        switch token := t.(type) {\n        // 处理元素开始（标签）\n        case xml.StartElement:\n            name := token.Name.Local\n            fmt.Printf(\"Token name: %s\\n\", name)\n            for _, attr := range token.Attr {\n                attrName := attr.Name.Local\n                attrValue := attr.Value\n                fmt.Printf(\"An attribute is: %s %s\\n\", attrName, attrValue)\n            }\n        // 处理元素结束（标签）\n        case xml.EndElement:\n            fmt.Printf(\"Token of '%s' end\\n\", token.Name.Local)\n        // 处理字符数据（这里就是元素的文本）\n        case xml.CharData:\n            content := string([]byte(token))\n            fmt.Printf(\"This is the content: %v\\n\", content)\n        default:\n            // ...\n        }\n    }\n}\n```\n\n#### XML文件读取\n\n\n\n```go\n//从文件读取，如可以如下：\ncontent, err := ioutil.ReadFile(\"studygolang.xml\")\ndecoder := xml.NewDecoder(bytes.NewBuffer(content))\nxml.Unmarshal(content, &result)//将文件转化成对象\n```\n\n### 生成xml\n\n\n\n#### 对象转换为xml\n\n\n\n```go\npackage main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n    // \"os\"\n)\n\ntype Servers struct {\n    XMLName xml.Name `xml:\"servers\"`\n    Version string   `xml:\"version,attr\"`\n    Svs     []server `xml:\"server\"`\n}\n\ntype server struct {\n    ServerName string `xml:\"serverName\"`\n    ServerIP   string `xml:\"serverIP\"`\n}\n\nfunc main() {\n    v := &Servers{Version: \"1\"}\n    v.Svs = append(v.Svs, server{\"Shanghai_VPN\", \"127.0.0.1\"})\n    v.Svs = append(v.Svs, server{\"Beijing_VPN\", \"127.0.0.2\"})\n    output, err := xml.MarshalIndent(v, \"  \", \"    \")\n    if err != nil {\n        fmt.Printf(\"error: %v\\n\", err)\n    }\n    // os.Stdout.Write([]byte(xml.Header))\n\n    // os.Stdout.Write(output)\n    //将字节流转换成string输出\n    fmt.Println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"+string(output))\n}\n```\n\n### map与XML相互转换（只能解决简单的的xml）\n\n\n\n```go\npackage main\n\nimport (\n    \"encoding/xml\"\n    \"fmt\"\n    \"io\"\n)\n\ntype Map map[string]string\n\ntype xmlMapEntry struct {\n    XMLName xml.Name\n    Value   string `xml:\",chardata\"`\n}\n\n// MarshalXML marshals the map to XML, with each key in the map being a\n// tag and it's corresponding value being it's contents.\nfunc (m Map) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n    if len(m) == 0 {\n        return nil\n    }\n\n    err := e.EncodeToken(start)\n    if err != nil {\n        return err\n    }\n\n    for k, v := range m {\n        e.Encode(xmlMapEntry{XMLName: xml.Name{Local: k}, Value: v})\n    }\n\n    return e.EncodeToken(start.End())\n}\n\n// UnmarshalXML unmarshals the XML into a map of string to strings,\n// creating a key in the map for each tag and setting it's value to the\n// tags contents.\n//\n// The fact this function is on the pointer of Map is important, so that\n// if m is nil it can be initialized, which is often the case if m is\n// nested in another xml structurel. This is also why the first thing done\n// on the first line is initialize it.\nfunc (m *Map) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {\n    *m = Map{}\n    for {\n        var e xmlMapEntry\n\n        err := d.Decode(&e)\n        if err == io.EOF {\n            break\n        } else if err != nil {\n            return err\n        }\n\n        (*m)[e.XMLName.Local] = e.Value\n    }\n    return nil\n}\n\nfunc main() {\n    // The Map\n    m := map[string]string{\n        \"key_1\": \"Value One\",\n        \"key_2\": \"Value Two\",\n    }\n    fmt.Println(m)\n\n    // Encode to XML\n    x, _ := xml.MarshalIndent(Map(m), \"\", \"  \")\n    fmt.Println(string(x))\n\n    // Decode back from XML\n    var rm map[string]string\n    xml.Unmarshal(x, (*Map)(&rm))\n    fmt.Println(rm)\n}\n```\n\n### msgpack\n\nmsgpack是针对json做的优化传输，相当于是一个二进制的json。上面两种Json和Xml格式，都是文本格式的数据，好处在于能够方便的阅读。但是问题在于占用空间比较大。所以又出现了MsgPack这种格式，它是在json基础上转换为二进制进行传输的。对应关系像下面这个图：\n\n![](/png2.png)\n\nMsgPack并没有官方的包，我们需要使用一个第三方的包，[项目地址](https://github.com/vmihailenco/msgpack )\n\n使用:以下代码进行拉取相关依赖包。\n\n```bash\ngo get -u github.com/vmihailenco/msgpack \n```\n\n实现比较简单，将 json.Marshal 和 json.Unmarshal 中的【 json】替换为【 maspack】即可。\n\n### Proto Buff\n\n![](/jpg3.jpg)\n\nprotobuf是Google公司开发出的一种数据格式。[官方文档地址](https://developers.google.cn/protocol-buffers/ )。\n\n简单讲它使用了**IDL语言**作为中间语言来串联不同的编程语言。不同的语言可以根据生成的IDL中间语言，生成自己的语言。\n\n这样做有什么好处？ 举个例子：当我们在协作开发的时候，A部门使用的是Go语言、B部分使用的是Java语言，C部门使用的是C#语言，当他们之间进行数据交换的时候，都要各自维护自己的结构体，才能进行数据的\n\n序列化和反序列化，**使用protobuf的好处就是只需要一个IDL描述**，然后生成不同的语言的结构，这样维护一份就可以了。\n\n同时 prototbuf的性能也很好，这也是它的一个优势。IDL语言使用的变长编码（根据整数的范围 0-255 那么这个数字就占用1个字节 ，如果使用定长编码的话 一个整数可能就是 4个字节）所以它的空间利用率是很好的。\n\n那开发流程是怎样的？\n\nA. IDL编写\n\nB. 生成只定语言的代码\n\nC. 序列化和反序列化\n\n \n\n如何在Go中应用prototbuf\n\nA.安装protoc编译器，解压后拷贝到GOPATH/bin目录下, [下载地址](https://github.com/google/protobuf/releases) 这个是一个可执行程序。\n\nB.安装生成Go语言的插件\n\n执行命令：\n\n```bash\ngo get -u github.com/golang/protobuf/protoc-gen-go\n```\n\n创建简单的proto文件:\n\n```protobuf\n//指定版本\n//注意proto3与proto2的写法有些不同\nsyntax = \"proto3\";\n\n//包名，通过protoc生成时go文件时\npackage school;\n\n//性别\n//枚举类型第一个字段必须为0\nenum Sex {\n    male = 0;\n    female = 1;\n    other =2;\n}\n\n//学生\nmessage Student {\n    Sex sex = 1;\n    string Name = 2;\n    int32 Age =3;\n}\n\n//班级\nmessage Class{\n    repeated Student Students =1;\n    string Name = 2; \n}\n```\n\n message 就可以理解成类， repeated可以理解成数组。\n\nD.利用之前下载好的protoc.exe 生成一个Go的代码。 第一个【.】代表当前输出的目录，后面*.proto则是 proto文件的路径\n\n```bash\nprotoc --go_out=.  *.proto\n```\n\nprotoc --go_out=.\\school\\ .\\school.proto\n\n执行之后会生成如下的文件，这个go文件就可以直接使用了。\n\n ![](/png5.png)\n\nE. 使用生成的Go文件\n\n①使用 proto.Marshal() 执行序列化\n\n```go\nfunc writeProto(filename string) (err error) {\n    //创建学生信息\n    var students []*school.Student\n    for i := 0; i < 30; i++ {\n\n        var sex = (school.Sex)(i % 3)\n        student := &school.Student{\n            Name: fmt.Sprintf(\"Student_%d\", i),\n            Age:  15,\n            Sex:  sex,\n        }\n\n        students = append(students, student)\n    }\n\n    //创建班级信息\n    var myClass school.Class\n    myClass.Name = \"我的班级\"\n    myClass.Students = students\n\n    data, err := proto.Marshal(&myClass)\n    if err != nil {\n        fmt.Printf(\"marshal proto buf failed, err:%v\\n\", err)\n        return\n    }\n\n    err = ioutil.WriteFile(filename, data, 0755)\n    if err != nil {\n        fmt.Printf(\"write file failed, err:%v\\n\", err)\n        return\n    }\n    return\n}\n```\n\n②使用proto.Unmarshal(data, &mySchool)执行反序列化\n\n```go\nfunc readProto(filename string) (err error) {\n    var mySchool school.Class\n    data, err := ioutil.ReadFile(filename)\n    if err != nil {\n        return\n    }\n    err = proto.Unmarshal(data, &mySchool)\n    if err != nil {\n        return\n    }\n\n    fmt.Printf(\"proto:%v\\n\", mySchool)\n    return\n}\n```\n\n如果在使用protobuf生成的Go文件，出现了如下的异常：\n\n**undefined: proto.ProtoPackageIsVersion3**\n\n这个时候可能是由于**上面两步下载的protoc可执行文件 和 protobuf 的版本不一致**导致的。\n\n1. 可以**清空**下gopath下的 github.com\\golang\\protobuf 然后重新下载，并在github.com\\golang\\protobuf\\protoc-gen-go 执行 **go install** 命令。\n\n2. 检查一下是不是使用了 **godep** 等包管理工具，里面引用的版本和protoc可执行文件不一致造成的","slug":"Go-ProtoBuf-和其他传输数据协议","published":1,"updated":"2020-02-07T06:25:40.494Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771riy0002zd5b95zkenpp","content":"<p><img src=\"/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/start.png\" alt></p>\n<h2 id=\"常用的数据传输协议\"><a href=\"#常用的数据传输协议\" class=\"headerlink\" title=\"常用的数据传输协议\"></a>常用的数据传输协议</h2><p>为什么要有数据传输协议呢，其实这个问题非常简单，像我们在做游戏开发的时候，比如游戏引擎层面的开发语言是用的Lua、C++或者C#等，但是往往在服务器上用的并不是对等的语言，可能会在小项目的时候用Java写服务器，随着规模的增大，我们可能会考虑升级到像C++或者Node等。这样者皆适用Socket在Tcp/Udp等协议的支持下，虽然说客户端和服务器连接不成问题，但是，客户端和服务器两种不同的语言的数据类型很不一样，直接用流式传输字节流已经显得力不从心了。</p>\n<p>假若我们采用一种统一的中间格式做数据中介，只是在传输钱序列化，在接受后反序列化成特定语言的类型就不会出现因为类型不匹配而出现的困扰了。</p>\n<h3 id=\"Json\"><a href=\"#Json\" class=\"headerlink\" title=\"Json\"></a>Json</h3><blockquote>\n<p>JSON(JavaScript Object Notation,JavaScript对象表示法)是一种轻量级的、键值对的数据交换格式。结构由大括号’{}’，中括号’[]’，逗号’，’，冒号’;’，双引号’””‘组成，包含的数据类型有Object，Number,Boolean,String,Array, NULL等。</p>\n</blockquote>\n<p><img src=\"/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/png4.png\" alt></p>\n<p>json图示意：</p>\n<p><img src=\"/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/png1.png\" alt></p>\n<h4 id=\"json序列化\"><a href=\"#json序列化\" class=\"headerlink\" title=\"json序列化\"></a>json序列化</h4><blockquote>\n<p>将Go语言原数据转换成JSON格式字符串</p>\n</blockquote>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">//传map,结构体,slice...,返回结果byte切片和error是否错误</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">Marshal</span><span class=\"token punctuation\">(</span>v <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">error</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<h4 id=\"结构体转json\"><a href=\"#结构体转json\" class=\"headerlink\" title=\"结构体转json\"></a>结构体转json</h4><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span><span class=\"token punctuation\">{</span>\n   Name <span class=\"token builtin\">string</span>   <span class=\"token comment\" spellcheck=\"true\">//姓名</span>\n   Age <span class=\"token builtin\">int</span>       <span class=\"token comment\" spellcheck=\"true\">//年龄</span>\n   Sex <span class=\"token builtin\">rune</span>      <span class=\"token comment\" spellcheck=\"true\">//性别</span>\n   Hobby <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span>  <span class=\"token comment\" spellcheck=\"true\">//爱好</span>\n   Money <span class=\"token builtin\">float64</span>   <span class=\"token comment\" spellcheck=\"true\">//钱</span>\n<span class=\"token punctuation\">}</span>\n\nperson<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span>Name<span class=\"token punctuation\">:</span><span class=\"token string\">\"张三\"</span><span class=\"token punctuation\">,</span>Age<span class=\"token punctuation\">:</span><span class=\"token number\">18</span><span class=\"token punctuation\">,</span>Sex<span class=\"token punctuation\">:</span><span class=\"token string\">'男'</span><span class=\"token punctuation\">,</span>Hobby<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"听音乐\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"看书\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"打篮球\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>Money<span class=\"token punctuation\">:</span><span class=\"token number\">18.62</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">if</span> bytes<span class=\"token punctuation\">,</span>err<span class=\"token operator\">:=</span>json<span class=\"token punctuation\">.</span><span class=\"token function\">Marshal</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>err<span class=\"token operator\">!=</span><span class=\"token boolean\">nil</span><span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"编码错误\"</span><span class=\"token punctuation\">,</span>err<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n<span class=\"token comment\" spellcheck=\"true\">//{\"Name\":\"张三\",\"Age\":18,\"Sex\":30007,\"Hobby\":[\"听音乐\",\"看书\",\"打篮球\"],\"Money\":18.62}</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"编码成功:\"</span><span class=\"token punctuation\">,</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"Map转Json\"><a href=\"#Map转Json\" class=\"headerlink\" title=\"Map转Json\"></a>Map转Json</h4><pre class=\" language-go\"><code class=\"language-go\">  p<span class=\"token operator\">:=</span><span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  p1<span class=\"token operator\">:=</span><span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"张三\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"age\"</span><span class=\"token punctuation\">:</span><span class=\"token number\">18</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"sex\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">'男'</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"hobby\"</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"听音乐\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"看书\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"打篮球\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"money\"</span><span class=\"token punctuation\">:</span><span class=\"token number\">18.62</span><span class=\"token punctuation\">}</span>\n  p2<span class=\"token operator\">:=</span><span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"李四\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"age\"</span><span class=\"token punctuation\">:</span><span class=\"token number\">19</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"sex\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">'女'</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"hobby\"</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"听音乐\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"看电影\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"打足球\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"money\"</span><span class=\"token punctuation\">:</span><span class=\"token number\">1.62</span><span class=\"token punctuation\">}</span>\n  p<span class=\"token operator\">=</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span>p1<span class=\"token punctuation\">,</span>p2<span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">if</span> bytes<span class=\"token punctuation\">,</span>err<span class=\"token operator\">:=</span>json<span class=\"token punctuation\">.</span><span class=\"token function\">Marshal</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>err<span class=\"token operator\">!=</span><span class=\"token boolean\">nil</span><span class=\"token punctuation\">{</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"编码错误\"</span><span class=\"token punctuation\">,</span>err<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"Json反序列化\"><a href=\"#Json反序列化\" class=\"headerlink\" title=\"Json反序列化\"></a>Json反序列化</h3><blockquote>\n<p>将JSON格式字符串转换成Go语言原数据</p>\n</blockquote>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">//传入JSON字符串的byte字节和Go接收数据的类型指针，返回err错误，是否返回成功</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">Unmarshal</span><span class=\"token punctuation\">(</span>data <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">,</span> v <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span>\n</code></pre>\n<h4 id=\"Json转map\"><a href=\"#Json转map\" class=\"headerlink\" title=\"Json转map\"></a>Json转map</h4><pre class=\" language-go\"><code class=\"language-go\">str<span class=\"token operator\">:=</span><span class=\"token string\">`{\"Name\":\"张三\",\"Age\":18,\"Sex\":30007,\"Hobby\":[\"听音乐\",\"看书\",\"打篮球\"],\"Money\":18.62}`</span>\n\np<span class=\"token operator\">:=</span><span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> err<span class=\"token operator\">:=</span>json<span class=\"token punctuation\">.</span><span class=\"token function\">Unmarshal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token function\">byte</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>err<span class=\"token operator\">!=</span><span class=\"token boolean\">nil</span><span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"解码失败\"</span><span class=\"token punctuation\">,</span>err<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"解析成功\"</span><span class=\"token punctuation\">,</span>p<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"Json转结构体\"><a href=\"#Json转结构体\" class=\"headerlink\" title=\"Json转结构体\"></a>Json转结构体</h4><pre class=\" language-go\"><code class=\"language-go\">str<span class=\"token operator\">:=</span><span class=\"token string\">`{\"Name\":\"张三\",\"Age\":18,\"Sex\":30007,\"Hobby\":[\"听音乐\",\"看书\",\"打篮球\"],\"Money\":18.62}`</span>\n<span class=\"token keyword\">var</span> p Person\n\n<span class=\"token keyword\">if</span> err<span class=\"token operator\">:=</span>json<span class=\"token punctuation\">.</span><span class=\"token function\">Unmarshal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token function\">byte</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>err<span class=\"token operator\">!=</span><span class=\"token boolean\">nil</span><span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"解码失败\"</span><span class=\"token punctuation\">,</span>err<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"解析成功\"</span><span class=\"token punctuation\">,</span>p<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"Json转切片\"><a href=\"#Json转切片\" class=\"headerlink\" title=\"Json转切片\"></a>Json转切片</h4><pre class=\" language-go\"><code class=\"language-go\">str<span class=\"token operator\">:=</span><span class=\"token string\">`[{\"Hobby\":[\"听音乐\",\"看书\",\"打篮球\"]}]`</span>\np<span class=\"token operator\">:=</span><span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">if</span> err<span class=\"token operator\">:=</span>json<span class=\"token punctuation\">.</span><span class=\"token function\">Unmarshal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token function\">byte</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>err<span class=\"token operator\">!=</span><span class=\"token boolean\">nil</span><span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"解码失败\"</span><span class=\"token punctuation\">,</span>err<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"解析成功\"</span><span class=\"token punctuation\">,</span>p<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Json的使用非常简便，使用的也是文本协议，人类直接可以读懂修改的文本段。</p>\n<h3 id=\"XML\"><a href=\"#XML\" class=\"headerlink\" title=\"XML\"></a>XML</h3><p>xml主要用于配置文件的编写，由于xml是第一代文本协议，解决了一些跨语言的难题，但是由于xml占用的空间比较大，资源利用率很低，所以只用在配置文件这种文件树相对简单，文件类型单一的使用上。</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>persons</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>person</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>polaris<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">age</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>28<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>career</span><span class=\"token punctuation\">></span></span>无业游民<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>career</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>interests</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>interest</span><span class=\"token punctuation\">></span></span>做游戏<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>interest</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>interest</span><span class=\"token punctuation\">></span></span>打篮球<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>interest</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>interests</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>person</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>person</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>studygolang<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">age</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>27<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>career</span><span class=\"token punctuation\">></span></span>工程师<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>career</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>interests</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>interest</span><span class=\"token punctuation\">></span></span>编程<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>interest</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>interest</span><span class=\"token punctuation\">></span></span>下棋<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>interest</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>interests</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>person</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>persons</span><span class=\"token punctuation\">></span></span></code></pre>\n<p>如上的xml文件如何解析呢？</p>\n<p>首先对应的结构体定义如下：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Result <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    XMLName xml<span class=\"token punctuation\">.</span>Name <span class=\"token string\">`xml:\"persons\"`</span><span class=\"token comment\" spellcheck=\"true\">//标签上的标签名</span>\n    Persons <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>Person <span class=\"token string\">`xml:\"person\"`</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    Name <span class=\"token builtin\">string</span> <span class=\"token string\">`xml:\"name,attr\"`</span><span class=\"token comment\" spellcheck=\"true\">//persion标签属性名为name的属性值</span>\n    Age <span class=\"token builtin\">int</span> <span class=\"token string\">`xml:\"age,attr\"`</span>\n    Career <span class=\"token builtin\">string</span> <span class=\"token string\">`xml:\"career\"`</span><span class=\"token comment\" spellcheck=\"true\">//persion中标签名为career的值</span>\n    Interests <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span> <span class=\"token string\">`xml:\"interests>interest\"`</span><span class=\"token comment\" spellcheck=\"true\">//标签interests下的interest数组</span>\n    <span class=\"token comment\" spellcheck=\"true\">//不写>当子标签为一个的时候回把它当做对象解析</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"XML字符串读取\"><a href=\"#XML字符串读取\" class=\"headerlink\" title=\"XML字符串读取\"></a>XML字符串读取</h4><h5 id=\"方法一：转对象\"><a href=\"#方法一：转对象\" class=\"headerlink\" title=\"方法一：转对象\"></a>方法一：转对象</h5><pre class=\" language-xml\"><code class=\"language-xml\">input := `<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Person</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>FirstName</span><span class=\"token punctuation\">></span></span>Xu<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>FirstName</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>LastName</span><span class=\"token punctuation\">></span></span>Xinhua<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>LastName</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Person</span><span class=\"token punctuation\">></span></span>`\nerr := xml.Unmarshal([]byte(input), &amp;v)//将文件转化成对象</code></pre>\n<h5 id=\"方法二：遍历\"><a href=\"#方法二：遍历\" class=\"headerlink\" title=\"方法二：遍历\"></a>方法二：遍历</h5><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"encoding/xml\"</span>\n    <span class=\"token string\">\"strings\"</span>\n    <span class=\"token string\">\"fmt\"</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> t xml<span class=\"token punctuation\">.</span>Token\n    <span class=\"token keyword\">var</span> err <span class=\"token builtin\">error</span>\n\n    input <span class=\"token operator\">:=</span> <span class=\"token string\">`&lt;Person>&lt;FirstName>Xu&lt;/FirstName>&lt;LastName>Xinhua&lt;/LastName>&lt;/Person>`</span>\n    inputReader <span class=\"token operator\">:=</span> strings<span class=\"token punctuation\">.</span><span class=\"token function\">NewReader</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 从文件读取，如可以如下：</span>\n    <span class=\"token comment\" spellcheck=\"true\">// content, err := ioutil.ReadFile(\"studygolang.xml\")</span>\n    <span class=\"token comment\" spellcheck=\"true\">// decoder := xml.NewDecoder(bytes.NewBuffer(content))</span>\n\n    decoder <span class=\"token operator\">:=</span> xml<span class=\"token punctuation\">.</span><span class=\"token function\">NewDecoder</span><span class=\"token punctuation\">(</span>inputReader<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> t<span class=\"token punctuation\">,</span> err <span class=\"token operator\">=</span> decoder<span class=\"token punctuation\">.</span><span class=\"token function\">Token</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> err <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">;</span> t<span class=\"token punctuation\">,</span> err <span class=\"token operator\">=</span> decoder<span class=\"token punctuation\">.</span><span class=\"token function\">Token</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">switch</span> token <span class=\"token operator\">:=</span> t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 处理元素开始（标签）</span>\n        <span class=\"token keyword\">case</span> xml<span class=\"token punctuation\">.</span>StartElement<span class=\"token punctuation\">:</span>\n            name <span class=\"token operator\">:=</span> token<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">.</span>Local\n            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Token name: %s\\n\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">for</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> attr <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> token<span class=\"token punctuation\">.</span>Attr <span class=\"token punctuation\">{</span>\n                attrName <span class=\"token operator\">:=</span> attr<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">.</span>Local\n                attrValue <span class=\"token operator\">:=</span> attr<span class=\"token punctuation\">.</span>Value\n                fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"An attribute is: %s %s\\n\"</span><span class=\"token punctuation\">,</span> attrName<span class=\"token punctuation\">,</span> attrValue<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 处理元素结束（标签）</span>\n        <span class=\"token keyword\">case</span> xml<span class=\"token punctuation\">.</span>EndElement<span class=\"token punctuation\">:</span>\n            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Token of '%s' end\\n\"</span><span class=\"token punctuation\">,</span> token<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">.</span>Local<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 处理字符数据（这里就是元素的文本）</span>\n        <span class=\"token keyword\">case</span> xml<span class=\"token punctuation\">.</span>CharData<span class=\"token punctuation\">:</span>\n            content <span class=\"token operator\">:=</span> <span class=\"token function\">string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token function\">byte</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This is the content: %v\\n\"</span><span class=\"token punctuation\">,</span> content<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"XML文件读取\"><a href=\"#XML文件读取\" class=\"headerlink\" title=\"XML文件读取\"></a>XML文件读取</h4><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">//从文件读取，如可以如下：</span>\ncontent<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> ioutil<span class=\"token punctuation\">.</span><span class=\"token function\">ReadFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"studygolang.xml\"</span><span class=\"token punctuation\">)</span>\ndecoder <span class=\"token operator\">:=</span> xml<span class=\"token punctuation\">.</span><span class=\"token function\">NewDecoder</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">.</span><span class=\"token function\">NewBuffer</span><span class=\"token punctuation\">(</span>content<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nxml<span class=\"token punctuation\">.</span><span class=\"token function\">Unmarshal</span><span class=\"token punctuation\">(</span>content<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>result<span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//将文件转化成对象</span></code></pre>\n<h3 id=\"生成xml\"><a href=\"#生成xml\" class=\"headerlink\" title=\"生成xml\"></a>生成xml</h3><h4 id=\"对象转换为xml\"><a href=\"#对象转换为xml\" class=\"headerlink\" title=\"对象转换为xml\"></a>对象转换为xml</h4><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"encoding/xml\"</span>\n    <span class=\"token string\">\"fmt\"</span>\n    <span class=\"token comment\" spellcheck=\"true\">// \"os\"</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">type</span> Servers <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    XMLName xml<span class=\"token punctuation\">.</span>Name <span class=\"token string\">`xml:\"servers\"`</span>\n    Version <span class=\"token builtin\">string</span>   <span class=\"token string\">`xml:\"version,attr\"`</span>\n    Svs     <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>server <span class=\"token string\">`xml:\"server\"`</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> server <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    ServerName <span class=\"token builtin\">string</span> <span class=\"token string\">`xml:\"serverName\"`</span>\n    ServerIP   <span class=\"token builtin\">string</span> <span class=\"token string\">`xml:\"serverIP\"`</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    v <span class=\"token operator\">:=</span> <span class=\"token operator\">&amp;</span>Servers<span class=\"token punctuation\">{</span>Version<span class=\"token punctuation\">:</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">}</span>\n    v<span class=\"token punctuation\">.</span>Svs <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>Svs<span class=\"token punctuation\">,</span> server<span class=\"token punctuation\">{</span><span class=\"token string\">\"Shanghai_VPN\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"127.0.0.1\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    v<span class=\"token punctuation\">.</span>Svs <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>Svs<span class=\"token punctuation\">,</span> server<span class=\"token punctuation\">{</span><span class=\"token string\">\"Beijing_VPN\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"127.0.0.2\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    output<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> xml<span class=\"token punctuation\">.</span><span class=\"token function\">MarshalIndent</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> <span class=\"token string\">\"  \"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"    \"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"error: %v\\n\"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// os.Stdout.Write([]byte(xml.Header))</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// os.Stdout.Write(output)</span>\n    <span class=\"token comment\" spellcheck=\"true\">//将字节流转换成string输出</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"</span><span class=\"token operator\">+</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span>output<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"map与XML相互转换（只能解决简单的的xml）\"><a href=\"#map与XML相互转换（只能解决简单的的xml）\" class=\"headerlink\" title=\"map与XML相互转换（只能解决简单的的xml）\"></a>map与XML相互转换（只能解决简单的的xml）</h3><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"encoding/xml\"</span>\n    <span class=\"token string\">\"fmt\"</span>\n    <span class=\"token string\">\"io\"</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">type</span> Map <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span>\n\n<span class=\"token keyword\">type</span> xmlMapEntry <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    XMLName xml<span class=\"token punctuation\">.</span>Name\n    Value   <span class=\"token builtin\">string</span> <span class=\"token string\">`xml:\",chardata\"`</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// MarshalXML marshals the map to XML, with each key in the map being a</span>\n<span class=\"token comment\" spellcheck=\"true\">// tag and it's corresponding value being it's contents.</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m Map<span class=\"token punctuation\">)</span> <span class=\"token function\">MarshalXML</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">*</span>xml<span class=\"token punctuation\">.</span>Encoder<span class=\"token punctuation\">,</span> start xml<span class=\"token punctuation\">.</span>StartElement<span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">nil</span>\n    <span class=\"token punctuation\">}</span>\n\n    err <span class=\"token operator\">:=</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">EncodeToken</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> err\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span> k<span class=\"token punctuation\">,</span> v <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> m <span class=\"token punctuation\">{</span>\n        e<span class=\"token punctuation\">.</span><span class=\"token function\">Encode</span><span class=\"token punctuation\">(</span>xmlMapEntry<span class=\"token punctuation\">{</span>XMLName<span class=\"token punctuation\">:</span> xml<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">{</span>Local<span class=\"token punctuation\">:</span> k<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> Value<span class=\"token punctuation\">:</span> v<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">EncodeToken</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">.</span><span class=\"token function\">End</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// UnmarshalXML unmarshals the XML into a map of string to strings,</span>\n<span class=\"token comment\" spellcheck=\"true\">// creating a key in the map for each tag and setting it's value to the</span>\n<span class=\"token comment\" spellcheck=\"true\">// tags contents.</span>\n<span class=\"token comment\" spellcheck=\"true\">//</span>\n<span class=\"token comment\" spellcheck=\"true\">// The fact this function is on the pointer of Map is important, so that</span>\n<span class=\"token comment\" spellcheck=\"true\">// if m is nil it can be initialized, which is often the case if m is</span>\n<span class=\"token comment\" spellcheck=\"true\">// nested in another xml structurel. This is also why the first thing done</span>\n<span class=\"token comment\" spellcheck=\"true\">// on the first line is initialize it.</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Map<span class=\"token punctuation\">)</span> <span class=\"token function\">UnmarshalXML</span><span class=\"token punctuation\">(</span>d <span class=\"token operator\">*</span>xml<span class=\"token punctuation\">.</span>Decoder<span class=\"token punctuation\">,</span> start xml<span class=\"token punctuation\">.</span>StartElement<span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">*</span>m <span class=\"token operator\">=</span> Map<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> e xmlMapEntry\n\n        err <span class=\"token operator\">:=</span> d<span class=\"token punctuation\">.</span><span class=\"token function\">Decode</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>e<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> err <span class=\"token operator\">==</span> io<span class=\"token punctuation\">.</span>EOF <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">break</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> err\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>e<span class=\"token punctuation\">.</span>XMLName<span class=\"token punctuation\">.</span>Local<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>Value\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">nil</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// The Map</span>\n    m <span class=\"token operator\">:=</span> <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">{</span>\n        <span class=\"token string\">\"key_1\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"Value One\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"key_2\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"Value Two\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Encode to XML</span>\n    x<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> xml<span class=\"token punctuation\">.</span><span class=\"token function\">MarshalIndent</span><span class=\"token punctuation\">(</span><span class=\"token function\">Map</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"  \"</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Decode back from XML</span>\n    <span class=\"token keyword\">var</span> rm <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span>\n    xml<span class=\"token punctuation\">.</span><span class=\"token function\">Unmarshal</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>Map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>rm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>rm<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"msgpack\"><a href=\"#msgpack\" class=\"headerlink\" title=\"msgpack\"></a>msgpack</h3><p>msgpack是针对json做的优化传输，相当于是一个二进制的json。上面两种Json和Xml格式，都是文本格式的数据，好处在于能够方便的阅读。但是问题在于占用空间比较大。所以又出现了MsgPack这种格式，它是在json基础上转换为二进制进行传输的。对应关系像下面这个图：</p>\n<p><img src=\"/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/png2.png\" alt></p>\n<p>MsgPack并没有官方的包，我们需要使用一个第三方的包，<a href=\"https://github.com/vmihailenco/msgpack\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n<p>使用:以下代码进行拉取相关依赖包。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">go get -u github.com/vmihailenco/msgpack </code></pre>\n<p>实现比较简单，将 json.Marshal 和 json.Unmarshal 中的【 json】替换为【 maspack】即可。</p>\n<h3 id=\"Proto-Buff\"><a href=\"#Proto-Buff\" class=\"headerlink\" title=\"Proto Buff\"></a>Proto Buff</h3><p><img src=\"/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/jpg3.jpg\" alt></p>\n<p>protobuf是Google公司开发出的一种数据格式。<a href=\"https://developers.google.cn/protocol-buffers/\" target=\"_blank\" rel=\"noopener\">官方文档地址</a>。</p>\n<p>简单讲它使用了<strong>IDL语言</strong>作为中间语言来串联不同的编程语言。不同的语言可以根据生成的IDL中间语言，生成自己的语言。</p>\n<p>这样做有什么好处？ 举个例子：当我们在协作开发的时候，A部门使用的是Go语言、B部分使用的是Java语言，C部门使用的是C#语言，当他们之间进行数据交换的时候，都要各自维护自己的结构体，才能进行数据的</p>\n<p>序列化和反序列化，<strong>使用protobuf的好处就是只需要一个IDL描述</strong>，然后生成不同的语言的结构，这样维护一份就可以了。</p>\n<p>同时 prototbuf的性能也很好，这也是它的一个优势。IDL语言使用的变长编码（根据整数的范围 0-255 那么这个数字就占用1个字节 ，如果使用定长编码的话 一个整数可能就是 4个字节）所以它的空间利用率是很好的。</p>\n<p>那开发流程是怎样的？</p>\n<p>A. IDL编写</p>\n<p>B. 生成只定语言的代码</p>\n<p>C. 序列化和反序列化</p>\n<p>如何在Go中应用prototbuf</p>\n<p>A.安装protoc编译器，解压后拷贝到GOPATH/bin目录下, <a href=\"https://github.com/google/protobuf/releases\" target=\"_blank\" rel=\"noopener\">下载地址</a> 这个是一个可执行程序。</p>\n<p>B.安装生成Go语言的插件</p>\n<p>执行命令：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">go get -u github.com/golang/protobuf/protoc-gen-go</code></pre>\n<p>创建简单的proto文件:</p>\n<pre class=\" language-protobuf\"><code class=\"language-protobuf\"><span class=\"token comment\" spellcheck=\"true\">//指定版本</span>\n<span class=\"token comment\" spellcheck=\"true\">//注意proto3与proto2的写法有些不同</span>\nsyntax <span class=\"token operator\">=</span> <span class=\"token string\">\"proto3\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//包名，通过protoc生成时go文件时</span>\n<span class=\"token keyword\">package</span> school<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//性别</span>\n<span class=\"token comment\" spellcheck=\"true\">//枚举类型第一个字段必须为0</span>\n<span class=\"token keyword\">enum</span> Sex <span class=\"token punctuation\">{</span>\n    male <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    female <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    other <span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//学生</span>\n<span class=\"token keyword\">message</span> Student <span class=\"token punctuation\">{</span>\n    Sex sex <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token primitive symbol\">string</span> Name <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token primitive symbol\">int32</span> Age <span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//班级</span>\n<span class=\"token keyword\">message</span> Class<span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">repeated</span> Student Students <span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token primitive symbol\">string</span> Name <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span></code></pre>\n<p> message 就可以理解成类， repeated可以理解成数组。</p>\n<p>D.利用之前下载好的protoc.exe 生成一个Go的代码。 第一个【.】代表当前输出的目录，后面*.proto则是 proto文件的路径</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">protoc --go_out<span class=\"token operator\">=</span>.  *.proto</code></pre>\n<p>protoc –go_out=.\\school\\ .\\school.proto</p>\n<p>执行之后会生成如下的文件，这个go文件就可以直接使用了。</p>\n<p> <img src=\"/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/png5.png\" alt></p>\n<p>E. 使用生成的Go文件</p>\n<p>①使用 proto.Marshal() 执行序列化</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">writeProto</span><span class=\"token punctuation\">(</span>filename <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>err <span class=\"token builtin\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//创建学生信息</span>\n    <span class=\"token keyword\">var</span> students <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>school<span class=\"token punctuation\">.</span>Student\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">var</span> sex <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>school<span class=\"token punctuation\">.</span>Sex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">%</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n        student <span class=\"token operator\">:=</span> <span class=\"token operator\">&amp;</span>school<span class=\"token punctuation\">.</span>Student<span class=\"token punctuation\">{</span>\n            Name<span class=\"token punctuation\">:</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Sprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Student_%d\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            Age<span class=\"token punctuation\">:</span>  <span class=\"token number\">15</span><span class=\"token punctuation\">,</span>\n            Sex<span class=\"token punctuation\">:</span>  sex<span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span>\n\n        students <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>students<span class=\"token punctuation\">,</span> student<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//创建班级信息</span>\n    <span class=\"token keyword\">var</span> myClass school<span class=\"token punctuation\">.</span>Class\n    myClass<span class=\"token punctuation\">.</span>Name <span class=\"token operator\">=</span> <span class=\"token string\">\"我的班级\"</span>\n    myClass<span class=\"token punctuation\">.</span>Students <span class=\"token operator\">=</span> students\n\n    data<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> proto<span class=\"token punctuation\">.</span><span class=\"token function\">Marshal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>myClass<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"marshal proto buf failed, err:%v\\n\"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n\n    err <span class=\"token operator\">=</span> ioutil<span class=\"token punctuation\">.</span><span class=\"token function\">WriteFile</span><span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> <span class=\"token number\">0755</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"write file failed, err:%v\\n\"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>②使用proto.Unmarshal(data, &amp;mySchool)执行反序列化</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">readProto</span><span class=\"token punctuation\">(</span>filename <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>err <span class=\"token builtin\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> mySchool school<span class=\"token punctuation\">.</span>Class\n    data<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> ioutil<span class=\"token punctuation\">.</span><span class=\"token function\">ReadFile</span><span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    err <span class=\"token operator\">=</span> proto<span class=\"token punctuation\">.</span><span class=\"token function\">Unmarshal</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>mySchool<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"proto:%v\\n\"</span><span class=\"token punctuation\">,</span> mySchool<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>如果在使用protobuf生成的Go文件，出现了如下的异常：</p>\n<p><strong>undefined: proto.ProtoPackageIsVersion3</strong></p>\n<p>这个时候可能是由于<strong>上面两步下载的protoc可执行文件 和 protobuf 的版本不一致</strong>导致的。</p>\n<ol>\n<li><p>可以<strong>清空</strong>下gopath下的 github.com\\golang\\protobuf 然后重新下载，并在github.com\\golang\\protobuf\\protoc-gen-go 执行 <strong>go install</strong> 命令。</p>\n</li>\n<li><p>检查一下是不是使用了 <strong>godep</strong> 等包管理工具，里面引用的版本和protoc可执行文件不一致造成的</p>\n</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<p><img src=\"/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/start.png\" alt></p>\n<h2 id=\"常用的数据传输协议\"><a href=\"#常用的数据传输协议\" class=\"headerlink\" title=\"常用的数据传输协议\"></a>常用的数据传输协议</h2><p>为什么要有数据传输协议呢，其实这个问题非常简单，像我们在做游戏开发的时候，比如游戏引擎层面的开发语言是用的Lua、C++或者C#等，但是往往在服务器上用的并不是对等的语言，可能会在小项目的时候用Java写服务器，随着规模的增大，我们可能会考虑升级到像C++或者Node等。这样者皆适用Socket在Tcp/Udp等协议的支持下，虽然说客户端和服务器连接不成问题，但是，客户端和服务器两种不同的语言的数据类型很不一样，直接用流式传输字节流已经显得力不从心了。</p>\n<p>假若我们采用一种统一的中间格式做数据中介，只是在传输钱序列化，在接受后反序列化成特定语言的类型就不会出现因为类型不匹配而出现的困扰了。</p>\n<h3 id=\"Json\"><a href=\"#Json\" class=\"headerlink\" title=\"Json\"></a>Json</h3><blockquote>\n<p>JSON(JavaScript Object Notation,JavaScript对象表示法)是一种轻量级的、键值对的数据交换格式。结构由大括号’{}’，中括号’[]’，逗号’，’，冒号’;’，双引号’””‘组成，包含的数据类型有Object，Number,Boolean,String,Array, NULL等。</p>\n</blockquote>\n<p><img src=\"/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/png4.png\" alt></p>\n<p>json图示意：</p>\n<p><img src=\"/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/png1.png\" alt></p>\n<h4 id=\"json序列化\"><a href=\"#json序列化\" class=\"headerlink\" title=\"json序列化\"></a>json序列化</h4><blockquote>\n<p>将Go语言原数据转换成JSON格式字符串</p>\n</blockquote>\n<pre><code class=\"go\">//传map,结构体,slice...,返回结果byte切片和error是否错误\nfunc Marshal(v interface{}) ([]byte, error)\n</code></pre>\n<h4 id=\"结构体转json\"><a href=\"#结构体转json\" class=\"headerlink\" title=\"结构体转json\"></a>结构体转json</h4><pre><code class=\"go\">type Person struct{\n   Name string   //姓名\n   Age int       //年龄\n   Sex rune      //性别\n   Hobby []string  //爱好\n   Money float64   //钱\n}\n\nperson:=Person{Name:&quot;张三&quot;,Age:18,Sex:&#39;男&#39;,Hobby:[]string{&quot;听音乐&quot;,&quot;看书&quot;,&quot;打篮球&quot;},Money:18.62}\nif bytes,err:=json.Marshal(person);err!=nil{\n  fmt.Println(&quot;编码错误&quot;,err)\n}else{\n//{&quot;Name&quot;:&quot;张三&quot;,&quot;Age&quot;:18,&quot;Sex&quot;:30007,&quot;Hobby&quot;:[&quot;听音乐&quot;,&quot;看书&quot;,&quot;打篮球&quot;],&quot;Money&quot;:18.62}\n  fmt.Println(&quot;编码成功:&quot;,string(bytes))\n}</code></pre>\n<h4 id=\"Map转Json\"><a href=\"#Map转Json\" class=\"headerlink\" title=\"Map转Json\"></a>Map转Json</h4><pre><code class=\"go\">  p:=make([]map[string]interface{},0)\n  p1:=map[string]interface{}{&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:18,&quot;sex&quot;:&#39;男&#39;,&quot;hobby&quot;:[]string{&quot;听音乐&quot;,&quot;看书&quot;,&quot;打篮球&quot;},&quot;money&quot;:18.62}\n  p2:=map[string]interface{}{&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:19,&quot;sex&quot;:&#39;女&#39;,&quot;hobby&quot;:[]string{&quot;听音乐&quot;,&quot;看电影&quot;,&quot;打足球&quot;},&quot;money&quot;:1.62}\n  p=append(p,p1,p2)\n\n  if bytes,err:=json.Marshal(p);err!=nil{\n    fmt.Println(&quot;编码错误&quot;,err)\n  }else{\n    fmt.Println(string(bytes))\n  }</code></pre>\n<h3 id=\"Json反序列化\"><a href=\"#Json反序列化\" class=\"headerlink\" title=\"Json反序列化\"></a>Json反序列化</h3><blockquote>\n<p>将JSON格式字符串转换成Go语言原数据</p>\n</blockquote>\n<pre><code class=\"go\">//传入JSON字符串的byte字节和Go接收数据的类型指针，返回err错误，是否返回成功\nfunc Unmarshal(data []byte, v interface{}) error\n</code></pre>\n<h4 id=\"Json转map\"><a href=\"#Json转map\" class=\"headerlink\" title=\"Json转map\"></a>Json转map</h4><pre><code class=\"go\">str:=`{&quot;Name&quot;:&quot;张三&quot;,&quot;Age&quot;:18,&quot;Sex&quot;:30007,&quot;Hobby&quot;:[&quot;听音乐&quot;,&quot;看书&quot;,&quot;打篮球&quot;],&quot;Money&quot;:18.62}`\n\np:=make(map[string]interface{}, 0)\nif err:=json.Unmarshal([]byte(str),&amp;p);err!=nil{\n  fmt.Println(&quot;解码失败&quot;,err)\n}else{\n  fmt.Println(&quot;解析成功&quot;,p)\n}</code></pre>\n<h4 id=\"Json转结构体\"><a href=\"#Json转结构体\" class=\"headerlink\" title=\"Json转结构体\"></a>Json转结构体</h4><pre><code class=\"go\">str:=`{&quot;Name&quot;:&quot;张三&quot;,&quot;Age&quot;:18,&quot;Sex&quot;:30007,&quot;Hobby&quot;:[&quot;听音乐&quot;,&quot;看书&quot;,&quot;打篮球&quot;],&quot;Money&quot;:18.62}`\nvar p Person\n\nif err:=json.Unmarshal([]byte(str),&amp;p);err!=nil{\n  fmt.Println(&quot;解码失败&quot;,err)\n}else{\n  fmt.Println(&quot;解析成功&quot;,p)\n}</code></pre>\n<h4 id=\"Json转切片\"><a href=\"#Json转切片\" class=\"headerlink\" title=\"Json转切片\"></a>Json转切片</h4><pre><code class=\"go\">str:=`[{&quot;Hobby&quot;:[&quot;听音乐&quot;,&quot;看书&quot;,&quot;打篮球&quot;]}]`\np:=make([]map[string]interface{}, 0)\n\nif err:=json.Unmarshal([]byte(str),&amp;p);err!=nil{\n  fmt.Println(&quot;解码失败&quot;,err)\n}else{\n  fmt.Println(&quot;解析成功&quot;,p)\n}</code></pre>\n<p>Json的使用非常简便，使用的也是文本协议，人类直接可以读懂修改的文本段。</p>\n<h3 id=\"XML\"><a href=\"#XML\" class=\"headerlink\" title=\"XML\"></a>XML</h3><p>xml主要用于配置文件的编写，由于xml是第一代文本协议，解决了一些跨语言的难题，但是由于xml占用的空间比较大，资源利用率很低，所以只用在配置文件这种文件树相对简单，文件类型单一的使用上。</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;persons&gt;\n    &lt;person name=&quot;polaris&quot; age=&quot;28&quot;&gt;\n        &lt;career&gt;无业游民&lt;/career&gt;\n        &lt;interests&gt;\n            &lt;interest&gt;做游戏&lt;/interest&gt;\n            &lt;interest&gt;打篮球&lt;/interest&gt;\n        &lt;/interests&gt;\n    &lt;/person&gt;\n    &lt;person name=&quot;studygolang&quot; age=&quot;27&quot;&gt;\n        &lt;career&gt;工程师&lt;/career&gt;\n        &lt;interests&gt;\n            &lt;interest&gt;编程&lt;/interest&gt;\n            &lt;interest&gt;下棋&lt;/interest&gt;\n        &lt;/interests&gt;\n    &lt;/person&gt;\n&lt;/persons&gt;</code></pre>\n<p>如上的xml文件如何解析呢？</p>\n<p>首先对应的结构体定义如下：</p>\n<pre><code class=\"go\">type Result struct {\n    XMLName xml.Name `xml:&quot;persons&quot;`//标签上的标签名\n    Persons []Person `xml:&quot;person&quot;`\n}\ntype Person struct {\n    Name string `xml:&quot;name,attr&quot;`//persion标签属性名为name的属性值\n    Age int `xml:&quot;age,attr&quot;`\n    Career string `xml:&quot;career&quot;`//persion中标签名为career的值\n    Interests []string `xml:&quot;interests&gt;interest&quot;`//标签interests下的interest数组\n    //不写&gt;当子标签为一个的时候回把它当做对象解析\n}</code></pre>\n<h4 id=\"XML字符串读取\"><a href=\"#XML字符串读取\" class=\"headerlink\" title=\"XML字符串读取\"></a>XML字符串读取</h4><h5 id=\"方法一：转对象\"><a href=\"#方法一：转对象\" class=\"headerlink\" title=\"方法一：转对象\"></a>方法一：转对象</h5><pre><code class=\"xml\">input := `&lt;Person&gt;&lt;FirstName&gt;Xu&lt;/FirstName&gt;&lt;LastName&gt;Xinhua&lt;/LastName&gt;&lt;/Person&gt;`\nerr := xml.Unmarshal([]byte(input), &amp;v)//将文件转化成对象</code></pre>\n<h5 id=\"方法二：遍历\"><a href=\"#方法二：遍历\" class=\"headerlink\" title=\"方法二：遍历\"></a>方法二：遍历</h5><pre><code class=\"go\">package main\n\nimport (\n    &quot;encoding/xml&quot;\n    &quot;strings&quot;\n    &quot;fmt&quot;\n)\n\nfunc main() {\n    var t xml.Token\n    var err error\n\n    input := `&lt;Person&gt;&lt;FirstName&gt;Xu&lt;/FirstName&gt;&lt;LastName&gt;Xinhua&lt;/LastName&gt;&lt;/Person&gt;`\n    inputReader := strings.NewReader(input)\n\n    // 从文件读取，如可以如下：\n    // content, err := ioutil.ReadFile(&quot;studygolang.xml&quot;)\n    // decoder := xml.NewDecoder(bytes.NewBuffer(content))\n\n    decoder := xml.NewDecoder(inputReader)\n    for t, err = decoder.Token(); err == nil; t, err = decoder.Token() {\n        switch token := t.(type) {\n        // 处理元素开始（标签）\n        case xml.StartElement:\n            name := token.Name.Local\n            fmt.Printf(&quot;Token name: %s\\n&quot;, name)\n            for _, attr := range token.Attr {\n                attrName := attr.Name.Local\n                attrValue := attr.Value\n                fmt.Printf(&quot;An attribute is: %s %s\\n&quot;, attrName, attrValue)\n            }\n        // 处理元素结束（标签）\n        case xml.EndElement:\n            fmt.Printf(&quot;Token of &#39;%s&#39; end\\n&quot;, token.Name.Local)\n        // 处理字符数据（这里就是元素的文本）\n        case xml.CharData:\n            content := string([]byte(token))\n            fmt.Printf(&quot;This is the content: %v\\n&quot;, content)\n        default:\n            // ...\n        }\n    }\n}</code></pre>\n<h4 id=\"XML文件读取\"><a href=\"#XML文件读取\" class=\"headerlink\" title=\"XML文件读取\"></a>XML文件读取</h4><pre><code class=\"go\">//从文件读取，如可以如下：\ncontent, err := ioutil.ReadFile(&quot;studygolang.xml&quot;)\ndecoder := xml.NewDecoder(bytes.NewBuffer(content))\nxml.Unmarshal(content, &amp;result)//将文件转化成对象</code></pre>\n<h3 id=\"生成xml\"><a href=\"#生成xml\" class=\"headerlink\" title=\"生成xml\"></a>生成xml</h3><h4 id=\"对象转换为xml\"><a href=\"#对象转换为xml\" class=\"headerlink\" title=\"对象转换为xml\"></a>对象转换为xml</h4><pre><code class=\"go\">package main\n\nimport (\n    &quot;encoding/xml&quot;\n    &quot;fmt&quot;\n    // &quot;os&quot;\n)\n\ntype Servers struct {\n    XMLName xml.Name `xml:&quot;servers&quot;`\n    Version string   `xml:&quot;version,attr&quot;`\n    Svs     []server `xml:&quot;server&quot;`\n}\n\ntype server struct {\n    ServerName string `xml:&quot;serverName&quot;`\n    ServerIP   string `xml:&quot;serverIP&quot;`\n}\n\nfunc main() {\n    v := &amp;Servers{Version: &quot;1&quot;}\n    v.Svs = append(v.Svs, server{&quot;Shanghai_VPN&quot;, &quot;127.0.0.1&quot;})\n    v.Svs = append(v.Svs, server{&quot;Beijing_VPN&quot;, &quot;127.0.0.2&quot;})\n    output, err := xml.MarshalIndent(v, &quot;  &quot;, &quot;    &quot;)\n    if err != nil {\n        fmt.Printf(&quot;error: %v\\n&quot;, err)\n    }\n    // os.Stdout.Write([]byte(xml.Header))\n\n    // os.Stdout.Write(output)\n    //将字节流转换成string输出\n    fmt.Println(&quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot;?&gt;\\n&quot;+string(output))\n}</code></pre>\n<h3 id=\"map与XML相互转换（只能解决简单的的xml）\"><a href=\"#map与XML相互转换（只能解决简单的的xml）\" class=\"headerlink\" title=\"map与XML相互转换（只能解决简单的的xml）\"></a>map与XML相互转换（只能解决简单的的xml）</h3><pre><code class=\"go\">package main\n\nimport (\n    &quot;encoding/xml&quot;\n    &quot;fmt&quot;\n    &quot;io&quot;\n)\n\ntype Map map[string]string\n\ntype xmlMapEntry struct {\n    XMLName xml.Name\n    Value   string `xml:&quot;,chardata&quot;`\n}\n\n// MarshalXML marshals the map to XML, with each key in the map being a\n// tag and it&#39;s corresponding value being it&#39;s contents.\nfunc (m Map) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n    if len(m) == 0 {\n        return nil\n    }\n\n    err := e.EncodeToken(start)\n    if err != nil {\n        return err\n    }\n\n    for k, v := range m {\n        e.Encode(xmlMapEntry{XMLName: xml.Name{Local: k}, Value: v})\n    }\n\n    return e.EncodeToken(start.End())\n}\n\n// UnmarshalXML unmarshals the XML into a map of string to strings,\n// creating a key in the map for each tag and setting it&#39;s value to the\n// tags contents.\n//\n// The fact this function is on the pointer of Map is important, so that\n// if m is nil it can be initialized, which is often the case if m is\n// nested in another xml structurel. This is also why the first thing done\n// on the first line is initialize it.\nfunc (m *Map) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {\n    *m = Map{}\n    for {\n        var e xmlMapEntry\n\n        err := d.Decode(&amp;e)\n        if err == io.EOF {\n            break\n        } else if err != nil {\n            return err\n        }\n\n        (*m)[e.XMLName.Local] = e.Value\n    }\n    return nil\n}\n\nfunc main() {\n    // The Map\n    m := map[string]string{\n        &quot;key_1&quot;: &quot;Value One&quot;,\n        &quot;key_2&quot;: &quot;Value Two&quot;,\n    }\n    fmt.Println(m)\n\n    // Encode to XML\n    x, _ := xml.MarshalIndent(Map(m), &quot;&quot;, &quot;  &quot;)\n    fmt.Println(string(x))\n\n    // Decode back from XML\n    var rm map[string]string\n    xml.Unmarshal(x, (*Map)(&amp;rm))\n    fmt.Println(rm)\n}</code></pre>\n<h3 id=\"msgpack\"><a href=\"#msgpack\" class=\"headerlink\" title=\"msgpack\"></a>msgpack</h3><p>msgpack是针对json做的优化传输，相当于是一个二进制的json。上面两种Json和Xml格式，都是文本格式的数据，好处在于能够方便的阅读。但是问题在于占用空间比较大。所以又出现了MsgPack这种格式，它是在json基础上转换为二进制进行传输的。对应关系像下面这个图：</p>\n<p><img src=\"/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/png2.png\" alt></p>\n<p>MsgPack并没有官方的包，我们需要使用一个第三方的包，<a href=\"https://github.com/vmihailenco/msgpack\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n<p>使用:以下代码进行拉取相关依赖包。</p>\n<pre><code class=\"bash\">go get -u github.com/vmihailenco/msgpack </code></pre>\n<p>实现比较简单，将 json.Marshal 和 json.Unmarshal 中的【 json】替换为【 maspack】即可。</p>\n<h3 id=\"Proto-Buff\"><a href=\"#Proto-Buff\" class=\"headerlink\" title=\"Proto Buff\"></a>Proto Buff</h3><p><img src=\"/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/jpg3.jpg\" alt></p>\n<p>protobuf是Google公司开发出的一种数据格式。<a href=\"https://developers.google.cn/protocol-buffers/\" target=\"_blank\" rel=\"noopener\">官方文档地址</a>。</p>\n<p>简单讲它使用了<strong>IDL语言</strong>作为中间语言来串联不同的编程语言。不同的语言可以根据生成的IDL中间语言，生成自己的语言。</p>\n<p>这样做有什么好处？ 举个例子：当我们在协作开发的时候，A部门使用的是Go语言、B部分使用的是Java语言，C部门使用的是C#语言，当他们之间进行数据交换的时候，都要各自维护自己的结构体，才能进行数据的</p>\n<p>序列化和反序列化，<strong>使用protobuf的好处就是只需要一个IDL描述</strong>，然后生成不同的语言的结构，这样维护一份就可以了。</p>\n<p>同时 prototbuf的性能也很好，这也是它的一个优势。IDL语言使用的变长编码（根据整数的范围 0-255 那么这个数字就占用1个字节 ，如果使用定长编码的话 一个整数可能就是 4个字节）所以它的空间利用率是很好的。</p>\n<p>那开发流程是怎样的？</p>\n<p>A. IDL编写</p>\n<p>B. 生成只定语言的代码</p>\n<p>C. 序列化和反序列化</p>\n<p>如何在Go中应用prototbuf</p>\n<p>A.安装protoc编译器，解压后拷贝到GOPATH/bin目录下, <a href=\"https://github.com/google/protobuf/releases\" target=\"_blank\" rel=\"noopener\">下载地址</a> 这个是一个可执行程序。</p>\n<p>B.安装生成Go语言的插件</p>\n<p>执行命令：</p>\n<pre><code class=\"bash\">go get -u github.com/golang/protobuf/protoc-gen-go</code></pre>\n<p>创建简单的proto文件:</p>\n<pre><code class=\"protobuf\">//指定版本\n//注意proto3与proto2的写法有些不同\nsyntax = &quot;proto3&quot;;\n\n//包名，通过protoc生成时go文件时\npackage school;\n\n//性别\n//枚举类型第一个字段必须为0\nenum Sex {\n    male = 0;\n    female = 1;\n    other =2;\n}\n\n//学生\nmessage Student {\n    Sex sex = 1;\n    string Name = 2;\n    int32 Age =3;\n}\n\n//班级\nmessage Class{\n    repeated Student Students =1;\n    string Name = 2; \n}</code></pre>\n<p> message 就可以理解成类， repeated可以理解成数组。</p>\n<p>D.利用之前下载好的protoc.exe 生成一个Go的代码。 第一个【.】代表当前输出的目录，后面*.proto则是 proto文件的路径</p>\n<pre><code class=\"bash\">protoc --go_out=.  *.proto</code></pre>\n<p>protoc –go_out=.\\school\\ .\\school.proto</p>\n<p>执行之后会生成如下的文件，这个go文件就可以直接使用了。</p>\n<p> <img src=\"/2020/01/25/go-protobuf-he-qi-ta-chuan-shu-shu-ju-xie-yi/png5.png\" alt></p>\n<p>E. 使用生成的Go文件</p>\n<p>①使用 proto.Marshal() 执行序列化</p>\n<pre><code class=\"go\">func writeProto(filename string) (err error) {\n    //创建学生信息\n    var students []*school.Student\n    for i := 0; i &lt; 30; i++ {\n\n        var sex = (school.Sex)(i % 3)\n        student := &amp;school.Student{\n            Name: fmt.Sprintf(&quot;Student_%d&quot;, i),\n            Age:  15,\n            Sex:  sex,\n        }\n\n        students = append(students, student)\n    }\n\n    //创建班级信息\n    var myClass school.Class\n    myClass.Name = &quot;我的班级&quot;\n    myClass.Students = students\n\n    data, err := proto.Marshal(&amp;myClass)\n    if err != nil {\n        fmt.Printf(&quot;marshal proto buf failed, err:%v\\n&quot;, err)\n        return\n    }\n\n    err = ioutil.WriteFile(filename, data, 0755)\n    if err != nil {\n        fmt.Printf(&quot;write file failed, err:%v\\n&quot;, err)\n        return\n    }\n    return\n}</code></pre>\n<p>②使用proto.Unmarshal(data, &amp;mySchool)执行反序列化</p>\n<pre><code class=\"go\">func readProto(filename string) (err error) {\n    var mySchool school.Class\n    data, err := ioutil.ReadFile(filename)\n    if err != nil {\n        return\n    }\n    err = proto.Unmarshal(data, &amp;mySchool)\n    if err != nil {\n        return\n    }\n\n    fmt.Printf(&quot;proto:%v\\n&quot;, mySchool)\n    return\n}</code></pre>\n<p>如果在使用protobuf生成的Go文件，出现了如下的异常：</p>\n<p><strong>undefined: proto.ProtoPackageIsVersion3</strong></p>\n<p>这个时候可能是由于<strong>上面两步下载的protoc可执行文件 和 protobuf 的版本不一致</strong>导致的。</p>\n<ol>\n<li><p>可以<strong>清空</strong>下gopath下的 github.com\\golang\\protobuf 然后重新下载，并在github.com\\golang\\protobuf\\protoc-gen-go 执行 <strong>go install</strong> 命令。</p>\n</li>\n<li><p>检查一下是不是使用了 <strong>godep</strong> 等包管理工具，里面引用的版本和protoc可执行文件不一致造成的</p>\n</li>\n</ol>\n"},{"title":"Go defer 详解","date":"2019-04-21T12:12:28.000Z","_content":"\n# Defer详解\n\n![](/defer.png)\n\ndefer语句是Go中一个非常有用的特性，可以将一个方法延迟到包裹该方法的方法返回时执行，在实际应用中，defer语句可以充当其他语言中try…catch…的角色，也可以用来处理关闭文件句柄等收尾操作。\n\nGo官方文档中对defer的执行时机做了阐述，分别是。\n\n- 包裹defer的函数返回时\n- 包裹defer的函数执行到末尾时\n- 所在的goroutine发生panic时\n\n如下，defer相当于一个临时的函数调用栈，在一个函数中，每次遇到的defer语句都会被放在一个临时的函数栈中，在函数返回之前进行调用，具体的调用时机是在**返回值真正返回之前**。\n\n为什么这么说呢，因为Go的函数返回值返回操作并不是原子性操作，它分为两步，如下的操作：\n\n```go\nreturn x\n```\n\n## 返回值原理:\n\n- 返回值=x\n- RET指令\n\n### defer操作\n\n1. 返回值 =x\n2. 检索defer函数栈，执行pop并执行\n3. RET指令\n\n\n\n接下来这个案例很能说明问题：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc Defer() int {\n\n\tnumber := 10\n\n\tdefer func() {\n\t\tnumber += 20\n\t}()\n\n\treturn number\n}\n\nfunc main() {\n\n\tn := Defer()\n\n\tfmt.Print(n)\n\n}\n```\n\n**输出的结果是： 10**\n\n这是因为在defer之前返回值已经设置好了，所以执行的defer并不修改返回值。\n\n\n\n再如：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc Defer() (x int) {\n\n\tdefer func() {\n\t\tx += 20\n\t}()\n\n\treturn 5\n}\n\nfunc main() {\n\n\tn := Defer()\n\n\tfmt.Print(n)\n\n}\n\n```\n\n**输出结果： 25**\n\n是不是有点出乎意料，这是因为在 Defer( ) 的定义里面 x作为返回值已经指定，所以其实底层执行的是：\n\n```go\n1. x = 5\n2. x+=20\n3. return x\n```\n\n\n\n而：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc Defer() (x int) {\n\n\ty:=10\n\tdefer func() {\n\t\ty += 20\n\t}()\n\n\treturn y\n}\n\nfunc main() {\n\n\tn := Defer()\n\n\tfmt.Print(n)\n\n}\n```\n\n**输出结果：10**\n\n是不是觉得更奇怪啦，出乎意料的结果是吧！ 当然这些都是一些障眼法啦，只要了解返回值和defer的操作一下切都会显得很自然了。\n\n```go\n1. x = y(10)\n2. defer()->不修改y，只修改副本\n3. 返回x(10)\n```\n\n最后：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc Defer() (x int) {\n\n\ty:=10\n\tdefer func(x int) {\n\t\tx+=1\n\t}(y)\n\n\treturn y\n}\n\nfunc main() {\n\n\tn := Defer()\n\n\tfmt.Print(n)\n\n}\n```\n\n**输出结果： 10**\n\n这个就比较简单，匿名函数传入的是值的副本，所以修改不到原值。\n\n\n\n好啦，defer到此结束～","source":"_posts/Go-defer-详解.md","raw":"---\ntitle: Go defer 详解\ndate: 2019-04-21 20:12:28\ntags: [Go,服务端开发]\ncategories: Go栈\n---\n\n# Defer详解\n\n![](/defer.png)\n\ndefer语句是Go中一个非常有用的特性，可以将一个方法延迟到包裹该方法的方法返回时执行，在实际应用中，defer语句可以充当其他语言中try…catch…的角色，也可以用来处理关闭文件句柄等收尾操作。\n\nGo官方文档中对defer的执行时机做了阐述，分别是。\n\n- 包裹defer的函数返回时\n- 包裹defer的函数执行到末尾时\n- 所在的goroutine发生panic时\n\n如下，defer相当于一个临时的函数调用栈，在一个函数中，每次遇到的defer语句都会被放在一个临时的函数栈中，在函数返回之前进行调用，具体的调用时机是在**返回值真正返回之前**。\n\n为什么这么说呢，因为Go的函数返回值返回操作并不是原子性操作，它分为两步，如下的操作：\n\n```go\nreturn x\n```\n\n## 返回值原理:\n\n- 返回值=x\n- RET指令\n\n### defer操作\n\n1. 返回值 =x\n2. 检索defer函数栈，执行pop并执行\n3. RET指令\n\n\n\n接下来这个案例很能说明问题：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc Defer() int {\n\n\tnumber := 10\n\n\tdefer func() {\n\t\tnumber += 20\n\t}()\n\n\treturn number\n}\n\nfunc main() {\n\n\tn := Defer()\n\n\tfmt.Print(n)\n\n}\n```\n\n**输出的结果是： 10**\n\n这是因为在defer之前返回值已经设置好了，所以执行的defer并不修改返回值。\n\n\n\n再如：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc Defer() (x int) {\n\n\tdefer func() {\n\t\tx += 20\n\t}()\n\n\treturn 5\n}\n\nfunc main() {\n\n\tn := Defer()\n\n\tfmt.Print(n)\n\n}\n\n```\n\n**输出结果： 25**\n\n是不是有点出乎意料，这是因为在 Defer( ) 的定义里面 x作为返回值已经指定，所以其实底层执行的是：\n\n```go\n1. x = 5\n2. x+=20\n3. return x\n```\n\n\n\n而：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc Defer() (x int) {\n\n\ty:=10\n\tdefer func() {\n\t\ty += 20\n\t}()\n\n\treturn y\n}\n\nfunc main() {\n\n\tn := Defer()\n\n\tfmt.Print(n)\n\n}\n```\n\n**输出结果：10**\n\n是不是觉得更奇怪啦，出乎意料的结果是吧！ 当然这些都是一些障眼法啦，只要了解返回值和defer的操作一下切都会显得很自然了。\n\n```go\n1. x = y(10)\n2. defer()->不修改y，只修改副本\n3. 返回x(10)\n```\n\n最后：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc Defer() (x int) {\n\n\ty:=10\n\tdefer func(x int) {\n\t\tx+=1\n\t}(y)\n\n\treturn y\n}\n\nfunc main() {\n\n\tn := Defer()\n\n\tfmt.Print(n)\n\n}\n```\n\n**输出结果： 10**\n\n这个就比较简单，匿名函数传入的是值的副本，所以修改不到原值。\n\n\n\n好啦，defer到此结束～","slug":"Go-defer-详解","published":1,"updated":"2020-02-08T03:21:23.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rj10006zd5bgibc7mc8","content":"<h1 id=\"Defer详解\"><a href=\"#Defer详解\" class=\"headerlink\" title=\"Defer详解\"></a>Defer详解</h1><p><img src=\"/2019/04/21/go-defer-xiang-jie/defer.png\" alt></p>\n<p>defer语句是Go中一个非常有用的特性，可以将一个方法延迟到包裹该方法的方法返回时执行，在实际应用中，defer语句可以充当其他语言中try…catch…的角色，也可以用来处理关闭文件句柄等收尾操作。</p>\n<p>Go官方文档中对defer的执行时机做了阐述，分别是。</p>\n<ul>\n<li>包裹defer的函数返回时</li>\n<li>包裹defer的函数执行到末尾时</li>\n<li>所在的goroutine发生panic时</li>\n</ul>\n<p>如下，defer相当于一个临时的函数调用栈，在一个函数中，每次遇到的defer语句都会被放在一个临时的函数栈中，在函数返回之前进行调用，具体的调用时机是在<strong>返回值真正返回之前</strong>。</p>\n<p>为什么这么说呢，因为Go的函数返回值返回操作并不是原子性操作，它分为两步，如下的操作：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">return</span> x</code></pre>\n<h2 id=\"返回值原理\"><a href=\"#返回值原理\" class=\"headerlink\" title=\"返回值原理:\"></a>返回值原理:</h2><ul>\n<li>返回值=x</li>\n<li>RET指令</li>\n</ul>\n<h3 id=\"defer操作\"><a href=\"#defer操作\" class=\"headerlink\" title=\"defer操作\"></a>defer操作</h3><ol>\n<li>返回值 =x</li>\n<li>检索defer函数栈，执行pop并执行</li>\n<li>RET指令</li>\n</ol>\n<p>接下来这个案例很能说明问题：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">Defer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n\n    number <span class=\"token operator\">:=</span> <span class=\"token number\">10</span>\n\n    <span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        number <span class=\"token operator\">+=</span> <span class=\"token number\">20</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> number\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    n <span class=\"token operator\">:=</span> <span class=\"token function\">Defer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Print</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>输出的结果是： 10</strong></p>\n<p>这是因为在defer之前返回值已经设置好了，所以执行的defer并不修改返回值。</p>\n<p>再如：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">Defer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>x <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        x <span class=\"token operator\">+=</span> <span class=\"token number\">20</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">5</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    n <span class=\"token operator\">:=</span> <span class=\"token function\">Defer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Print</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>输出结果： 25</strong></p>\n<p>是不是有点出乎意料，这是因为在 Defer( ) 的定义里面 x作为返回值已经指定，所以其实底层执行的是：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token number\">1</span><span class=\"token punctuation\">.</span> x <span class=\"token operator\">=</span> <span class=\"token number\">5</span>\n<span class=\"token number\">2</span><span class=\"token punctuation\">.</span> x<span class=\"token operator\">+=</span><span class=\"token number\">20</span>\n<span class=\"token number\">3</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">return</span> x</code></pre>\n<p>而：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">Defer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>x <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    y<span class=\"token operator\">:=</span><span class=\"token number\">10</span>\n    <span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        y <span class=\"token operator\">+=</span> <span class=\"token number\">20</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> y\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    n <span class=\"token operator\">:=</span> <span class=\"token function\">Defer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Print</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>输出结果：10</strong></p>\n<p>是不是觉得更奇怪啦，出乎意料的结果是吧！ 当然这些都是一些障眼法啦，只要了解返回值和defer的操作一下切都会显得很自然了。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token number\">1</span><span class=\"token punctuation\">.</span> x <span class=\"token operator\">=</span> <span class=\"token function\">y</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n<span class=\"token number\">2</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">defer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>不修改y，只修改副本\n<span class=\"token number\">3</span><span class=\"token punctuation\">.</span> 返回<span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span></code></pre>\n<p>最后：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">Defer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>x <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    y<span class=\"token operator\">:=</span><span class=\"token number\">10</span>\n    <span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>x <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        x<span class=\"token operator\">+=</span><span class=\"token number\">1</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> y\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    n <span class=\"token operator\">:=</span> <span class=\"token function\">Defer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Print</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>输出结果： 10</strong></p>\n<p>这个就比较简单，匿名函数传入的是值的副本，所以修改不到原值。</p>\n<p>好啦，defer到此结束～</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<h1 id=\"Defer详解\"><a href=\"#Defer详解\" class=\"headerlink\" title=\"Defer详解\"></a>Defer详解</h1><p><img src=\"/2019/04/21/go-defer-xiang-jie/defer.png\" alt></p>\n<p>defer语句是Go中一个非常有用的特性，可以将一个方法延迟到包裹该方法的方法返回时执行，在实际应用中，defer语句可以充当其他语言中try…catch…的角色，也可以用来处理关闭文件句柄等收尾操作。</p>\n<p>Go官方文档中对defer的执行时机做了阐述，分别是。</p>\n<ul>\n<li>包裹defer的函数返回时</li>\n<li>包裹defer的函数执行到末尾时</li>\n<li>所在的goroutine发生panic时</li>\n</ul>\n<p>如下，defer相当于一个临时的函数调用栈，在一个函数中，每次遇到的defer语句都会被放在一个临时的函数栈中，在函数返回之前进行调用，具体的调用时机是在<strong>返回值真正返回之前</strong>。</p>\n<p>为什么这么说呢，因为Go的函数返回值返回操作并不是原子性操作，它分为两步，如下的操作：</p>\n<pre><code class=\"go\">return x</code></pre>\n<h2 id=\"返回值原理\"><a href=\"#返回值原理\" class=\"headerlink\" title=\"返回值原理:\"></a>返回值原理:</h2><ul>\n<li>返回值=x</li>\n<li>RET指令</li>\n</ul>\n<h3 id=\"defer操作\"><a href=\"#defer操作\" class=\"headerlink\" title=\"defer操作\"></a>defer操作</h3><ol>\n<li>返回值 =x</li>\n<li>检索defer函数栈，执行pop并执行</li>\n<li>RET指令</li>\n</ol>\n<p>接下来这个案例很能说明问题：</p>\n<pre><code class=\"go\">package main\n\nimport &quot;fmt&quot;\n\nfunc Defer() int {\n\n    number := 10\n\n    defer func() {\n        number += 20\n    }()\n\n    return number\n}\n\nfunc main() {\n\n    n := Defer()\n\n    fmt.Print(n)\n\n}</code></pre>\n<p><strong>输出的结果是： 10</strong></p>\n<p>这是因为在defer之前返回值已经设置好了，所以执行的defer并不修改返回值。</p>\n<p>再如：</p>\n<pre><code class=\"go\">package main\n\nimport &quot;fmt&quot;\n\nfunc Defer() (x int) {\n\n    defer func() {\n        x += 20\n    }()\n\n    return 5\n}\n\nfunc main() {\n\n    n := Defer()\n\n    fmt.Print(n)\n\n}\n</code></pre>\n<p><strong>输出结果： 25</strong></p>\n<p>是不是有点出乎意料，这是因为在 Defer( ) 的定义里面 x作为返回值已经指定，所以其实底层执行的是：</p>\n<pre><code class=\"go\">1. x = 5\n2. x+=20\n3. return x</code></pre>\n<p>而：</p>\n<pre><code class=\"go\">package main\n\nimport &quot;fmt&quot;\n\nfunc Defer() (x int) {\n\n    y:=10\n    defer func() {\n        y += 20\n    }()\n\n    return y\n}\n\nfunc main() {\n\n    n := Defer()\n\n    fmt.Print(n)\n\n}</code></pre>\n<p><strong>输出结果：10</strong></p>\n<p>是不是觉得更奇怪啦，出乎意料的结果是吧！ 当然这些都是一些障眼法啦，只要了解返回值和defer的操作一下切都会显得很自然了。</p>\n<pre><code class=\"go\">1. x = y(10)\n2. defer()-&gt;不修改y，只修改副本\n3. 返回x(10)</code></pre>\n<p>最后：</p>\n<pre><code class=\"go\">package main\n\nimport &quot;fmt&quot;\n\nfunc Defer() (x int) {\n\n    y:=10\n    defer func(x int) {\n        x+=1\n    }(y)\n\n    return y\n}\n\nfunc main() {\n\n    n := Defer()\n\n    fmt.Print(n)\n\n}</code></pre>\n<p><strong>输出结果： 10</strong></p>\n<p>这个就比较简单，匿名函数传入的是值的副本，所以修改不到原值。</p>\n<p>好啦，defer到此结束～</p>\n"},{"title":"Go单元测试和压力测试","date":"2020-01-20T01:27:03.000Z","_content":"\n![](/start.png)\n\n# Go语言中的自动化测试框架\n\n​\t\ttesting包提供了自动化测试相关的框架，只需要在文件中引用测试包即可。\n\n```go\nimport(\ntesting\n)\n```\n\n支持单元测试和压力测试。以\n\n```go\ngo test\n```\n\n驱动测试案例的执行。\n\n## Go测试框架规范\n\n由于testing是一个自动化测试框架，所以我们在编写测试用例的时候需要遵循相对应的规范。\n\n- 用来测试的代码必须以   **_test.go**   结尾\n- 单元测试的函数名必须以.   **Test**   开头，并且只有一个参数，类型是 ***Testing.T**\n- 基准测试或者压力测试必须以.   **Benchmark**   开头，并且只有一个参数，类型是 ***Testing.B**\n\n## 基础的单元测试用例的编写\n\n新建两个go代码文件\n\n```go\nAdd.go\t\t\t\t\t\t // 代码文件\nAdd_test.go.       // 单元测试文件\n```\n\n其中：\n\n**Add.go** 里面包含一个基础的函数：\n\n```go\nfunc Add(a int,b int) int  {\n\treturn a+b\n}\n\n```\n\nAdd_test.go里面包含一个基础的单元测试用例：\n\n```go\nfunc TestAdd(t *testing.T) {\n\tvar a = 20\n\tvar b = 30\n\n\tc:= Add(a,b)\n\n\tif c!=30{\n\t\tt.Fatal(\"invaild : a+b\")  // 错误日志 执行此条panic 程序终止\n\t}\n  \n  t.Logf(\"a=%d b=%d,sum=%d\",a,b,c)  // 调试日志 用于输出\n}\n\n```\n\n别忘记引用测试包\n\n```go\nimport \"testing\"\n```\n\n此时执行 \n\n```go\ngo test \n```\n\n![](/png1.png)\n\n单元测试走了panic分支，因为这也是测试的预期。接着修改一下测试用例：\n\n```go\nfunc TestAdd(t *testing.T) {\n\tvar a = 20\n\tvar b = 30\n\n\tc:= Add(a,b)\n\n\tif c!=50{\n\t\tt.Fatal(\"invaild : a+b\")  // 错误日志 执行此条panic 程序终止\n\t}\n  \n  t.Logf(\"a=%d b=%d,sum=%d\",a,b,c)  // 调试日志 用于输出\n}\n```\n\n![](/png2.png)\n\n此时走的是正常的分支，不会出现panic，但是并不会出现任何的Log输出信息，因为默认情况下，t.Logf并不会直接把日志显示在终端，我们应该调用\n\n```go\ngo test -v\n```\n\nOK,结果如下：\n\n![](/png3.png)\n\ngo test 会执行**所有的以_test结尾的测试测试文件**中**所有的以TestFunc 为标准的所有测试用例**。\n\n### 压力测试 [ Benchmark ]\n\n我们自己写的一些通用库通常需要做相应的压力测试，testing包里面包含很好的压力测试条件和环境，使用起来也非常的简单。只需要在测试文件中相对应的测试用例名字以**Benchmake**开头，如：\n\n```go\nfunc BenchmarkAdd(b *testing.B) {\n  // N为测试框架自带的测试压力基准值\n\tfor i := 0; i < b.N; i++ {\n\t\tvar a = 10\n\t\tvar b = 20\n\t\tAdd(a,b)\n\t}\n}\n```\n\n如上代码，我们对Add函数执行压力测试，其中的N是框架传入的测试压力基准值，我么可以通过它做相应的轮询压力测试。\n\n测试的参数和单元测试不同的是，压力测试使用的是：\n\n```go\ngo test -bench .\n```\n\n执行结果：\n\n![](/png4.png)\n\n### 测试相关的参数\n\n- go test -bench . \t\t\t\t\t\t\t\t\t // 执行所有的压力测试案例\n- go test -bench BenchmarkAdd  \t\t\t//执行相对应的压力测试案例\n- go test -run TestAdd  \t\t\t\t\t\t     //执行特定的测试案例\n- go test -v\t\t\t\t\t\t\t\t\t\t\t\t//查看对应的测试详情","source":"_posts/Go单元测试和压力测试.md","raw":"---\n\ntitle: Go单元测试和压力测试\ndate: 2020-01-20 09:27:03\ntags: [Go,服务端开发,软件测试]\ncategories: Go栈\t\n---\n\n![](/start.png)\n\n# Go语言中的自动化测试框架\n\n​\t\ttesting包提供了自动化测试相关的框架，只需要在文件中引用测试包即可。\n\n```go\nimport(\ntesting\n)\n```\n\n支持单元测试和压力测试。以\n\n```go\ngo test\n```\n\n驱动测试案例的执行。\n\n## Go测试框架规范\n\n由于testing是一个自动化测试框架，所以我们在编写测试用例的时候需要遵循相对应的规范。\n\n- 用来测试的代码必须以   **_test.go**   结尾\n- 单元测试的函数名必须以.   **Test**   开头，并且只有一个参数，类型是 ***Testing.T**\n- 基准测试或者压力测试必须以.   **Benchmark**   开头，并且只有一个参数，类型是 ***Testing.B**\n\n## 基础的单元测试用例的编写\n\n新建两个go代码文件\n\n```go\nAdd.go\t\t\t\t\t\t // 代码文件\nAdd_test.go.       // 单元测试文件\n```\n\n其中：\n\n**Add.go** 里面包含一个基础的函数：\n\n```go\nfunc Add(a int,b int) int  {\n\treturn a+b\n}\n\n```\n\nAdd_test.go里面包含一个基础的单元测试用例：\n\n```go\nfunc TestAdd(t *testing.T) {\n\tvar a = 20\n\tvar b = 30\n\n\tc:= Add(a,b)\n\n\tif c!=30{\n\t\tt.Fatal(\"invaild : a+b\")  // 错误日志 执行此条panic 程序终止\n\t}\n  \n  t.Logf(\"a=%d b=%d,sum=%d\",a,b,c)  // 调试日志 用于输出\n}\n\n```\n\n别忘记引用测试包\n\n```go\nimport \"testing\"\n```\n\n此时执行 \n\n```go\ngo test \n```\n\n![](/png1.png)\n\n单元测试走了panic分支，因为这也是测试的预期。接着修改一下测试用例：\n\n```go\nfunc TestAdd(t *testing.T) {\n\tvar a = 20\n\tvar b = 30\n\n\tc:= Add(a,b)\n\n\tif c!=50{\n\t\tt.Fatal(\"invaild : a+b\")  // 错误日志 执行此条panic 程序终止\n\t}\n  \n  t.Logf(\"a=%d b=%d,sum=%d\",a,b,c)  // 调试日志 用于输出\n}\n```\n\n![](/png2.png)\n\n此时走的是正常的分支，不会出现panic，但是并不会出现任何的Log输出信息，因为默认情况下，t.Logf并不会直接把日志显示在终端，我们应该调用\n\n```go\ngo test -v\n```\n\nOK,结果如下：\n\n![](/png3.png)\n\ngo test 会执行**所有的以_test结尾的测试测试文件**中**所有的以TestFunc 为标准的所有测试用例**。\n\n### 压力测试 [ Benchmark ]\n\n我们自己写的一些通用库通常需要做相应的压力测试，testing包里面包含很好的压力测试条件和环境，使用起来也非常的简单。只需要在测试文件中相对应的测试用例名字以**Benchmake**开头，如：\n\n```go\nfunc BenchmarkAdd(b *testing.B) {\n  // N为测试框架自带的测试压力基准值\n\tfor i := 0; i < b.N; i++ {\n\t\tvar a = 10\n\t\tvar b = 20\n\t\tAdd(a,b)\n\t}\n}\n```\n\n如上代码，我们对Add函数执行压力测试，其中的N是框架传入的测试压力基准值，我么可以通过它做相应的轮询压力测试。\n\n测试的参数和单元测试不同的是，压力测试使用的是：\n\n```go\ngo test -bench .\n```\n\n执行结果：\n\n![](/png4.png)\n\n### 测试相关的参数\n\n- go test -bench . \t\t\t\t\t\t\t\t\t // 执行所有的压力测试案例\n- go test -bench BenchmarkAdd  \t\t\t//执行相对应的压力测试案例\n- go test -run TestAdd  \t\t\t\t\t\t     //执行特定的测试案例\n- go test -v\t\t\t\t\t\t\t\t\t\t\t\t//查看对应的测试详情","slug":"Go单元测试和压力测试","published":1,"updated":"2020-02-08T03:21:57.499Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rj30008zd5b68b83s0b","content":"<p><img src=\"/2020/01/20/go-dan-yuan-ce-shi-he-ya-li-ce-shi/start.png\" alt></p>\n<h1 id=\"Go语言中的自动化测试框架\"><a href=\"#Go语言中的自动化测试框架\" class=\"headerlink\" title=\"Go语言中的自动化测试框架\"></a>Go语言中的自动化测试框架</h1><p>​        testing包提供了自动化测试相关的框架，只需要在文件中引用测试包即可。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span>\ntesting\n<span class=\"token punctuation\">)</span></code></pre>\n<p>支持单元测试和压力测试。以</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">go</span> test</code></pre>\n<p>驱动测试案例的执行。</p>\n<h2 id=\"Go测试框架规范\"><a href=\"#Go测试框架规范\" class=\"headerlink\" title=\"Go测试框架规范\"></a>Go测试框架规范</h2><p>由于testing是一个自动化测试框架，所以我们在编写测试用例的时候需要遵循相对应的规范。</p>\n<ul>\n<li>用来测试的代码必须以   <strong>_test.go</strong>   结尾</li>\n<li>单元测试的函数名必须以.   <strong>Test</strong>   开头，并且只有一个参数，类型是 <strong>*Testing.T</strong></li>\n<li>基准测试或者压力测试必须以.   <strong>Benchmark</strong>   开头，并且只有一个参数，类型是 <strong>*Testing.B</strong></li>\n</ul>\n<h2 id=\"基础的单元测试用例的编写\"><a href=\"#基础的单元测试用例的编写\" class=\"headerlink\" title=\"基础的单元测试用例的编写\"></a>基础的单元测试用例的编写</h2><p>新建两个go代码文件</p>\n<pre class=\" language-go\"><code class=\"language-go\">Add<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span>                         <span class=\"token comment\" spellcheck=\"true\">// 代码文件</span>\nAdd_test<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span><span class=\"token punctuation\">.</span>       <span class=\"token comment\" spellcheck=\"true\">// 单元测试文件</span></code></pre>\n<p>其中：</p>\n<p><strong>Add.go</strong> 里面包含一个基础的函数：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>a <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span>b <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span>  <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> a<span class=\"token operator\">+</span>b\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>Add_test.go里面包含一个基础的单元测试用例：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">TestAdd</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>testing<span class=\"token punctuation\">.</span>T<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">20</span>\n    <span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token number\">30</span>\n\n    c<span class=\"token operator\">:=</span> <span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> c<span class=\"token operator\">!=</span><span class=\"token number\">30</span><span class=\"token punctuation\">{</span>\n        t<span class=\"token punctuation\">.</span><span class=\"token function\">Fatal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"invaild : a+b\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 错误日志 执行此条panic 程序终止</span>\n    <span class=\"token punctuation\">}</span>\n\n  t<span class=\"token punctuation\">.</span><span class=\"token function\">Logf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a=%d b=%d,sum=%d\"</span><span class=\"token punctuation\">,</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 调试日志 用于输出</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>别忘记引用测试包</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">import</span> <span class=\"token string\">\"testing\"</span></code></pre>\n<p>此时执行 </p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">go</span> test </code></pre>\n<p><img src=\"/2020/01/20/go-dan-yuan-ce-shi-he-ya-li-ce-shi/png1.png\" alt></p>\n<p>单元测试走了panic分支，因为这也是测试的预期。接着修改一下测试用例：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">TestAdd</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>testing<span class=\"token punctuation\">.</span>T<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">20</span>\n    <span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token number\">30</span>\n\n    c<span class=\"token operator\">:=</span> <span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> c<span class=\"token operator\">!=</span><span class=\"token number\">50</span><span class=\"token punctuation\">{</span>\n        t<span class=\"token punctuation\">.</span><span class=\"token function\">Fatal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"invaild : a+b\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 错误日志 执行此条panic 程序终止</span>\n    <span class=\"token punctuation\">}</span>\n\n  t<span class=\"token punctuation\">.</span><span class=\"token function\">Logf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a=%d b=%d,sum=%d\"</span><span class=\"token punctuation\">,</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 调试日志 用于输出</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><img src=\"/2020/01/20/go-dan-yuan-ce-shi-he-ya-li-ce-shi/png2.png\" alt></p>\n<p>此时走的是正常的分支，不会出现panic，但是并不会出现任何的Log输出信息，因为默认情况下，t.Logf并不会直接把日志显示在终端，我们应该调用</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">go</span> test <span class=\"token operator\">-</span>v</code></pre>\n<p>OK,结果如下：</p>\n<p><img src=\"/2020/01/20/go-dan-yuan-ce-shi-he-ya-li-ce-shi/png3.png\" alt></p>\n<p>go test 会执行<strong>所有的以_test结尾的测试测试文件</strong>中<strong>所有的以TestFunc 为标准的所有测试用例</strong>。</p>\n<h3 id=\"压力测试-Benchmark\"><a href=\"#压力测试-Benchmark\" class=\"headerlink\" title=\"压力测试 [ Benchmark ]\"></a>压力测试 [ Benchmark ]</h3><p>我们自己写的一些通用库通常需要做相应的压力测试，testing包里面包含很好的压力测试条件和环境，使用起来也非常的简单。只需要在测试文件中相对应的测试用例名字以<strong>Benchmake</strong>开头，如：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">BenchmarkAdd</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">*</span>testing<span class=\"token punctuation\">.</span>B<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// N为测试框架自带的测试压力基准值</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">.</span>N<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n        <span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token number\">20</span>\n        <span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>如上代码，我们对Add函数执行压力测试，其中的N是框架传入的测试压力基准值，我么可以通过它做相应的轮询压力测试。</p>\n<p>测试的参数和单元测试不同的是，压力测试使用的是：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">go</span> test <span class=\"token operator\">-</span>bench <span class=\"token punctuation\">.</span></code></pre>\n<p>执行结果：</p>\n<p><img src=\"/2020/01/20/go-dan-yuan-ce-shi-he-ya-li-ce-shi/png4.png\" alt></p>\n<h3 id=\"测试相关的参数\"><a href=\"#测试相关的参数\" class=\"headerlink\" title=\"测试相关的参数\"></a>测试相关的参数</h3><ul>\n<li>go test -bench .                                      // 执行所有的压力测试案例</li>\n<li>go test -bench BenchmarkAdd              //执行相对应的压力测试案例</li>\n<li>go test -run TestAdd                               //执行特定的测试案例</li>\n<li>go test -v                                                //查看对应的测试详情</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<p><img src=\"/2020/01/20/go-dan-yuan-ce-shi-he-ya-li-ce-shi/start.png\" alt></p>\n<h1 id=\"Go语言中的自动化测试框架\"><a href=\"#Go语言中的自动化测试框架\" class=\"headerlink\" title=\"Go语言中的自动化测试框架\"></a>Go语言中的自动化测试框架</h1><p>​        testing包提供了自动化测试相关的框架，只需要在文件中引用测试包即可。</p>\n<pre><code class=\"go\">import(\ntesting\n)</code></pre>\n<p>支持单元测试和压力测试。以</p>\n<pre><code class=\"go\">go test</code></pre>\n<p>驱动测试案例的执行。</p>\n<h2 id=\"Go测试框架规范\"><a href=\"#Go测试框架规范\" class=\"headerlink\" title=\"Go测试框架规范\"></a>Go测试框架规范</h2><p>由于testing是一个自动化测试框架，所以我们在编写测试用例的时候需要遵循相对应的规范。</p>\n<ul>\n<li>用来测试的代码必须以   <strong>_test.go</strong>   结尾</li>\n<li>单元测试的函数名必须以.   <strong>Test</strong>   开头，并且只有一个参数，类型是 <strong>*Testing.T</strong></li>\n<li>基准测试或者压力测试必须以.   <strong>Benchmark</strong>   开头，并且只有一个参数，类型是 <strong>*Testing.B</strong></li>\n</ul>\n<h2 id=\"基础的单元测试用例的编写\"><a href=\"#基础的单元测试用例的编写\" class=\"headerlink\" title=\"基础的单元测试用例的编写\"></a>基础的单元测试用例的编写</h2><p>新建两个go代码文件</p>\n<pre><code class=\"go\">Add.go                         // 代码文件\nAdd_test.go.       // 单元测试文件</code></pre>\n<p>其中：</p>\n<p><strong>Add.go</strong> 里面包含一个基础的函数：</p>\n<pre><code class=\"go\">func Add(a int,b int) int  {\n    return a+b\n}\n</code></pre>\n<p>Add_test.go里面包含一个基础的单元测试用例：</p>\n<pre><code class=\"go\">func TestAdd(t *testing.T) {\n    var a = 20\n    var b = 30\n\n    c:= Add(a,b)\n\n    if c!=30{\n        t.Fatal(&quot;invaild : a+b&quot;)  // 错误日志 执行此条panic 程序终止\n    }\n\n  t.Logf(&quot;a=%d b=%d,sum=%d&quot;,a,b,c)  // 调试日志 用于输出\n}\n</code></pre>\n<p>别忘记引用测试包</p>\n<pre><code class=\"go\">import &quot;testing&quot;</code></pre>\n<p>此时执行 </p>\n<pre><code class=\"go\">go test </code></pre>\n<p><img src=\"/2020/01/20/go-dan-yuan-ce-shi-he-ya-li-ce-shi/png1.png\" alt></p>\n<p>单元测试走了panic分支，因为这也是测试的预期。接着修改一下测试用例：</p>\n<pre><code class=\"go\">func TestAdd(t *testing.T) {\n    var a = 20\n    var b = 30\n\n    c:= Add(a,b)\n\n    if c!=50{\n        t.Fatal(&quot;invaild : a+b&quot;)  // 错误日志 执行此条panic 程序终止\n    }\n\n  t.Logf(&quot;a=%d b=%d,sum=%d&quot;,a,b,c)  // 调试日志 用于输出\n}</code></pre>\n<p><img src=\"/2020/01/20/go-dan-yuan-ce-shi-he-ya-li-ce-shi/png2.png\" alt></p>\n<p>此时走的是正常的分支，不会出现panic，但是并不会出现任何的Log输出信息，因为默认情况下，t.Logf并不会直接把日志显示在终端，我们应该调用</p>\n<pre><code class=\"go\">go test -v</code></pre>\n<p>OK,结果如下：</p>\n<p><img src=\"/2020/01/20/go-dan-yuan-ce-shi-he-ya-li-ce-shi/png3.png\" alt></p>\n<p>go test 会执行<strong>所有的以_test结尾的测试测试文件</strong>中<strong>所有的以TestFunc 为标准的所有测试用例</strong>。</p>\n<h3 id=\"压力测试-Benchmark\"><a href=\"#压力测试-Benchmark\" class=\"headerlink\" title=\"压力测试 [ Benchmark ]\"></a>压力测试 [ Benchmark ]</h3><p>我们自己写的一些通用库通常需要做相应的压力测试，testing包里面包含很好的压力测试条件和环境，使用起来也非常的简单。只需要在测试文件中相对应的测试用例名字以<strong>Benchmake</strong>开头，如：</p>\n<pre><code class=\"go\">func BenchmarkAdd(b *testing.B) {\n  // N为测试框架自带的测试压力基准值\n    for i := 0; i &lt; b.N; i++ {\n        var a = 10\n        var b = 20\n        Add(a,b)\n    }\n}</code></pre>\n<p>如上代码，我们对Add函数执行压力测试，其中的N是框架传入的测试压力基准值，我么可以通过它做相应的轮询压力测试。</p>\n<p>测试的参数和单元测试不同的是，压力测试使用的是：</p>\n<pre><code class=\"go\">go test -bench .</code></pre>\n<p>执行结果：</p>\n<p><img src=\"/2020/01/20/go-dan-yuan-ce-shi-he-ya-li-ce-shi/png4.png\" alt></p>\n<h3 id=\"测试相关的参数\"><a href=\"#测试相关的参数\" class=\"headerlink\" title=\"测试相关的参数\"></a>测试相关的参数</h3><ul>\n<li>go test -bench .                                      // 执行所有的压力测试案例</li>\n<li>go test -bench BenchmarkAdd              //执行相对应的压力测试案例</li>\n<li>go test -run TestAdd                               //执行特定的测试案例</li>\n<li>go test -v                                                //查看对应的测试详情</li>\n</ul>\n"},{"title":"Go常用语法糖炮弹工具集","date":"2020-01-10T04:52:21.000Z","_content":"\n![](/p1.jpg)\n\n### 关于Go\n\nGo语言虽然说是C族语言，也被调侃为21世纪网络C语言，但是Go不得不说它是一种简单到特立独行的语言。\n\n```go\nvar age int\nname := \"小鬼 Boy\"\n```\n\n万种风流，都放在类型后面的，它放在前面..\n\n```go\ntype Animal interface {\n\tName()\n\tSay()\n\tEat()\n}\n```\n\n```go\ntype Dog struct {\n\n}\n\nfunc (dog * Dog)Name()  {\n\tfmt.Println(\"我叫旺财\")\n}\n\nfunc (dog * Dog)Say()  {\n\tfmt.Println(\"旺旺\")\n}\n\nfunc (dog * Dog)Eat()  {\n\tfmt.Println(\"哇哦\")\n}\n```\n\n没有Class概念，却有着非同寻常的interface，可以说Go是组合优于继承的集大成者。\n\n更像一个100斤小孩子的是， 时间格式化的方式居然固定在Go语言的生日！！wtf？ 写错一个数字居然会有意想不到的结果...\n\n```go\nnowStr := now.Format(\"2006-01-02 15:04:05.999\")  //固定数字 格式可以随便搭配\n```\n\n另外，在编写日志库系统的时候，难免会用到取得当前crash的位置：\n\n```go\nfunc GetLineInfo(fileName string,funcName string,lineNumber int){\n\tpc,file,line,ok := runtime.Caller(0)\n\tif ok{\n\t\tfileName = file\n    //pc转函数\n\t\tfuncName = runtime.FuncForPC(pc).Name()\n\t\tlineNumber = line\n\t}\n\treturn\n}\n```\n\npc是当前运行到的指令计数器\nruntime.Caller(0)后面的**参数**是表示**函数调用栈**里面的函数的所在行，所以当参数为 0 时代表的是当前GetLineInfo（）的函数所在行，当参数为 1 时表示GetLineInfo的被调函数头所在行，以此类推。\n\n```go\n10 \tfuc DropParent(){\n11    \tfileName, funcName, lineNumber := GetLineInfo()\n12 \t}\n\n14 fun DropGrandParent(){\n15  DropParent()\n16 }\n```\n\n当：\n\n```\nruntime.Caller(0)时\n```\n\n返回的是函数栈栈底函数的所在地址，即 func GetLineInfo(fileName string,funcName string,lineNumber int)所在行，\n\n当\n\n```go\nruntime.Caller(1)时\n```\n\n返回的是函数栈栈底第二个函数的所在地址，即 fuc DropParent()所在行，如此往复。\n\n先写到这，以后再写更多的go的一些常用到但是每次还要去查阅的相关的东西。","source":"_posts/Go常用语法糖炮弹工具集.md","raw":"---\ntitle: Go常用语法糖炮弹工具集\ndate: 2020-01-10 12:52:21\ntags: [Go,服务端开发]\ncategories: Go栈\n---\n\n![](/p1.jpg)\n\n### 关于Go\n\nGo语言虽然说是C族语言，也被调侃为21世纪网络C语言，但是Go不得不说它是一种简单到特立独行的语言。\n\n```go\nvar age int\nname := \"小鬼 Boy\"\n```\n\n万种风流，都放在类型后面的，它放在前面..\n\n```go\ntype Animal interface {\n\tName()\n\tSay()\n\tEat()\n}\n```\n\n```go\ntype Dog struct {\n\n}\n\nfunc (dog * Dog)Name()  {\n\tfmt.Println(\"我叫旺财\")\n}\n\nfunc (dog * Dog)Say()  {\n\tfmt.Println(\"旺旺\")\n}\n\nfunc (dog * Dog)Eat()  {\n\tfmt.Println(\"哇哦\")\n}\n```\n\n没有Class概念，却有着非同寻常的interface，可以说Go是组合优于继承的集大成者。\n\n更像一个100斤小孩子的是， 时间格式化的方式居然固定在Go语言的生日！！wtf？ 写错一个数字居然会有意想不到的结果...\n\n```go\nnowStr := now.Format(\"2006-01-02 15:04:05.999\")  //固定数字 格式可以随便搭配\n```\n\n另外，在编写日志库系统的时候，难免会用到取得当前crash的位置：\n\n```go\nfunc GetLineInfo(fileName string,funcName string,lineNumber int){\n\tpc,file,line,ok := runtime.Caller(0)\n\tif ok{\n\t\tfileName = file\n    //pc转函数\n\t\tfuncName = runtime.FuncForPC(pc).Name()\n\t\tlineNumber = line\n\t}\n\treturn\n}\n```\n\npc是当前运行到的指令计数器\nruntime.Caller(0)后面的**参数**是表示**函数调用栈**里面的函数的所在行，所以当参数为 0 时代表的是当前GetLineInfo（）的函数所在行，当参数为 1 时表示GetLineInfo的被调函数头所在行，以此类推。\n\n```go\n10 \tfuc DropParent(){\n11    \tfileName, funcName, lineNumber := GetLineInfo()\n12 \t}\n\n14 fun DropGrandParent(){\n15  DropParent()\n16 }\n```\n\n当：\n\n```\nruntime.Caller(0)时\n```\n\n返回的是函数栈栈底函数的所在地址，即 func GetLineInfo(fileName string,funcName string,lineNumber int)所在行，\n\n当\n\n```go\nruntime.Caller(1)时\n```\n\n返回的是函数栈栈底第二个函数的所在地址，即 fuc DropParent()所在行，如此往复。\n\n先写到这，以后再写更多的go的一些常用到但是每次还要去查阅的相关的东西。","slug":"Go常用语法糖炮弹工具集","published":1,"updated":"2020-02-07T06:26:35.926Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rj60009zd5b1r4a6zfy","content":"<p><img src=\"/2020/01/10/go-chang-yong-yu-fa-tang-pao-dan-gong-ju-ji/p1.jpg\" alt></p>\n<h3 id=\"关于Go\"><a href=\"#关于Go\" class=\"headerlink\" title=\"关于Go\"></a>关于Go</h3><p>Go语言虽然说是C族语言，也被调侃为21世纪网络C语言，但是Go不得不说它是一种简单到特立独行的语言。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> age <span class=\"token builtin\">int</span>\nname <span class=\"token operator\">:=</span> <span class=\"token string\">\"小鬼 Boy\"</span></code></pre>\n<p>万种风流，都放在类型后面的，它放在前面..</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Animal <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">Say</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">Eat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Dog <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>dog <span class=\"token operator\">*</span> Dog<span class=\"token punctuation\">)</span><span class=\"token function\">Name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">{</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"我叫旺财\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>dog <span class=\"token operator\">*</span> Dog<span class=\"token punctuation\">)</span><span class=\"token function\">Say</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">{</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"旺旺\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>dog <span class=\"token operator\">*</span> Dog<span class=\"token punctuation\">)</span><span class=\"token function\">Eat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">{</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"哇哦\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>没有Class概念，却有着非同寻常的interface，可以说Go是组合优于继承的集大成者。</p>\n<p>更像一个100斤小孩子的是， 时间格式化的方式居然固定在Go语言的生日！！wtf？ 写错一个数字居然会有意想不到的结果…</p>\n<pre class=\" language-go\"><code class=\"language-go\">nowStr <span class=\"token operator\">:=</span> now<span class=\"token punctuation\">.</span><span class=\"token function\">Format</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2006-01-02 15:04:05.999\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">//固定数字 格式可以随便搭配</span></code></pre>\n<p>另外，在编写日志库系统的时候，难免会用到取得当前crash的位置：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">GetLineInfo</span><span class=\"token punctuation\">(</span>fileName <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span>funcName <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span>lineNumber <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    pc<span class=\"token punctuation\">,</span>file<span class=\"token punctuation\">,</span>line<span class=\"token punctuation\">,</span>ok <span class=\"token operator\">:=</span> runtime<span class=\"token punctuation\">.</span><span class=\"token function\">Caller</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> ok<span class=\"token punctuation\">{</span>\n        fileName <span class=\"token operator\">=</span> file\n    <span class=\"token comment\" spellcheck=\"true\">//pc转函数</span>\n        funcName <span class=\"token operator\">=</span> runtime<span class=\"token punctuation\">.</span><span class=\"token function\">FuncForPC</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">Name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        lineNumber <span class=\"token operator\">=</span> line\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>pc是当前运行到的指令计数器<br>runtime.Caller(0)后面的<strong>参数</strong>是表示<strong>函数调用栈</strong>里面的函数的所在行，所以当参数为 0 时代表的是当前GetLineInfo（）的函数所在行，当参数为 1 时表示GetLineInfo的被调函数头所在行，以此类推。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token number\">10</span>     fuc <span class=\"token function\">DropParent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token number\">11</span>        fileName<span class=\"token punctuation\">,</span> funcName<span class=\"token punctuation\">,</span> lineNumber <span class=\"token operator\">:=</span> <span class=\"token function\">GetLineInfo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token number\">12</span>     <span class=\"token punctuation\">}</span>\n\n<span class=\"token number\">14</span> fun <span class=\"token function\">DropGrandParent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token number\">15</span>  <span class=\"token function\">DropParent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token number\">16</span> <span class=\"token punctuation\">}</span></code></pre>\n<p>当：</p>\n<pre><code>runtime.Caller(0)时</code></pre><p>返回的是函数栈栈底函数的所在地址，即 func GetLineInfo(fileName string,funcName string,lineNumber int)所在行，</p>\n<p>当</p>\n<pre class=\" language-go\"><code class=\"language-go\">runtime<span class=\"token punctuation\">.</span><span class=\"token function\">Caller</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>时</code></pre>\n<p>返回的是函数栈栈底第二个函数的所在地址，即 fuc DropParent()所在行，如此往复。</p>\n<p>先写到这，以后再写更多的go的一些常用到但是每次还要去查阅的相关的东西。</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<p><img src=\"/2020/01/10/go-chang-yong-yu-fa-tang-pao-dan-gong-ju-ji/p1.jpg\" alt></p>\n<h3 id=\"关于Go\"><a href=\"#关于Go\" class=\"headerlink\" title=\"关于Go\"></a>关于Go</h3><p>Go语言虽然说是C族语言，也被调侃为21世纪网络C语言，但是Go不得不说它是一种简单到特立独行的语言。</p>\n<pre><code class=\"go\">var age int\nname := &quot;小鬼 Boy&quot;</code></pre>\n<p>万种风流，都放在类型后面的，它放在前面..</p>\n<pre><code class=\"go\">type Animal interface {\n    Name()\n    Say()\n    Eat()\n}</code></pre>\n<pre><code class=\"go\">type Dog struct {\n\n}\n\nfunc (dog * Dog)Name()  {\n    fmt.Println(&quot;我叫旺财&quot;)\n}\n\nfunc (dog * Dog)Say()  {\n    fmt.Println(&quot;旺旺&quot;)\n}\n\nfunc (dog * Dog)Eat()  {\n    fmt.Println(&quot;哇哦&quot;)\n}</code></pre>\n<p>没有Class概念，却有着非同寻常的interface，可以说Go是组合优于继承的集大成者。</p>\n<p>更像一个100斤小孩子的是， 时间格式化的方式居然固定在Go语言的生日！！wtf？ 写错一个数字居然会有意想不到的结果…</p>\n<pre><code class=\"go\">nowStr := now.Format(&quot;2006-01-02 15:04:05.999&quot;)  //固定数字 格式可以随便搭配</code></pre>\n<p>另外，在编写日志库系统的时候，难免会用到取得当前crash的位置：</p>\n<pre><code class=\"go\">func GetLineInfo(fileName string,funcName string,lineNumber int){\n    pc,file,line,ok := runtime.Caller(0)\n    if ok{\n        fileName = file\n    //pc转函数\n        funcName = runtime.FuncForPC(pc).Name()\n        lineNumber = line\n    }\n    return\n}</code></pre>\n<p>pc是当前运行到的指令计数器<br>runtime.Caller(0)后面的<strong>参数</strong>是表示<strong>函数调用栈</strong>里面的函数的所在行，所以当参数为 0 时代表的是当前GetLineInfo（）的函数所在行，当参数为 1 时表示GetLineInfo的被调函数头所在行，以此类推。</p>\n<pre><code class=\"go\">10     fuc DropParent(){\n11        fileName, funcName, lineNumber := GetLineInfo()\n12     }\n\n14 fun DropGrandParent(){\n15  DropParent()\n16 }</code></pre>\n<p>当：</p>\n<pre><code>runtime.Caller(0)时</code></pre><p>返回的是函数栈栈底函数的所在地址，即 func GetLineInfo(fileName string,funcName string,lineNumber int)所在行，</p>\n<p>当</p>\n<pre><code class=\"go\">runtime.Caller(1)时</code></pre>\n<p>返回的是函数栈栈底第二个函数的所在地址，即 fuc DropParent()所在行，如此往复。</p>\n<p>先写到这，以后再写更多的go的一些常用到但是每次还要去查阅的相关的东西。</p>\n"},{"title":"Go并发编程初探","date":"2020-01-20T11:17:11.000Z","_content":"\n### 并发与并行\n\n并发：同一时段内执行多个操作,如两排公用一台咖啡机，在时间粒度为1h时的情况下，我们可以把它看作是一个人眼可见的并发模型，当然这只是个比喻。\n\n![](/png1.png)\n\n并行：同一时刻执行多个操作，这里就涉及到两个咖啡机同时处理操作。\n\n![](/png2.png)\n\n明白了并发和并行的话，接下来就好说。\n\n**多线程技术**\n\n- 线程是有操作系统管理的一组程序的执行流，是操作系统能操作的最小单位。简而言之，线程是一个程序运行时[进程]产生的一个小分支，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的**内核线程**和由用户进程自行调度的**用户线程**\n- 在很多的编程语言里面，多线程技术的实现是一个抢占式的模型，每一个属于应用层面的线程都是附属于该应用的一个运行分支，通过cpu来进行调度，但是在操作系统层面，不断的从内核态到应用态的切换会使得CPU的处理消耗得更大，简而言之，直接通过操作系统调度不断切换的线程，因为涉及到当前线程从被挂起到得到时间片恢复会浪费很大的资源。所以在java里面对于多线程的使用都会使用线程池来进行优化，但是这种优化也是有瓶颈的，毕竟只是在运用层面。\n- Go语言的**goroutine技术**是类似于**unity的协程**技术，但是与之不相同的事，他是在语言层面在Go运行时的内核里面做自己的调度，所以当CPU给到进程时间片的时候，内核会直接对进程树下面的所有的微线程的[goroutine]进行调度，减少了操作系统层面的上下文切换，非常的轻量级。\n\n### Goroutine原理\n\n简而言之，一个操作系统会对应用户态多个goroutine，而且会使用多个操作系统进线程，而且操作系统线程对于goroutine是 **M：N**的关系。\n\n做一个模型抽象：\n\n- 造作系统线程设为：  M\n- 用户态线程 [ goroutine ] 设为:    G\n- 上下文对象设为：    P\n\n![](/png6.png)\n\n其中G会被M去执行，P相当于执行的中间件，也就是M执行G任务的时候P是执行环境，只是类似于操作系统内核态的上下文，只是足够的轻量级。\n\n### Goroutine调度\n\n![](/png7.png)\n\n当前M执行G任务时，其他的G会进入等待状态，当当前的G被调度完成或者时间片轮询超时，此时的G会被放入队尾，队头任务被调度，依次轮询执行，当然这里面还有一些其他的调度算法。\n\n### 当用户态线程阻塞时如何调度？\n\n由于我们的物理线程会对应执行多个用户态线程(Goroutine)，当我们的某个goroutine进行一个耗时操作的时候，比如：\n\n![](/png8.png)\n\n当当前Mo调度Go进行耗时的文件操作时，如果调度依旧进行，则会出现接下来的所有的被Mo调度的goroutine都会‘卡死’，所以呢，Go在运行时内核为这样的耗时操作新开一个调度，然后单一的去执行耗时操作，其余的依旧轮询使用时间片调度。\n\n### Goroutine池\n\n当我们在进行某些并发操作计算的时候，每次遇到都开启新的goroutine去执行，难免会出现goroutine的暴增，使用不当甚至出现泄漏的情况。通常使用goroutine池来进行任务的调配和线程间通信。\n\n比如一个非常简单的例子，**随机不断生成随机数，然后启动worker池来进行计算每个数的各个位上的数的和并且输出。**\n\n> number: 1234 , result: 1+2+3+4 = 10\n\n开两个抽象类进行封装：\n\n```go\ntype Job struct {\n\tJobId  int\n\tNumber int\n}\n\ntype Result struct {\n\tJob *Job\n\tsum int\n}\n```\n\n一个是表示一个计算任务，一个存储计算结果。\n\n每一个worker都回去做计算任务，并且把计算的结果放入结果队列。\n\n```go\n// 求出每个位上的值的和 如1234 = 1+2+3+4 = 10\nfunc (job *Job) Work(result chan *Result) {\n\n\t//计算\n\tsum := 0\n\tnumber := job.Number\n\n\tfor number != 0 {\n\t\ttemp := number % 10\n\t\tsum += temp\n\t\tnumber /= 10\n\t}\n\n\t//把计算的结果变成对象\n\tr := &Result{\n\t\tJob: job,\n\t\tsum: sum,\n\t}\n\n\t//写入管道\n\tresult <- r\n\n}\n\n```\n\n而每一个Worker负责从任务队列里面取出任务，然后进行计算。\n\n```go\nfunc Worker(jobChan chan *Job, resultChan chan *Result) {\n\n\tfor job := range jobChan {\n\t\tjob.Work(resultChan)\n\t}\n}\n\n```\n\n再封装一个启动器,表示启动多大的worker池。\n\n```go\n//启动worker池\nfunc StartWorkerPool(poolSize int, jobChan chan *Job, resultChan chan *Result) {\n\tfor i := 0; i < poolSize; i++ {\n\t\tgo Worker(jobChan, resultChan)\n\t}\n}\n```\n\n用于产生随机数的接口和输出结果的接口是用来做显示的，这也列出来。\n\n```go\nfunc ProductJobs(jobChan chan *Job) {\n\tjobId := 1\n\tfor {\n\t\tjobId++\n\n\t\tnumber := rand.Int()\n\n\t\tjob := &Job{\n\t\t\tJobId:  jobId,\n\t\t\tNumber: number,\n\t\t}\n\n\t\tjobChan <- job\n\n\t}\n\n}\n\nfunc PrintWorker(resultChan chan *Result) {\n\tfor result := range resultChan {\n\t\tfmt.Printf(\"JobId : %d number: %d  result : %d \\n\", result.Job.JobId, result.Job.Number, result.sum)\n\t}\n}\n\n```\n\n最后只需在main里面进行调用即可。\n\n```go\nfunc main() {\n\n\tjobChan := make(chan *Job, 1024)\n\tresultChan := make(chan *Result, 1024)\n\n\t//启动worker池\n\tStartWorkerPool(512, jobChan, resultChan)\n\n\tgo PrintWorker(resultChan)\n\n\tgo ProductJobs(jobChan)\n\n\tselect {}\n}\n```\n\n结果；\n\n![](/png9.png)\n\n这是个非常简单的例子，但是仔细看会觉得很优雅，这个就是使用goroutine实现像工厂流水线一般的运作方式。\n\n### 线程安全\n\n首先，Go语言在设计理念上已经做到了足够简单，我们无须像C/C++，Java等语言在设计多线程的时候考虑各种线程之间的问题以及多线程管理带来的麻烦。但是，只要有并发的概念，那就避免不了资源冲突的问题。我以前在设计游戏的时候，因为有些游戏的逻辑比较复杂，用到的协程非常多，导致很多的资源在我某个协程取它的时候已经实现被其他协程修改了。\n\n比如说： 我有两个协程，一个是用来计算修改子弹的伤害，一个是用来计算子弹销毁。如果两个协程不自己进行处理的话，很多时候子弹就会突然消失。当然游戏设计并不是说的这么简单，中间还有很多的逻辑。\n\n所以我们需要在两个同时想持有某项资源的线程做一个限定，不能让操作同时发生，出现意料之外的结果。而这样的被多个线程所持有的资源没称作临界资源或临界区。\n\n```go\nx = x+10\n```\n\n这是一个看起来再简单不过的语句，但是要知道在并发的世界里面，什么都没这么简单，我们分析一下，在程序底层实际上是做了三步**原子操作**：\n\n1. 先从内存中取出x的值\n2. CPU进行计算 x+10\n3. 把x+10存储到内存中\n\n为什么这么分析，因为中间的每一步都有可能被别人取先。 所以我们需要加锁而避免出现临界资源在多个线程同时操作下出现问题。\n\n![](/lock.jpg)\n\n### 互斥锁\n\n当对某个资源进行非原子操作的时候，我们对此操作加锁，使得其他的线程对其操作的时候只能等待其锁被释放后才能进入临界区，而多个线程等待的时候，其唤醒策略是随机的，或者看线程的优先级而定。\n\n```go\nvar mutex sync.Mutex   // 在全局区定义互斥锁\n\nmutex.Lock()\ni++\nmutex.Unlock()\n\n```\n\n使用很简单，只需在临界操作前加锁，操作后解除锁即可。\n\n### 读写锁\n\n在我们对临界区资源进行读操作的时候其实是不用加锁的的，加锁反而会降低性能。但是当我们需要读取值的时候却中途被雪入了其他不正确的值，就会出现错误。所以**读写锁**应运而生。\n\n**读锁：**\n\n- 当一个goroutine获得读锁以后，**其他的goroutine获取写锁都会等待。**\n- 当一个goroutine获得读锁以后，**其他的goroutine获得读锁时，都会获得锁。**\n\n**写锁：**\n\n- 当一个goroutine获得写锁以后，**其他的goroutine获取写锁和读锁都会等待,写锁是互斥的**\n\n```go\nvar rwLock sync.RWMutex\n\n//读锁\nrwLock.RLock()\nfmt.Println(\"a = \",a)\nrwlock.RUnlock()\n\n\n//写锁\nrwLock.Lock()\na++\nrwlock.Unlock()\n```\n\n在读多写少的情况下，读写锁的性能比互斥锁高很多。\n\n### 原子操作\n\n为什么要介绍原子操作呢？这个原子操作和上面讲的单步的原子操作是不一样的两件事，这个原子操作是Go语言里面的一种单步操作的函数。由于**加锁代价比较高，比较耗时，需要上下文切换**。所以在Go语言里面，针对基本数据类型可以使用原子操作保证线程安全。原子操作可以在用户态就可以完成，所以性能比互斥锁高。\n\n在使用互斥锁的时候：\n\n```go\nvar mutex sync.Mutex   // 在全局区定义互斥锁\n\nmutex.Lock()\ni++\nmutex.Unlock()\n```\n\n原子操作：\n\n```go\natomic.AddInt32(&x,1)  // 相当于x = x + 1\n```\n\n我对10000个goroutine进行原子操作和互斥锁操作，原子操作的性能是互斥锁的5倍左右，锁着goroutine的数量级越大，性能差异也就越大。\n\n相对应的其他原子操作：\n\n```go\na := atomic.LoadInt32(&x)   \t\t\t\t\t\t//  加载操作.  var a int = x \natomic.StoreInt32(&x,10)   \t\t\t\t\t\t  //  写入. x = 10\nb := atomic.SwapInt32(&x,10)\t\t\t\t\t  //  交换操作\n```\n\n","source":"_posts/Go并发编程初探.md","raw":"---\ntitle: Go并发编程初探\ndate: 2020-01-20 19:17:11\ntags: [Go,服务端开发,并发编程]\ncategories: Go栈 \n---\n\n### 并发与并行\n\n并发：同一时段内执行多个操作,如两排公用一台咖啡机，在时间粒度为1h时的情况下，我们可以把它看作是一个人眼可见的并发模型，当然这只是个比喻。\n\n![](/png1.png)\n\n并行：同一时刻执行多个操作，这里就涉及到两个咖啡机同时处理操作。\n\n![](/png2.png)\n\n明白了并发和并行的话，接下来就好说。\n\n**多线程技术**\n\n- 线程是有操作系统管理的一组程序的执行流，是操作系统能操作的最小单位。简而言之，线程是一个程序运行时[进程]产生的一个小分支，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的**内核线程**和由用户进程自行调度的**用户线程**\n- 在很多的编程语言里面，多线程技术的实现是一个抢占式的模型，每一个属于应用层面的线程都是附属于该应用的一个运行分支，通过cpu来进行调度，但是在操作系统层面，不断的从内核态到应用态的切换会使得CPU的处理消耗得更大，简而言之，直接通过操作系统调度不断切换的线程，因为涉及到当前线程从被挂起到得到时间片恢复会浪费很大的资源。所以在java里面对于多线程的使用都会使用线程池来进行优化，但是这种优化也是有瓶颈的，毕竟只是在运用层面。\n- Go语言的**goroutine技术**是类似于**unity的协程**技术，但是与之不相同的事，他是在语言层面在Go运行时的内核里面做自己的调度，所以当CPU给到进程时间片的时候，内核会直接对进程树下面的所有的微线程的[goroutine]进行调度，减少了操作系统层面的上下文切换，非常的轻量级。\n\n### Goroutine原理\n\n简而言之，一个操作系统会对应用户态多个goroutine，而且会使用多个操作系统进线程，而且操作系统线程对于goroutine是 **M：N**的关系。\n\n做一个模型抽象：\n\n- 造作系统线程设为：  M\n- 用户态线程 [ goroutine ] 设为:    G\n- 上下文对象设为：    P\n\n![](/png6.png)\n\n其中G会被M去执行，P相当于执行的中间件，也就是M执行G任务的时候P是执行环境，只是类似于操作系统内核态的上下文，只是足够的轻量级。\n\n### Goroutine调度\n\n![](/png7.png)\n\n当前M执行G任务时，其他的G会进入等待状态，当当前的G被调度完成或者时间片轮询超时，此时的G会被放入队尾，队头任务被调度，依次轮询执行，当然这里面还有一些其他的调度算法。\n\n### 当用户态线程阻塞时如何调度？\n\n由于我们的物理线程会对应执行多个用户态线程(Goroutine)，当我们的某个goroutine进行一个耗时操作的时候，比如：\n\n![](/png8.png)\n\n当当前Mo调度Go进行耗时的文件操作时，如果调度依旧进行，则会出现接下来的所有的被Mo调度的goroutine都会‘卡死’，所以呢，Go在运行时内核为这样的耗时操作新开一个调度，然后单一的去执行耗时操作，其余的依旧轮询使用时间片调度。\n\n### Goroutine池\n\n当我们在进行某些并发操作计算的时候，每次遇到都开启新的goroutine去执行，难免会出现goroutine的暴增，使用不当甚至出现泄漏的情况。通常使用goroutine池来进行任务的调配和线程间通信。\n\n比如一个非常简单的例子，**随机不断生成随机数，然后启动worker池来进行计算每个数的各个位上的数的和并且输出。**\n\n> number: 1234 , result: 1+2+3+4 = 10\n\n开两个抽象类进行封装：\n\n```go\ntype Job struct {\n\tJobId  int\n\tNumber int\n}\n\ntype Result struct {\n\tJob *Job\n\tsum int\n}\n```\n\n一个是表示一个计算任务，一个存储计算结果。\n\n每一个worker都回去做计算任务，并且把计算的结果放入结果队列。\n\n```go\n// 求出每个位上的值的和 如1234 = 1+2+3+4 = 10\nfunc (job *Job) Work(result chan *Result) {\n\n\t//计算\n\tsum := 0\n\tnumber := job.Number\n\n\tfor number != 0 {\n\t\ttemp := number % 10\n\t\tsum += temp\n\t\tnumber /= 10\n\t}\n\n\t//把计算的结果变成对象\n\tr := &Result{\n\t\tJob: job,\n\t\tsum: sum,\n\t}\n\n\t//写入管道\n\tresult <- r\n\n}\n\n```\n\n而每一个Worker负责从任务队列里面取出任务，然后进行计算。\n\n```go\nfunc Worker(jobChan chan *Job, resultChan chan *Result) {\n\n\tfor job := range jobChan {\n\t\tjob.Work(resultChan)\n\t}\n}\n\n```\n\n再封装一个启动器,表示启动多大的worker池。\n\n```go\n//启动worker池\nfunc StartWorkerPool(poolSize int, jobChan chan *Job, resultChan chan *Result) {\n\tfor i := 0; i < poolSize; i++ {\n\t\tgo Worker(jobChan, resultChan)\n\t}\n}\n```\n\n用于产生随机数的接口和输出结果的接口是用来做显示的，这也列出来。\n\n```go\nfunc ProductJobs(jobChan chan *Job) {\n\tjobId := 1\n\tfor {\n\t\tjobId++\n\n\t\tnumber := rand.Int()\n\n\t\tjob := &Job{\n\t\t\tJobId:  jobId,\n\t\t\tNumber: number,\n\t\t}\n\n\t\tjobChan <- job\n\n\t}\n\n}\n\nfunc PrintWorker(resultChan chan *Result) {\n\tfor result := range resultChan {\n\t\tfmt.Printf(\"JobId : %d number: %d  result : %d \\n\", result.Job.JobId, result.Job.Number, result.sum)\n\t}\n}\n\n```\n\n最后只需在main里面进行调用即可。\n\n```go\nfunc main() {\n\n\tjobChan := make(chan *Job, 1024)\n\tresultChan := make(chan *Result, 1024)\n\n\t//启动worker池\n\tStartWorkerPool(512, jobChan, resultChan)\n\n\tgo PrintWorker(resultChan)\n\n\tgo ProductJobs(jobChan)\n\n\tselect {}\n}\n```\n\n结果；\n\n![](/png9.png)\n\n这是个非常简单的例子，但是仔细看会觉得很优雅，这个就是使用goroutine实现像工厂流水线一般的运作方式。\n\n### 线程安全\n\n首先，Go语言在设计理念上已经做到了足够简单，我们无须像C/C++，Java等语言在设计多线程的时候考虑各种线程之间的问题以及多线程管理带来的麻烦。但是，只要有并发的概念，那就避免不了资源冲突的问题。我以前在设计游戏的时候，因为有些游戏的逻辑比较复杂，用到的协程非常多，导致很多的资源在我某个协程取它的时候已经实现被其他协程修改了。\n\n比如说： 我有两个协程，一个是用来计算修改子弹的伤害，一个是用来计算子弹销毁。如果两个协程不自己进行处理的话，很多时候子弹就会突然消失。当然游戏设计并不是说的这么简单，中间还有很多的逻辑。\n\n所以我们需要在两个同时想持有某项资源的线程做一个限定，不能让操作同时发生，出现意料之外的结果。而这样的被多个线程所持有的资源没称作临界资源或临界区。\n\n```go\nx = x+10\n```\n\n这是一个看起来再简单不过的语句，但是要知道在并发的世界里面，什么都没这么简单，我们分析一下，在程序底层实际上是做了三步**原子操作**：\n\n1. 先从内存中取出x的值\n2. CPU进行计算 x+10\n3. 把x+10存储到内存中\n\n为什么这么分析，因为中间的每一步都有可能被别人取先。 所以我们需要加锁而避免出现临界资源在多个线程同时操作下出现问题。\n\n![](/lock.jpg)\n\n### 互斥锁\n\n当对某个资源进行非原子操作的时候，我们对此操作加锁，使得其他的线程对其操作的时候只能等待其锁被释放后才能进入临界区，而多个线程等待的时候，其唤醒策略是随机的，或者看线程的优先级而定。\n\n```go\nvar mutex sync.Mutex   // 在全局区定义互斥锁\n\nmutex.Lock()\ni++\nmutex.Unlock()\n\n```\n\n使用很简单，只需在临界操作前加锁，操作后解除锁即可。\n\n### 读写锁\n\n在我们对临界区资源进行读操作的时候其实是不用加锁的的，加锁反而会降低性能。但是当我们需要读取值的时候却中途被雪入了其他不正确的值，就会出现错误。所以**读写锁**应运而生。\n\n**读锁：**\n\n- 当一个goroutine获得读锁以后，**其他的goroutine获取写锁都会等待。**\n- 当一个goroutine获得读锁以后，**其他的goroutine获得读锁时，都会获得锁。**\n\n**写锁：**\n\n- 当一个goroutine获得写锁以后，**其他的goroutine获取写锁和读锁都会等待,写锁是互斥的**\n\n```go\nvar rwLock sync.RWMutex\n\n//读锁\nrwLock.RLock()\nfmt.Println(\"a = \",a)\nrwlock.RUnlock()\n\n\n//写锁\nrwLock.Lock()\na++\nrwlock.Unlock()\n```\n\n在读多写少的情况下，读写锁的性能比互斥锁高很多。\n\n### 原子操作\n\n为什么要介绍原子操作呢？这个原子操作和上面讲的单步的原子操作是不一样的两件事，这个原子操作是Go语言里面的一种单步操作的函数。由于**加锁代价比较高，比较耗时，需要上下文切换**。所以在Go语言里面，针对基本数据类型可以使用原子操作保证线程安全。原子操作可以在用户态就可以完成，所以性能比互斥锁高。\n\n在使用互斥锁的时候：\n\n```go\nvar mutex sync.Mutex   // 在全局区定义互斥锁\n\nmutex.Lock()\ni++\nmutex.Unlock()\n```\n\n原子操作：\n\n```go\natomic.AddInt32(&x,1)  // 相当于x = x + 1\n```\n\n我对10000个goroutine进行原子操作和互斥锁操作，原子操作的性能是互斥锁的5倍左右，锁着goroutine的数量级越大，性能差异也就越大。\n\n相对应的其他原子操作：\n\n```go\na := atomic.LoadInt32(&x)   \t\t\t\t\t\t//  加载操作.  var a int = x \natomic.StoreInt32(&x,10)   \t\t\t\t\t\t  //  写入. x = 10\nb := atomic.SwapInt32(&x,10)\t\t\t\t\t  //  交换操作\n```\n\n","slug":"Go并发编程初探","published":1,"updated":"2020-02-07T05:32:37.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rj9000czd5baofh0kmt","content":"<h3 id=\"并发与并行\"><a href=\"#并发与并行\" class=\"headerlink\" title=\"并发与并行\"></a>并发与并行</h3><p>并发：同一时段内执行多个操作,如两排公用一台咖啡机，在时间粒度为1h时的情况下，我们可以把它看作是一个人眼可见的并发模型，当然这只是个比喻。</p>\n<p><img src=\"/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png1.png\" alt></p>\n<p>并行：同一时刻执行多个操作，这里就涉及到两个咖啡机同时处理操作。</p>\n<p><img src=\"/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png2.png\" alt></p>\n<p>明白了并发和并行的话，接下来就好说。</p>\n<p><strong>多线程技术</strong></p>\n<ul>\n<li>线程是有操作系统管理的一组程序的执行流，是操作系统能操作的最小单位。简而言之，线程是一个程序运行时[进程]产生的一个小分支，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的<strong>内核线程</strong>和由用户进程自行调度的<strong>用户线程</strong></li>\n<li>在很多的编程语言里面，多线程技术的实现是一个抢占式的模型，每一个属于应用层面的线程都是附属于该应用的一个运行分支，通过cpu来进行调度，但是在操作系统层面，不断的从内核态到应用态的切换会使得CPU的处理消耗得更大，简而言之，直接通过操作系统调度不断切换的线程，因为涉及到当前线程从被挂起到得到时间片恢复会浪费很大的资源。所以在java里面对于多线程的使用都会使用线程池来进行优化，但是这种优化也是有瓶颈的，毕竟只是在运用层面。</li>\n<li>Go语言的<strong>goroutine技术</strong>是类似于<strong>unity的协程</strong>技术，但是与之不相同的事，他是在语言层面在Go运行时的内核里面做自己的调度，所以当CPU给到进程时间片的时候，内核会直接对进程树下面的所有的微线程的[goroutine]进行调度，减少了操作系统层面的上下文切换，非常的轻量级。</li>\n</ul>\n<h3 id=\"Goroutine原理\"><a href=\"#Goroutine原理\" class=\"headerlink\" title=\"Goroutine原理\"></a>Goroutine原理</h3><p>简而言之，一个操作系统会对应用户态多个goroutine，而且会使用多个操作系统进线程，而且操作系统线程对于goroutine是 <strong>M：N</strong>的关系。</p>\n<p>做一个模型抽象：</p>\n<ul>\n<li>造作系统线程设为：  M</li>\n<li>用户态线程 [ goroutine ] 设为:    G</li>\n<li>上下文对象设为：    P</li>\n</ul>\n<p><img src=\"/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png6.png\" alt></p>\n<p>其中G会被M去执行，P相当于执行的中间件，也就是M执行G任务的时候P是执行环境，只是类似于操作系统内核态的上下文，只是足够的轻量级。</p>\n<h3 id=\"Goroutine调度\"><a href=\"#Goroutine调度\" class=\"headerlink\" title=\"Goroutine调度\"></a>Goroutine调度</h3><p><img src=\"/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png7.png\" alt></p>\n<p>当前M执行G任务时，其他的G会进入等待状态，当当前的G被调度完成或者时间片轮询超时，此时的G会被放入队尾，队头任务被调度，依次轮询执行，当然这里面还有一些其他的调度算法。</p>\n<h3 id=\"当用户态线程阻塞时如何调度？\"><a href=\"#当用户态线程阻塞时如何调度？\" class=\"headerlink\" title=\"当用户态线程阻塞时如何调度？\"></a>当用户态线程阻塞时如何调度？</h3><p>由于我们的物理线程会对应执行多个用户态线程(Goroutine)，当我们的某个goroutine进行一个耗时操作的时候，比如：</p>\n<p><img src=\"/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png8.png\" alt></p>\n<p>当当前Mo调度Go进行耗时的文件操作时，如果调度依旧进行，则会出现接下来的所有的被Mo调度的goroutine都会‘卡死’，所以呢，Go在运行时内核为这样的耗时操作新开一个调度，然后单一的去执行耗时操作，其余的依旧轮询使用时间片调度。</p>\n<h3 id=\"Goroutine池\"><a href=\"#Goroutine池\" class=\"headerlink\" title=\"Goroutine池\"></a>Goroutine池</h3><p>当我们在进行某些并发操作计算的时候，每次遇到都开启新的goroutine去执行，难免会出现goroutine的暴增，使用不当甚至出现泄漏的情况。通常使用goroutine池来进行任务的调配和线程间通信。</p>\n<p>比如一个非常简单的例子，<strong>随机不断生成随机数，然后启动worker池来进行计算每个数的各个位上的数的和并且输出。</strong></p>\n<blockquote>\n<p>number: 1234 , result: 1+2+3+4 = 10</p>\n</blockquote>\n<p>开两个抽象类进行封装：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Job <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    JobId  <span class=\"token builtin\">int</span>\n    Number <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> Result <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    Job <span class=\"token operator\">*</span>Job\n    sum <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>一个是表示一个计算任务，一个存储计算结果。</p>\n<p>每一个worker都回去做计算任务，并且把计算的结果放入结果队列。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">// 求出每个位上的值的和 如1234 = 1+2+3+4 = 10</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>job <span class=\"token operator\">*</span>Job<span class=\"token punctuation\">)</span> <span class=\"token function\">Work</span><span class=\"token punctuation\">(</span>result <span class=\"token keyword\">chan</span> <span class=\"token operator\">*</span>Result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//计算</span>\n    sum <span class=\"token operator\">:=</span> <span class=\"token number\">0</span>\n    number <span class=\"token operator\">:=</span> job<span class=\"token punctuation\">.</span>Number\n\n    <span class=\"token keyword\">for</span> number <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        temp <span class=\"token operator\">:=</span> number <span class=\"token operator\">%</span> <span class=\"token number\">10</span>\n        sum <span class=\"token operator\">+=</span> temp\n        number <span class=\"token operator\">/=</span> <span class=\"token number\">10</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//把计算的结果变成对象</span>\n    r <span class=\"token operator\">:=</span> <span class=\"token operator\">&amp;</span>Result<span class=\"token punctuation\">{</span>\n        Job<span class=\"token punctuation\">:</span> job<span class=\"token punctuation\">,</span>\n        sum<span class=\"token punctuation\">:</span> sum<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//写入管道</span>\n    result <span class=\"token operator\">&lt;-</span> r\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>而每一个Worker负责从任务队列里面取出任务，然后进行计算。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">Worker</span><span class=\"token punctuation\">(</span>jobChan <span class=\"token keyword\">chan</span> <span class=\"token operator\">*</span>Job<span class=\"token punctuation\">,</span> resultChan <span class=\"token keyword\">chan</span> <span class=\"token operator\">*</span>Result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">for</span> job <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> jobChan <span class=\"token punctuation\">{</span>\n        job<span class=\"token punctuation\">.</span><span class=\"token function\">Work</span><span class=\"token punctuation\">(</span>resultChan<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>再封装一个启动器,表示启动多大的worker池。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">//启动worker池</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">StartWorkerPool</span><span class=\"token punctuation\">(</span>poolSize <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> jobChan <span class=\"token keyword\">chan</span> <span class=\"token operator\">*</span>Job<span class=\"token punctuation\">,</span> resultChan <span class=\"token keyword\">chan</span> <span class=\"token operator\">*</span>Result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> poolSize<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">go</span> <span class=\"token function\">Worker</span><span class=\"token punctuation\">(</span>jobChan<span class=\"token punctuation\">,</span> resultChan<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>用于产生随机数的接口和输出结果的接口是用来做显示的，这也列出来。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">ProductJobs</span><span class=\"token punctuation\">(</span>jobChan <span class=\"token keyword\">chan</span> <span class=\"token operator\">*</span>Job<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    jobId <span class=\"token operator\">:=</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n        jobId<span class=\"token operator\">++</span>\n\n        number <span class=\"token operator\">:=</span> rand<span class=\"token punctuation\">.</span><span class=\"token function\">Int</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n        job <span class=\"token operator\">:=</span> <span class=\"token operator\">&amp;</span>Job<span class=\"token punctuation\">{</span>\n            JobId<span class=\"token punctuation\">:</span>  jobId<span class=\"token punctuation\">,</span>\n            Number<span class=\"token punctuation\">:</span> number<span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span>\n\n        jobChan <span class=\"token operator\">&lt;-</span> job\n\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">PrintWorker</span><span class=\"token punctuation\">(</span>resultChan <span class=\"token keyword\">chan</span> <span class=\"token operator\">*</span>Result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> result <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> resultChan <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"JobId : %d number: %d  result : %d \\n\"</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">.</span>Job<span class=\"token punctuation\">.</span>JobId<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">.</span>Job<span class=\"token punctuation\">.</span>Number<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">.</span>sum<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>最后只需在main里面进行调用即可。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    jobChan <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token operator\">*</span>Job<span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span>\n    resultChan <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token operator\">*</span>Result<span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//启动worker池</span>\n    <span class=\"token function\">StartWorkerPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">512</span><span class=\"token punctuation\">,</span> jobChan<span class=\"token punctuation\">,</span> resultChan<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">go</span> <span class=\"token function\">PrintWorker</span><span class=\"token punctuation\">(</span>resultChan<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">go</span> <span class=\"token function\">ProductJobs</span><span class=\"token punctuation\">(</span>jobChan<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">select</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>结果；</p>\n<p><img src=\"/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png9.png\" alt></p>\n<p>这是个非常简单的例子，但是仔细看会觉得很优雅，这个就是使用goroutine实现像工厂流水线一般的运作方式。</p>\n<h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><p>首先，Go语言在设计理念上已经做到了足够简单，我们无须像C/C++，Java等语言在设计多线程的时候考虑各种线程之间的问题以及多线程管理带来的麻烦。但是，只要有并发的概念，那就避免不了资源冲突的问题。我以前在设计游戏的时候，因为有些游戏的逻辑比较复杂，用到的协程非常多，导致很多的资源在我某个协程取它的时候已经实现被其他协程修改了。</p>\n<p>比如说： 我有两个协程，一个是用来计算修改子弹的伤害，一个是用来计算子弹销毁。如果两个协程不自己进行处理的话，很多时候子弹就会突然消失。当然游戏设计并不是说的这么简单，中间还有很多的逻辑。</p>\n<p>所以我们需要在两个同时想持有某项资源的线程做一个限定，不能让操作同时发生，出现意料之外的结果。而这样的被多个线程所持有的资源没称作临界资源或临界区。</p>\n<pre class=\" language-go\"><code class=\"language-go\">x <span class=\"token operator\">=</span> x<span class=\"token operator\">+</span><span class=\"token number\">10</span></code></pre>\n<p>这是一个看起来再简单不过的语句，但是要知道在并发的世界里面，什么都没这么简单，我们分析一下，在程序底层实际上是做了三步<strong>原子操作</strong>：</p>\n<ol>\n<li>先从内存中取出x的值</li>\n<li>CPU进行计算 x+10</li>\n<li>把x+10存储到内存中</li>\n</ol>\n<p>为什么这么分析，因为中间的每一步都有可能被别人取先。 所以我们需要加锁而避免出现临界资源在多个线程同时操作下出现问题。</p>\n<p><img src=\"/2020/01/20/go-bing-fa-bian-cheng-chu-tan/lock.jpg\" alt></p>\n<h3 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h3><p>当对某个资源进行非原子操作的时候，我们对此操作加锁，使得其他的线程对其操作的时候只能等待其锁被释放后才能进入临界区，而多个线程等待的时候，其唤醒策略是随机的，或者看线程的优先级而定。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> mutex sync<span class=\"token punctuation\">.</span>Mutex   <span class=\"token comment\" spellcheck=\"true\">// 在全局区定义互斥锁</span>\n\nmutex<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ni<span class=\"token operator\">++</span>\nmutex<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>使用很简单，只需在临界操作前加锁，操作后解除锁即可。</p>\n<h3 id=\"读写锁\"><a href=\"#读写锁\" class=\"headerlink\" title=\"读写锁\"></a>读写锁</h3><p>在我们对临界区资源进行读操作的时候其实是不用加锁的的，加锁反而会降低性能。但是当我们需要读取值的时候却中途被雪入了其他不正确的值，就会出现错误。所以<strong>读写锁</strong>应运而生。</p>\n<p><strong>读锁：</strong></p>\n<ul>\n<li>当一个goroutine获得读锁以后，<strong>其他的goroutine获取写锁都会等待。</strong></li>\n<li>当一个goroutine获得读锁以后，<strong>其他的goroutine获得读锁时，都会获得锁。</strong></li>\n</ul>\n<p><strong>写锁：</strong></p>\n<ul>\n<li>当一个goroutine获得写锁以后，<strong>其他的goroutine获取写锁和读锁都会等待,写锁是互斥的</strong></li>\n</ul>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> rwLock sync<span class=\"token punctuation\">.</span>RWMutex\n\n<span class=\"token comment\" spellcheck=\"true\">//读锁</span>\nrwLock<span class=\"token punctuation\">.</span><span class=\"token function\">RLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a = \"</span><span class=\"token punctuation\">,</span>a<span class=\"token punctuation\">)</span>\nrwlock<span class=\"token punctuation\">.</span><span class=\"token function\">RUnlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">//写锁</span>\nrwLock<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\na<span class=\"token operator\">++</span>\nrwlock<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<p>在读多写少的情况下，读写锁的性能比互斥锁高很多。</p>\n<h3 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h3><p>为什么要介绍原子操作呢？这个原子操作和上面讲的单步的原子操作是不一样的两件事，这个原子操作是Go语言里面的一种单步操作的函数。由于<strong>加锁代价比较高，比较耗时，需要上下文切换</strong>。所以在Go语言里面，针对基本数据类型可以使用原子操作保证线程安全。原子操作可以在用户态就可以完成，所以性能比互斥锁高。</p>\n<p>在使用互斥锁的时候：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> mutex sync<span class=\"token punctuation\">.</span>Mutex   <span class=\"token comment\" spellcheck=\"true\">// 在全局区定义互斥锁</span>\n\nmutex<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ni<span class=\"token operator\">++</span>\nmutex<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<p>原子操作：</p>\n<pre class=\" language-go\"><code class=\"language-go\">atomic<span class=\"token punctuation\">.</span><span class=\"token function\">AddInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 相当于x = x + 1</span></code></pre>\n<p>我对10000个goroutine进行原子操作和互斥锁操作，原子操作的性能是互斥锁的5倍左右，锁着goroutine的数量级越大，性能差异也就越大。</p>\n<p>相对应的其他原子操作：</p>\n<pre class=\" language-go\"><code class=\"language-go\">a <span class=\"token operator\">:=</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">LoadInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">)</span>                           <span class=\"token comment\" spellcheck=\"true\">//  加载操作.  var a int = x </span>\natomic<span class=\"token punctuation\">.</span><span class=\"token function\">StoreInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>                             <span class=\"token comment\" spellcheck=\"true\">//  写入. x = 10</span>\nb <span class=\"token operator\">:=</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">SwapInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>                      <span class=\"token comment\" spellcheck=\"true\">//  交换操作</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<h3 id=\"并发与并行\"><a href=\"#并发与并行\" class=\"headerlink\" title=\"并发与并行\"></a>并发与并行</h3><p>并发：同一时段内执行多个操作,如两排公用一台咖啡机，在时间粒度为1h时的情况下，我们可以把它看作是一个人眼可见的并发模型，当然这只是个比喻。</p>\n<p><img src=\"/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png1.png\" alt></p>\n<p>并行：同一时刻执行多个操作，这里就涉及到两个咖啡机同时处理操作。</p>\n<p><img src=\"/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png2.png\" alt></p>\n<p>明白了并发和并行的话，接下来就好说。</p>\n<p><strong>多线程技术</strong></p>\n<ul>\n<li>线程是有操作系统管理的一组程序的执行流，是操作系统能操作的最小单位。简而言之，线程是一个程序运行时[进程]产生的一个小分支，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的<strong>内核线程</strong>和由用户进程自行调度的<strong>用户线程</strong></li>\n<li>在很多的编程语言里面，多线程技术的实现是一个抢占式的模型，每一个属于应用层面的线程都是附属于该应用的一个运行分支，通过cpu来进行调度，但是在操作系统层面，不断的从内核态到应用态的切换会使得CPU的处理消耗得更大，简而言之，直接通过操作系统调度不断切换的线程，因为涉及到当前线程从被挂起到得到时间片恢复会浪费很大的资源。所以在java里面对于多线程的使用都会使用线程池来进行优化，但是这种优化也是有瓶颈的，毕竟只是在运用层面。</li>\n<li>Go语言的<strong>goroutine技术</strong>是类似于<strong>unity的协程</strong>技术，但是与之不相同的事，他是在语言层面在Go运行时的内核里面做自己的调度，所以当CPU给到进程时间片的时候，内核会直接对进程树下面的所有的微线程的[goroutine]进行调度，减少了操作系统层面的上下文切换，非常的轻量级。</li>\n</ul>\n<h3 id=\"Goroutine原理\"><a href=\"#Goroutine原理\" class=\"headerlink\" title=\"Goroutine原理\"></a>Goroutine原理</h3><p>简而言之，一个操作系统会对应用户态多个goroutine，而且会使用多个操作系统进线程，而且操作系统线程对于goroutine是 <strong>M：N</strong>的关系。</p>\n<p>做一个模型抽象：</p>\n<ul>\n<li>造作系统线程设为：  M</li>\n<li>用户态线程 [ goroutine ] 设为:    G</li>\n<li>上下文对象设为：    P</li>\n</ul>\n<p><img src=\"/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png6.png\" alt></p>\n<p>其中G会被M去执行，P相当于执行的中间件，也就是M执行G任务的时候P是执行环境，只是类似于操作系统内核态的上下文，只是足够的轻量级。</p>\n<h3 id=\"Goroutine调度\"><a href=\"#Goroutine调度\" class=\"headerlink\" title=\"Goroutine调度\"></a>Goroutine调度</h3><p><img src=\"/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png7.png\" alt></p>\n<p>当前M执行G任务时，其他的G会进入等待状态，当当前的G被调度完成或者时间片轮询超时，此时的G会被放入队尾，队头任务被调度，依次轮询执行，当然这里面还有一些其他的调度算法。</p>\n<h3 id=\"当用户态线程阻塞时如何调度？\"><a href=\"#当用户态线程阻塞时如何调度？\" class=\"headerlink\" title=\"当用户态线程阻塞时如何调度？\"></a>当用户态线程阻塞时如何调度？</h3><p>由于我们的物理线程会对应执行多个用户态线程(Goroutine)，当我们的某个goroutine进行一个耗时操作的时候，比如：</p>\n<p><img src=\"/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png8.png\" alt></p>\n<p>当当前Mo调度Go进行耗时的文件操作时，如果调度依旧进行，则会出现接下来的所有的被Mo调度的goroutine都会‘卡死’，所以呢，Go在运行时内核为这样的耗时操作新开一个调度，然后单一的去执行耗时操作，其余的依旧轮询使用时间片调度。</p>\n<h3 id=\"Goroutine池\"><a href=\"#Goroutine池\" class=\"headerlink\" title=\"Goroutine池\"></a>Goroutine池</h3><p>当我们在进行某些并发操作计算的时候，每次遇到都开启新的goroutine去执行，难免会出现goroutine的暴增，使用不当甚至出现泄漏的情况。通常使用goroutine池来进行任务的调配和线程间通信。</p>\n<p>比如一个非常简单的例子，<strong>随机不断生成随机数，然后启动worker池来进行计算每个数的各个位上的数的和并且输出。</strong></p>\n<blockquote>\n<p>number: 1234 , result: 1+2+3+4 = 10</p>\n</blockquote>\n<p>开两个抽象类进行封装：</p>\n<pre><code class=\"go\">type Job struct {\n    JobId  int\n    Number int\n}\n\ntype Result struct {\n    Job *Job\n    sum int\n}</code></pre>\n<p>一个是表示一个计算任务，一个存储计算结果。</p>\n<p>每一个worker都回去做计算任务，并且把计算的结果放入结果队列。</p>\n<pre><code class=\"go\">// 求出每个位上的值的和 如1234 = 1+2+3+4 = 10\nfunc (job *Job) Work(result chan *Result) {\n\n    //计算\n    sum := 0\n    number := job.Number\n\n    for number != 0 {\n        temp := number % 10\n        sum += temp\n        number /= 10\n    }\n\n    //把计算的结果变成对象\n    r := &amp;Result{\n        Job: job,\n        sum: sum,\n    }\n\n    //写入管道\n    result &lt;- r\n\n}\n</code></pre>\n<p>而每一个Worker负责从任务队列里面取出任务，然后进行计算。</p>\n<pre><code class=\"go\">func Worker(jobChan chan *Job, resultChan chan *Result) {\n\n    for job := range jobChan {\n        job.Work(resultChan)\n    }\n}\n</code></pre>\n<p>再封装一个启动器,表示启动多大的worker池。</p>\n<pre><code class=\"go\">//启动worker池\nfunc StartWorkerPool(poolSize int, jobChan chan *Job, resultChan chan *Result) {\n    for i := 0; i &lt; poolSize; i++ {\n        go Worker(jobChan, resultChan)\n    }\n}</code></pre>\n<p>用于产生随机数的接口和输出结果的接口是用来做显示的，这也列出来。</p>\n<pre><code class=\"go\">func ProductJobs(jobChan chan *Job) {\n    jobId := 1\n    for {\n        jobId++\n\n        number := rand.Int()\n\n        job := &amp;Job{\n            JobId:  jobId,\n            Number: number,\n        }\n\n        jobChan &lt;- job\n\n    }\n\n}\n\nfunc PrintWorker(resultChan chan *Result) {\n    for result := range resultChan {\n        fmt.Printf(&quot;JobId : %d number: %d  result : %d \\n&quot;, result.Job.JobId, result.Job.Number, result.sum)\n    }\n}\n</code></pre>\n<p>最后只需在main里面进行调用即可。</p>\n<pre><code class=\"go\">func main() {\n\n    jobChan := make(chan *Job, 1024)\n    resultChan := make(chan *Result, 1024)\n\n    //启动worker池\n    StartWorkerPool(512, jobChan, resultChan)\n\n    go PrintWorker(resultChan)\n\n    go ProductJobs(jobChan)\n\n    select {}\n}</code></pre>\n<p>结果；</p>\n<p><img src=\"/2020/01/20/go-bing-fa-bian-cheng-chu-tan/png9.png\" alt></p>\n<p>这是个非常简单的例子，但是仔细看会觉得很优雅，这个就是使用goroutine实现像工厂流水线一般的运作方式。</p>\n<h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><p>首先，Go语言在设计理念上已经做到了足够简单，我们无须像C/C++，Java等语言在设计多线程的时候考虑各种线程之间的问题以及多线程管理带来的麻烦。但是，只要有并发的概念，那就避免不了资源冲突的问题。我以前在设计游戏的时候，因为有些游戏的逻辑比较复杂，用到的协程非常多，导致很多的资源在我某个协程取它的时候已经实现被其他协程修改了。</p>\n<p>比如说： 我有两个协程，一个是用来计算修改子弹的伤害，一个是用来计算子弹销毁。如果两个协程不自己进行处理的话，很多时候子弹就会突然消失。当然游戏设计并不是说的这么简单，中间还有很多的逻辑。</p>\n<p>所以我们需要在两个同时想持有某项资源的线程做一个限定，不能让操作同时发生，出现意料之外的结果。而这样的被多个线程所持有的资源没称作临界资源或临界区。</p>\n<pre><code class=\"go\">x = x+10</code></pre>\n<p>这是一个看起来再简单不过的语句，但是要知道在并发的世界里面，什么都没这么简单，我们分析一下，在程序底层实际上是做了三步<strong>原子操作</strong>：</p>\n<ol>\n<li>先从内存中取出x的值</li>\n<li>CPU进行计算 x+10</li>\n<li>把x+10存储到内存中</li>\n</ol>\n<p>为什么这么分析，因为中间的每一步都有可能被别人取先。 所以我们需要加锁而避免出现临界资源在多个线程同时操作下出现问题。</p>\n<p><img src=\"/2020/01/20/go-bing-fa-bian-cheng-chu-tan/lock.jpg\" alt></p>\n<h3 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h3><p>当对某个资源进行非原子操作的时候，我们对此操作加锁，使得其他的线程对其操作的时候只能等待其锁被释放后才能进入临界区，而多个线程等待的时候，其唤醒策略是随机的，或者看线程的优先级而定。</p>\n<pre><code class=\"go\">var mutex sync.Mutex   // 在全局区定义互斥锁\n\nmutex.Lock()\ni++\nmutex.Unlock()\n</code></pre>\n<p>使用很简单，只需在临界操作前加锁，操作后解除锁即可。</p>\n<h3 id=\"读写锁\"><a href=\"#读写锁\" class=\"headerlink\" title=\"读写锁\"></a>读写锁</h3><p>在我们对临界区资源进行读操作的时候其实是不用加锁的的，加锁反而会降低性能。但是当我们需要读取值的时候却中途被雪入了其他不正确的值，就会出现错误。所以<strong>读写锁</strong>应运而生。</p>\n<p><strong>读锁：</strong></p>\n<ul>\n<li>当一个goroutine获得读锁以后，<strong>其他的goroutine获取写锁都会等待。</strong></li>\n<li>当一个goroutine获得读锁以后，<strong>其他的goroutine获得读锁时，都会获得锁。</strong></li>\n</ul>\n<p><strong>写锁：</strong></p>\n<ul>\n<li>当一个goroutine获得写锁以后，<strong>其他的goroutine获取写锁和读锁都会等待,写锁是互斥的</strong></li>\n</ul>\n<pre><code class=\"go\">var rwLock sync.RWMutex\n\n//读锁\nrwLock.RLock()\nfmt.Println(&quot;a = &quot;,a)\nrwlock.RUnlock()\n\n\n//写锁\nrwLock.Lock()\na++\nrwlock.Unlock()</code></pre>\n<p>在读多写少的情况下，读写锁的性能比互斥锁高很多。</p>\n<h3 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h3><p>为什么要介绍原子操作呢？这个原子操作和上面讲的单步的原子操作是不一样的两件事，这个原子操作是Go语言里面的一种单步操作的函数。由于<strong>加锁代价比较高，比较耗时，需要上下文切换</strong>。所以在Go语言里面，针对基本数据类型可以使用原子操作保证线程安全。原子操作可以在用户态就可以完成，所以性能比互斥锁高。</p>\n<p>在使用互斥锁的时候：</p>\n<pre><code class=\"go\">var mutex sync.Mutex   // 在全局区定义互斥锁\n\nmutex.Lock()\ni++\nmutex.Unlock()</code></pre>\n<p>原子操作：</p>\n<pre><code class=\"go\">atomic.AddInt32(&amp;x,1)  // 相当于x = x + 1</code></pre>\n<p>我对10000个goroutine进行原子操作和互斥锁操作，原子操作的性能是互斥锁的5倍左右，锁着goroutine的数量级越大，性能差异也就越大。</p>\n<p>相对应的其他原子操作：</p>\n<pre><code class=\"go\">a := atomic.LoadInt32(&amp;x)                           //  加载操作.  var a int = x \natomic.StoreInt32(&amp;x,10)                             //  写入. x = 10\nb := atomic.SwapInt32(&amp;x,10)                      //  交换操作</code></pre>\n"},{"title":"Go语言基础之并发","date":"2020-02-08T02:32:02.000Z","_content":"\n# Go语言中的并发编程\n\n## 并发与并行\n\n并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。\n\n并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。\n\nGo语言的并发通过`goroutine`实现。`goroutine`类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个`goroutine`并发工作。`goroutine`是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。\n\nGo语言还提供`channel`在多个`goroutine`间进行通信。`goroutine`和`channel`是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。\n\n## goroutine\n\n在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？\n\nGo语言中的`goroutine`就是这样一种机制，`goroutine`的概念类似于线程，但 `goroutine`是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。\n\n在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–`goroutine`，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个`goroutine`去执行这个函数就可以了，就是这么简单粗暴。\n\n### 使用goroutine\n\nGo语言中使用`goroutine`非常简单，只需要在调用函数的时候在前面加上`go`关键字，就可以为一个函数创建一个`goroutine`。\n\n一个`goroutine`必定对应一个函数，可以创建多个`goroutine`去执行相同的函数。\n\n### 启动单个goroutine\n\n启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个`go`关键字。\n\n举个例子如下：\n\n```go\nfunc hello() {\n\tfmt.Println(\"Hello Goroutine!\")\n}\nfunc main() {\n\thello()\n\tfmt.Println(\"main goroutine done!\")\n}\n```\n\n这个示例中hello函数和下面的语句是串行的，执行的结果是打印完`Hello Goroutine!`后打印`main goroutine done!`。\n\n接下来我们在调用hello函数前面加上关键字`go`，也就是启动一个goroutine去执行hello这个函数。\n\n```go\nfunc main() {\n\tgo hello() // 启动另外一个goroutine去执行hello函数\n\tfmt.Println(\"main goroutine done!\")\n}\n```\n\n这一次的执行结果只打印了`main goroutine done!`，并没有打印`Hello Goroutine!`。为什么呢？\n\n在程序启动时，Go程序就会为`main()`函数创建一个默认的`goroutine`。\n\n当main()函数返回的时候该`goroutine`就结束了，所有在`main()`函数中启动的`goroutine`会一同结束，`main`函数所在的`goroutine`就像是权利的游戏中的夜王，其他的`goroutine`都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。\n\n所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是`time.Sleep`了。\n\n```go\nfunc main() {\n\tgo hello() // 启动另外一个goroutine去执行hello函数\n\tfmt.Println(\"main goroutine done!\")\n\ttime.Sleep(time.Second)\n}\n```\n\n执行上面的代码你会发现，这一次先打印`main goroutine done!`，然后紧接着打印`Hello Goroutine!`。\n\n首先为什么会先打印`main goroutine done!`是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的`goroutine`是继续执行的。\n\n### 启动多个goroutine\n\n在Go语言中实现并发就是这样简单，我们还可以启动多个`goroutine`。让我们再来一个例子： （这里使用了`sync.WaitGroup`来实现goroutine的同步）\n\n```go\nvar wg sync.WaitGroup\n\nfunc hello(i int) {\n\tdefer wg.Done() // goroutine结束就登记-1\n\tfmt.Println(\"Hello Goroutine!\", i)\n}\nfunc main() {\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1) // 启动一个goroutine就登记+1\n\t\tgo hello(i)\n\t}\n\twg.Wait() // 等待所有登记的goroutine都结束\n}\n```\n\n多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个`goroutine`是并发执行的，而`goroutine`的调度是随机的。\n\n## goroutine与线程\n\n### 可增长的栈\n\nOS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个`goroutine`的栈在其生命周期开始时只有很小的栈（典型情况下2KB），`goroutine`的栈不是固定的，他可以按需增大和缩小，`goroutine`的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的`goroutine`也是可以的。\n\n### goroutine调度\n\n`GPM`是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。\n\n- `G`很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。\n- `P`管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。\n- `M（machine）`是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；\n\nP与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。\n\nP的个数是通过`runtime.GOMAXPROCS`设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。\n\n单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，`goroutine`则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。\n\n[点我了解更多](https://www.cnblogs.com/sunsky303/p/9705727.html)\n\n### GOMAXPROCS\n\nGo运行时的调度器使用`GOMAXPROCS`参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。\n\nGo语言中可以通过`runtime.GOMAXPROCS()`函数设置当前程序并发时占用的CPU逻辑核心数。\n\nGo1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。\n\n我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：\n\n```go\nfunc a() {\n\tfor i := 1; i < 10; i++ {\n\t\tfmt.Println(\"A:\", i)\n\t}\n}\n\nfunc b() {\n\tfor i := 1; i < 10; i++ {\n\t\tfmt.Println(\"B:\", i)\n\t}\n}\n\nfunc main() {\n\truntime.GOMAXPROCS(1)\n\tgo a()\n\tgo b()\n\ttime.Sleep(time.Second)\n}\n```\n\n两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。\n\n```go\nfunc a() {\n\tfor i := 1; i < 10; i++ {\n\t\tfmt.Println(\"A:\", i)\n\t}\n}\n\nfunc b() {\n\tfor i := 1; i < 10; i++ {\n\t\tfmt.Println(\"B:\", i)\n\t}\n}\n\nfunc main() {\n\truntime.GOMAXPROCS(2)\n\tgo a()\n\tgo b()\n\ttime.Sleep(time.Second)\n}\n```\n\nGo语言中的操作系统线程和goroutine的关系：\n\n1. 一个操作系统线程对应用户态多个goroutine。\n2. go程序可以同时使用多个操作系统线程。\n3. goroutine和OS线程是多对多的关系，即m:n。\n\n## channel\n\n单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。\n\n虽然可以使用共享内存进行数据交换，但是共享内存在不同的`goroutine`中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。\n\nGo语言的并发模型是`CSP（Communicating Sequential Processes）`，提倡**通过通信共享内存**而不是**通过共享内存而实现通信**。\n\n如果说`goroutine`是Go程序并发的执行体，`channel`就是它们之间的连接。`channel`是可以让一个`goroutine`发送特定值到另一个`goroutine`的通信机制。\n\nGo 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。\n\n### channel类型\n\n`channel`是一种类型，一种引用类型。声明通道类型的格式如下：\n\n```go\nvar 变量 chan 元素类型\n```\n\n举几个例子：\n\n```go\nvar ch1 chan int   // 声明一个传递整型的通道\nvar ch2 chan bool  // 声明一个传递布尔型的通道\nvar ch3 chan []int // 声明一个传递int切片的通道\n```\n\n### 创建channel\n\n通道是引用类型，通道类型的空值是`nil`。\n\n```go\nvar ch chan int\nfmt.Println(ch) // <nil>\n```\n\n声明的通道后需要使用`make`函数初始化之后才能使用。\n\n创建channel的格式如下：\n\n```go\nmake(chan 元素类型, [缓冲大小])\n```\n\nchannel的缓冲大小是可选的。\n\n举几个例子：\n\n```go\nch4 := make(chan int)\nch5 := make(chan bool)\nch6 := make(chan []int)\n```\n\n### channel操作\n\n通道有发送（send）、接收(receive）和关闭（close）三种操作。\n\n发送和接收都使用`<-`符号。\n\n现在我们先使用以下语句定义一个通道：\n\n```go\nch := make(chan int)\n```\n\n#### 发送\n\n将一个值发送到通道中。\n\n```go\nch <- 10 // 把10发送到ch中\n```\n\n#### 接收\n\n从一个通道中接收值。\n\n```go\nx := <- ch // 从ch中接收值并赋值给变量x\n<-ch       // 从ch中接收值，忽略结果\n```\n\n#### 关闭\n\n我们通过调用内置的`close`函数来关闭通道。\n\n```go\nclose(ch)\n```\n\n关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。\n\n关闭后的通道有以下特点：\n\n1. 对一个关闭的通道再发送值就会导致panic。\n2. 对一个关闭的通道进行接收会一直获取值直到通道为空。\n3. 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。\n4. 关闭一个已经关闭的通道会导致panic。\n\n### 无缓冲的通道\n\n无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：\n\n```go\nfunc main() {\n\tch := make(chan int)\n\tch <- 10\n\tfmt.Println(\"发送成功\")\n}\n```\n\n上面这段代码能够通过编译，但是执行的时候会出现以下错误：\n\n```bash\nfatal error: all goroutines are asleep - deadlock!\n\ngoroutine 1 [chan send]:\nmain.main()\n        .../src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54\n```\n\n为什么会出现`deadlock`错误呢？\n\n因为我们使用`ch := make(chan int)`创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。\n\n上面的代码会阻塞在`ch <- 10`这一行代码形成死锁，那如何解决这个问题呢？\n\n一种方法是启用一个`goroutine`去接收值，例如：\n\n```go\nfunc recv(c chan int) {\n\tret := <-c\n\tfmt.Println(\"接收成功\", ret)\n}\nfunc main() {\n\tch := make(chan int)\n\tgo recv(ch) // 启用goroutine从通道接收值\n\tch <- 10\n\tfmt.Println(\"发送成功\")\n}\n```\n\n无缓冲通道上的发送操作会阻塞，直到另一个`goroutine`在该通道上执行接收操作，这时值才能发送成功，两个`goroutine`将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个`goroutine`在该通道上发送一个值。\n\n使用无缓冲通道进行通信将导致发送和接收的`goroutine`同步化。因此，无缓冲通道也被称为`同步通道`。\n\n### 有缓冲的通道\n\n解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：\n\n```go\nfunc main() {\n\tch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道\n\tch <- 10\n\tfmt.Println(\"发送成功\")\n}\n```\n\n只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。\n\n我们可以使用内置的`len`函数获取通道内元素的数量，使用`cap`函数获取通道的容量，虽然我们很少会这么做。\n\n### for range从通道循环取值\n\n当向通道中发送完数据时，我们可以通过`close`函数来关闭通道。\n\n当通道被关闭时，再往该通道发送值会引发panic，从该通道里接收的值一直都是类型零值。那如何判断一个通道是否被关闭了呢？\n\n我们来看下面这个例子：\n\n```go\n// channel 练习\nfunc main() {\n\tch1 := make(chan int)\n\tch2 := make(chan int)\n\t// 开启goroutine将0~100的数发送到ch1中\n\tgo func() {\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tch1 <- i\n\t\t}\n\t\tclose(ch1)\n\t}()\n\t// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中\n\tgo func() {\n\t\tfor {\n\t\t\ti, ok := <-ch1 // 通道关闭后再取值ok=false\n\t\t\tif !ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tch2 <- i * i\n\t\t}\n\t\tclose(ch2)\n\t}()\n\t// 在主goroutine中从ch2中接收值打印\n\tfor i := range ch2 { // 通道关闭后会退出for range循环\n\t\tfmt.Println(i)\n\t}\n}\n```\n\n从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是`for range`的方式。使用`for range`遍历通道，当通道被关闭的时候就会退出`for range`。\n\n### 单向通道\n\n有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。\n\nGo语言中提供了**单向通道**来处理这种情况。例如，我们把上面的例子改造如下：\n\n```go\nfunc counter(out chan<- int) {\n\tfor i := 0; i < 100; i++ {\n\t\tout <- i\n\t}\n\tclose(out)\n}\n\nfunc squarer(out chan<- int, in <-chan int) {\n\tfor i := range in {\n\t\tout <- i * i\n\t}\n\tclose(out)\n}\nfunc printer(in <-chan int) {\n\tfor i := range in {\n\t\tfmt.Println(i)\n\t}\n}\n\nfunc main() {\n\tch1 := make(chan int)\n\tch2 := make(chan int)\n\tgo counter(ch1)\n\tgo squarer(ch2, ch1)\n\tprinter(ch2)\n}\n```\n\n其中，\n\n- `chan<- int`是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；\n- `<-chan int`是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。\n\n在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。\n\n### 通道总结\n\n`channel`常见的异常总结，如下图：![channel异常总结](/1.png)\n\n关闭已经关闭的`channel`也会引发`panic`。\n\n## worker pool（goroutine池）\n\n在工作中我们通常会使用可以指定启动的goroutine数量–`worker pool`模式，控制`goroutine`的数量，防止`goroutine`泄漏和暴涨。\n\n一个简易的`work pool`示例代码如下：\n\n```go\nfunc worker(id int, jobs <-chan int, results chan<- int) {\n\tfor j := range jobs {\n\t\tfmt.Printf(\"worker:%d start job:%d\\n\", id, j)\n\t\ttime.Sleep(time.Second)\n\t\tfmt.Printf(\"worker:%d end job:%d\\n\", id, j)\n\t\tresults <- j * 2\n\t}\n}\n\n\nfunc main() {\n\tjobs := make(chan int, 100)\n\tresults := make(chan int, 100)\n\t// 开启3个goroutine\n\tfor w := 1; w <= 3; w++ {\n\t\tgo worker(w, jobs, results)\n\t}\n\t// 5个任务\n\tfor j := 1; j <= 5; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\t// 输出结果\n\tfor a := 1; a <= 5; a++ {\n\t\t<-results\n\t}\n}\n```\n\n## select多路复用\n\n在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：\n\n```go\nfor{\n    // 尝试从ch1接收值\n    data, ok := <-ch1\n    // 尝试从ch2接收值\n    data, ok := <-ch2\n    …\n}\n```\n\n这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了`select`关键字，可以同时响应多个通道的操作。\n\n`select`的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。`select`会一直等待，直到某个`case`的通信操作完成时，就会执行`case`分支对应的语句。具体格式如下：\n\n```go\nselect{\n    case <-ch1:\n        ...\n    case data := <-ch2:\n        ...\n    case ch3<-data:\n        ...\n    default:\n        默认操作\n}\n```\n\n举个小例子来演示下`select`的使用：\n\n```go\nfunc main() {\n\tch := make(chan int, 1)\n\tfor i := 0; i < 10; i++ {\n\t\tselect {\n\t\tcase x := <-ch:\n\t\t\tfmt.Println(x)\n\t\tcase ch <- i:\n\t\t}\n\t}\n}\n```\n\n使用`select`语句能提高代码的可读性。\n\n- 可处理一个或多个channel的发送/接收操作。\n- 如果多个`case`同时满足，`select`会随机选择一个。\n- 对于没有`case`的`select{}`会一直等待，可用于阻塞main函数。\n\n## 并发安全和锁\n\n有时候在Go代码中可能会存在多个`goroutine`同时操作一个资源（临界区），这种情况会发生`竞态问题`（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。\n\n举个例子：\n\n```go\nvar x int64\nvar wg sync.WaitGroup\n\nfunc add() {\n\tfor i := 0; i < 5000; i++ {\n\t\tx = x + 1\n\t}\n\twg.Done()\n}\nfunc main() {\n\twg.Add(2)\n\tgo add()\n\tgo add()\n\twg.Wait()\n\tfmt.Println(x)\n}\n```\n\n上面的代码中我们开启了两个`goroutine`去累加变量x的值，这两个`goroutine`在访问和修改`x`变量的时候就会存在数据竞争，导致最后的结果与期待的不符。\n\n### 互斥锁\n\n互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个`goroutine`可以访问共享资源。Go语言中使用`sync`包的`Mutex`类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：\n\n```go\nvar x int64\nvar wg sync.WaitGroup\nvar lock sync.Mutex\n\nfunc add() {\n\tfor i := 0; i < 5000; i++ {\n\t\tlock.Lock() // 加锁\n\t\tx = x + 1\n\t\tlock.Unlock() // 解锁\n\t}\n\twg.Done()\n}\nfunc main() {\n\twg.Add(2)\n\tgo add()\n\tgo add()\n\twg.Wait()\n\tfmt.Println(x)\n}\n```\n\n使用互斥锁能够保证同一时间有且只有一个`goroutine`进入临界区，其他的`goroutine`则在等待锁；当互斥锁释放后，等待的`goroutine`才可以获取锁进入临界区，多个`goroutine`同时等待一个锁时，唤醒的策略是随机的。\n\n### 读写互斥锁\n\n互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用`sync`包中的`RWMutex`类型。\n\n读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的`goroutine`如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个`goroutine`获取写锁之后，其他的`goroutine`无论是获取读锁还是写锁都会等待。\n\n读写锁示例：\n\n```go\nvar (\n\tx      int64\n\twg     sync.WaitGroup\n\tlock   sync.Mutex\n\trwlock sync.RWMutex\n)\n\nfunc write() {\n\t// lock.Lock()   // 加互斥锁\n\trwlock.Lock() // 加写锁\n\tx = x + 1\n\ttime.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒\n\trwlock.Unlock()                   // 解写锁\n\t// lock.Unlock()                     // 解互斥锁\n\twg.Done()\n}\n\nfunc read() {\n\t// lock.Lock()                  // 加互斥锁\n\trwlock.RLock()               // 加读锁\n\ttime.Sleep(time.Millisecond) // 假设读操作耗时1毫秒\n\trwlock.RUnlock()             // 解读锁\n\t// lock.Unlock()                // 解互斥锁\n\twg.Done()\n}\n\nfunc main() {\n\tstart := time.Now()\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo write()\n\t}\n\n\tfor i := 0; i < 1000; i++ {\n\t\twg.Add(1)\n\t\tgo read()\n\t}\n\n\twg.Wait()\n\tend := time.Now()\n\tfmt.Println(end.Sub(start))\n}\n```\n\n需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。\n\n### sync.WaitGroup\n\n在代码中生硬的使用`time.Sleep`肯定是不合适的，Go语言中可以使用`sync.WaitGroup`来实现并发任务的同步。`sync.WaitGroup`有以下几个方法：\n\n|             方法名              |        功能         |\n| :-----------------------------: | :-----------------: |\n| (wg * WaitGroup) Add(delta int) |    计数器+delta     |\n|     (wg *WaitGroup) Done()      |      计数器-1       |\n|     (wg *WaitGroup) Wait()      | 阻塞直到计数器变为0 |\n\n`sync.WaitGroup`内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。\n\n我们利用`sync.WaitGroup`将上面的代码优化一下：\n\n```go\nvar wg sync.WaitGroup\n\nfunc hello() {\n\tdefer wg.Done()\n\tfmt.Println(\"Hello Goroutine!\")\n}\nfunc main() {\n\twg.Add(1)\n\tgo hello() // 启动另外一个goroutine去执行hello函数\n\tfmt.Println(\"main goroutine done!\")\n\twg.Wait()\n}\n```\n\n需要注意`sync.WaitGroup`是一个结构体，传递的时候要传递指针。\n\n### sync.Once\n\n说在前面的话：这是一个进阶知识点。\n\n在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。\n\nGo语言中的`sync`包中提供了一个针对只执行一次场景的解决方案–`sync.Once`。\n\n`sync.Once`只有一个`Do`方法，其签名如下：\n\n```go\nfunc (o *Once) Do(f func()) {}\n```\n\n*备注：如果要执行的函数`f`需要传递参数就需要搭配闭包来使用。*\n\n#### 加载配置文件示例\n\n延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：\n\n```go\nvar icons map[string]image.Image\n\nfunc loadIcons() {\n\ticons = map[string]image.Image{\n\t\t\"left\":  loadIcon(\"left.png\"),\n\t\t\"up\":    loadIcon(\"up.png\"),\n\t\t\"right\": loadIcon(\"right.png\"),\n\t\t\"down\":  loadIcon(\"down.png\"),\n\t}\n}\n\n// Icon 被多个goroutine调用时不是并发安全的\nfunc Icon(name string) image.Image {\n\tif icons == nil {\n\t\tloadIcons()\n\t}\n\treturn icons[name]\n}\n```\n\n多个`goroutine`并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个`goroutine`都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：\n\n```go\nfunc loadIcons() {\n\ticons = make(map[string]image.Image)\n\ticons[\"left\"] = loadIcon(\"left.png\")\n\ticons[\"up\"] = loadIcon(\"up.png\")\n\ticons[\"right\"] = loadIcon(\"right.png\")\n\ticons[\"down\"] = loadIcon(\"down.png\")\n}\n```\n\n在这种情况下就会出现即使判断了`icons`不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化`icons`的时候不会被其他的`goroutine`操作，但是这样做又会引发性能问题。\n\n使用`sync.Once`改造的示例代码如下：\n\n```go\nvar icons map[string]image.Image\n\nvar loadIconsOnce sync.Once\n\nfunc loadIcons() {\n\ticons = map[string]image.Image{\n\t\t\"left\":  loadIcon(\"left.png\"),\n\t\t\"up\":    loadIcon(\"up.png\"),\n\t\t\"right\": loadIcon(\"right.png\"),\n\t\t\"down\":  loadIcon(\"down.png\"),\n\t}\n}\n\n// Icon 是并发安全的\nfunc Icon(name string) image.Image {\n\tloadIconsOnce.Do(loadIcons)\n\treturn icons[name]\n}\n```\n\n#### 并发安全的单例模式\n\n下面是借助`sync.Once`实现的并发安全的单例模式：\n\n```go\npackage singleton\n\nimport (\n    \"sync\"\n)\n\ntype singleton struct {}\n\nvar instance *singleton\nvar once sync.Once\n\nfunc GetInstance() *singleton {\n    once.Do(func() {\n        instance = &singleton{}\n    })\n    return instance\n}\n```\n\n`sync.Once`其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。\n\n### sync.Map\n\nGo语言中内置的map不是并发安全的。请看下面的示例：\n\n```go\nvar m = make(map[string]int)\n\nfunc get(key string) int {\n\treturn m[key]\n}\n\nfunc set(key string, value int) {\n\tm[key] = value\n}\n\nfunc main() {\n\twg := sync.WaitGroup{}\n\tfor i := 0; i < 20; i++ {\n\t\twg.Add(1)\n\t\tgo func(n int) {\n\t\t\tkey := strconv.Itoa(n)\n\t\t\tset(key, n)\n\t\t\tfmt.Printf(\"k=:%v,v:=%v\\n\", key, get(key))\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\twg.Wait()\n}\n```\n\n上面的代码开启少量几个`goroutine`的时候可能没什么问题，当并发多了之后执行上面的代码就会报`fatal error: concurrent map writes`错误。\n\n像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的`sync`包中提供了一个开箱即用的并发安全版map–`sync.Map`。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时`sync.Map`内置了诸如`Store`、`Load`、`LoadOrStore`、`Delete`、`Range`等操作方法。\n\n```go\nvar m = sync.Map{}\n\nfunc main() {\n\twg := sync.WaitGroup{}\n\tfor i := 0; i < 20; i++ {\n\t\twg.Add(1)\n\t\tgo func(n int) {\n\t\t\tkey := strconv.Itoa(n)\n\t\t\tm.Store(key, n)\n\t\t\tvalue, _ := m.Load(key)\n\t\t\tfmt.Printf(\"k=:%v,v:=%v\\n\", key, value)\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\twg.Wait()\n}\n```\n\n## 原子操作\n\n代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库`sync/atomic`提供。\n\n### atomic包\n\n|                             方法                             |      解释      |\n| :----------------------------------------------------------: | :------------: |\n| func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer) |    读取操作    |\n| func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer) |    写入操作    |\n| func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr) |    修改操作    |\n| func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer) |    交换操作    |\n| func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool) | 比较并交换操作 |\n\n### 示例\n\n我们填写一个示例来比较下互斥锁和原子操作的性能。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype Counter interface {\n\tInc()\n\tLoad() int64\n}\n\n// 普通版\ntype CommonCounter struct {\n\tcounter int64\n}\n\nfunc (c CommonCounter) Inc() {\n\tc.counter++\n}\n\nfunc (c CommonCounter) Load() int64 {\n\treturn c.counter\n}\n\n// 互斥锁版\ntype MutexCounter struct {\n\tcounter int64\n\tlock    sync.Mutex\n}\n\nfunc (m *MutexCounter) Inc() {\n\tm.lock.Lock()\n\tdefer m.lock.Unlock()\n\tm.counter++\n}\n\nfunc (m *MutexCounter) Load() int64 {\n\tm.lock.Lock()\n\tdefer m.lock.Unlock()\n\treturn m.counter\n}\n\n// 原子操作版\ntype AtomicCounter struct {\n\tcounter int64\n}\n\nfunc (a *AtomicCounter) Inc() {\n\tatomic.AddInt64(&a.counter, 1)\n}\n\nfunc (a *AtomicCounter) Load() int64 {\n\treturn atomic.LoadInt64(&a.counter)\n}\n\nfunc test(c Counter) {\n\tvar wg sync.WaitGroup\n\tstart := time.Now()\n\tfor i := 0; i < 1000; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tc.Inc()\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n\tend := time.Now()\n\tfmt.Println(c.Load(), end.Sub(start))\n}\n\nfunc main() {\n\tc1 := CommonCounter{} // 非并发安全\n\ttest(c1)\n\tc2 := MutexCounter{} // 使用互斥锁实现并发安全\n\ttest(&c2)\n\tc3 := AtomicCounter{} // 并发安全且比互斥锁效率更高\n\ttest(&c3)\n}\n```\n\n`atomic`包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。","source":"_posts/Go语言基础之并发.md","raw":"---\ntitle: Go语言基础之并发\ndate: 2020-02-08 10:32:02\ntags: [Go,服务器编程,并发]\ncategories: Go栈\n---\n\n# Go语言中的并发编程\n\n## 并发与并行\n\n并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。\n\n并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。\n\nGo语言的并发通过`goroutine`实现。`goroutine`类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个`goroutine`并发工作。`goroutine`是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。\n\nGo语言还提供`channel`在多个`goroutine`间进行通信。`goroutine`和`channel`是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。\n\n## goroutine\n\n在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？\n\nGo语言中的`goroutine`就是这样一种机制，`goroutine`的概念类似于线程，但 `goroutine`是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。\n\n在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–`goroutine`，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个`goroutine`去执行这个函数就可以了，就是这么简单粗暴。\n\n### 使用goroutine\n\nGo语言中使用`goroutine`非常简单，只需要在调用函数的时候在前面加上`go`关键字，就可以为一个函数创建一个`goroutine`。\n\n一个`goroutine`必定对应一个函数，可以创建多个`goroutine`去执行相同的函数。\n\n### 启动单个goroutine\n\n启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个`go`关键字。\n\n举个例子如下：\n\n```go\nfunc hello() {\n\tfmt.Println(\"Hello Goroutine!\")\n}\nfunc main() {\n\thello()\n\tfmt.Println(\"main goroutine done!\")\n}\n```\n\n这个示例中hello函数和下面的语句是串行的，执行的结果是打印完`Hello Goroutine!`后打印`main goroutine done!`。\n\n接下来我们在调用hello函数前面加上关键字`go`，也就是启动一个goroutine去执行hello这个函数。\n\n```go\nfunc main() {\n\tgo hello() // 启动另外一个goroutine去执行hello函数\n\tfmt.Println(\"main goroutine done!\")\n}\n```\n\n这一次的执行结果只打印了`main goroutine done!`，并没有打印`Hello Goroutine!`。为什么呢？\n\n在程序启动时，Go程序就会为`main()`函数创建一个默认的`goroutine`。\n\n当main()函数返回的时候该`goroutine`就结束了，所有在`main()`函数中启动的`goroutine`会一同结束，`main`函数所在的`goroutine`就像是权利的游戏中的夜王，其他的`goroutine`都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。\n\n所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是`time.Sleep`了。\n\n```go\nfunc main() {\n\tgo hello() // 启动另外一个goroutine去执行hello函数\n\tfmt.Println(\"main goroutine done!\")\n\ttime.Sleep(time.Second)\n}\n```\n\n执行上面的代码你会发现，这一次先打印`main goroutine done!`，然后紧接着打印`Hello Goroutine!`。\n\n首先为什么会先打印`main goroutine done!`是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的`goroutine`是继续执行的。\n\n### 启动多个goroutine\n\n在Go语言中实现并发就是这样简单，我们还可以启动多个`goroutine`。让我们再来一个例子： （这里使用了`sync.WaitGroup`来实现goroutine的同步）\n\n```go\nvar wg sync.WaitGroup\n\nfunc hello(i int) {\n\tdefer wg.Done() // goroutine结束就登记-1\n\tfmt.Println(\"Hello Goroutine!\", i)\n}\nfunc main() {\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1) // 启动一个goroutine就登记+1\n\t\tgo hello(i)\n\t}\n\twg.Wait() // 等待所有登记的goroutine都结束\n}\n```\n\n多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个`goroutine`是并发执行的，而`goroutine`的调度是随机的。\n\n## goroutine与线程\n\n### 可增长的栈\n\nOS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个`goroutine`的栈在其生命周期开始时只有很小的栈（典型情况下2KB），`goroutine`的栈不是固定的，他可以按需增大和缩小，`goroutine`的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的`goroutine`也是可以的。\n\n### goroutine调度\n\n`GPM`是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。\n\n- `G`很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。\n- `P`管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。\n- `M（machine）`是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；\n\nP与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。\n\nP的个数是通过`runtime.GOMAXPROCS`设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。\n\n单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，`goroutine`则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。\n\n[点我了解更多](https://www.cnblogs.com/sunsky303/p/9705727.html)\n\n### GOMAXPROCS\n\nGo运行时的调度器使用`GOMAXPROCS`参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。\n\nGo语言中可以通过`runtime.GOMAXPROCS()`函数设置当前程序并发时占用的CPU逻辑核心数。\n\nGo1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。\n\n我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：\n\n```go\nfunc a() {\n\tfor i := 1; i < 10; i++ {\n\t\tfmt.Println(\"A:\", i)\n\t}\n}\n\nfunc b() {\n\tfor i := 1; i < 10; i++ {\n\t\tfmt.Println(\"B:\", i)\n\t}\n}\n\nfunc main() {\n\truntime.GOMAXPROCS(1)\n\tgo a()\n\tgo b()\n\ttime.Sleep(time.Second)\n}\n```\n\n两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。\n\n```go\nfunc a() {\n\tfor i := 1; i < 10; i++ {\n\t\tfmt.Println(\"A:\", i)\n\t}\n}\n\nfunc b() {\n\tfor i := 1; i < 10; i++ {\n\t\tfmt.Println(\"B:\", i)\n\t}\n}\n\nfunc main() {\n\truntime.GOMAXPROCS(2)\n\tgo a()\n\tgo b()\n\ttime.Sleep(time.Second)\n}\n```\n\nGo语言中的操作系统线程和goroutine的关系：\n\n1. 一个操作系统线程对应用户态多个goroutine。\n2. go程序可以同时使用多个操作系统线程。\n3. goroutine和OS线程是多对多的关系，即m:n。\n\n## channel\n\n单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。\n\n虽然可以使用共享内存进行数据交换，但是共享内存在不同的`goroutine`中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。\n\nGo语言的并发模型是`CSP（Communicating Sequential Processes）`，提倡**通过通信共享内存**而不是**通过共享内存而实现通信**。\n\n如果说`goroutine`是Go程序并发的执行体，`channel`就是它们之间的连接。`channel`是可以让一个`goroutine`发送特定值到另一个`goroutine`的通信机制。\n\nGo 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。\n\n### channel类型\n\n`channel`是一种类型，一种引用类型。声明通道类型的格式如下：\n\n```go\nvar 变量 chan 元素类型\n```\n\n举几个例子：\n\n```go\nvar ch1 chan int   // 声明一个传递整型的通道\nvar ch2 chan bool  // 声明一个传递布尔型的通道\nvar ch3 chan []int // 声明一个传递int切片的通道\n```\n\n### 创建channel\n\n通道是引用类型，通道类型的空值是`nil`。\n\n```go\nvar ch chan int\nfmt.Println(ch) // <nil>\n```\n\n声明的通道后需要使用`make`函数初始化之后才能使用。\n\n创建channel的格式如下：\n\n```go\nmake(chan 元素类型, [缓冲大小])\n```\n\nchannel的缓冲大小是可选的。\n\n举几个例子：\n\n```go\nch4 := make(chan int)\nch5 := make(chan bool)\nch6 := make(chan []int)\n```\n\n### channel操作\n\n通道有发送（send）、接收(receive）和关闭（close）三种操作。\n\n发送和接收都使用`<-`符号。\n\n现在我们先使用以下语句定义一个通道：\n\n```go\nch := make(chan int)\n```\n\n#### 发送\n\n将一个值发送到通道中。\n\n```go\nch <- 10 // 把10发送到ch中\n```\n\n#### 接收\n\n从一个通道中接收值。\n\n```go\nx := <- ch // 从ch中接收值并赋值给变量x\n<-ch       // 从ch中接收值，忽略结果\n```\n\n#### 关闭\n\n我们通过调用内置的`close`函数来关闭通道。\n\n```go\nclose(ch)\n```\n\n关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。\n\n关闭后的通道有以下特点：\n\n1. 对一个关闭的通道再发送值就会导致panic。\n2. 对一个关闭的通道进行接收会一直获取值直到通道为空。\n3. 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。\n4. 关闭一个已经关闭的通道会导致panic。\n\n### 无缓冲的通道\n\n无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：\n\n```go\nfunc main() {\n\tch := make(chan int)\n\tch <- 10\n\tfmt.Println(\"发送成功\")\n}\n```\n\n上面这段代码能够通过编译，但是执行的时候会出现以下错误：\n\n```bash\nfatal error: all goroutines are asleep - deadlock!\n\ngoroutine 1 [chan send]:\nmain.main()\n        .../src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54\n```\n\n为什么会出现`deadlock`错误呢？\n\n因为我们使用`ch := make(chan int)`创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。\n\n上面的代码会阻塞在`ch <- 10`这一行代码形成死锁，那如何解决这个问题呢？\n\n一种方法是启用一个`goroutine`去接收值，例如：\n\n```go\nfunc recv(c chan int) {\n\tret := <-c\n\tfmt.Println(\"接收成功\", ret)\n}\nfunc main() {\n\tch := make(chan int)\n\tgo recv(ch) // 启用goroutine从通道接收值\n\tch <- 10\n\tfmt.Println(\"发送成功\")\n}\n```\n\n无缓冲通道上的发送操作会阻塞，直到另一个`goroutine`在该通道上执行接收操作，这时值才能发送成功，两个`goroutine`将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个`goroutine`在该通道上发送一个值。\n\n使用无缓冲通道进行通信将导致发送和接收的`goroutine`同步化。因此，无缓冲通道也被称为`同步通道`。\n\n### 有缓冲的通道\n\n解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：\n\n```go\nfunc main() {\n\tch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道\n\tch <- 10\n\tfmt.Println(\"发送成功\")\n}\n```\n\n只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。\n\n我们可以使用内置的`len`函数获取通道内元素的数量，使用`cap`函数获取通道的容量，虽然我们很少会这么做。\n\n### for range从通道循环取值\n\n当向通道中发送完数据时，我们可以通过`close`函数来关闭通道。\n\n当通道被关闭时，再往该通道发送值会引发panic，从该通道里接收的值一直都是类型零值。那如何判断一个通道是否被关闭了呢？\n\n我们来看下面这个例子：\n\n```go\n// channel 练习\nfunc main() {\n\tch1 := make(chan int)\n\tch2 := make(chan int)\n\t// 开启goroutine将0~100的数发送到ch1中\n\tgo func() {\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tch1 <- i\n\t\t}\n\t\tclose(ch1)\n\t}()\n\t// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中\n\tgo func() {\n\t\tfor {\n\t\t\ti, ok := <-ch1 // 通道关闭后再取值ok=false\n\t\t\tif !ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tch2 <- i * i\n\t\t}\n\t\tclose(ch2)\n\t}()\n\t// 在主goroutine中从ch2中接收值打印\n\tfor i := range ch2 { // 通道关闭后会退出for range循环\n\t\tfmt.Println(i)\n\t}\n}\n```\n\n从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是`for range`的方式。使用`for range`遍历通道，当通道被关闭的时候就会退出`for range`。\n\n### 单向通道\n\n有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。\n\nGo语言中提供了**单向通道**来处理这种情况。例如，我们把上面的例子改造如下：\n\n```go\nfunc counter(out chan<- int) {\n\tfor i := 0; i < 100; i++ {\n\t\tout <- i\n\t}\n\tclose(out)\n}\n\nfunc squarer(out chan<- int, in <-chan int) {\n\tfor i := range in {\n\t\tout <- i * i\n\t}\n\tclose(out)\n}\nfunc printer(in <-chan int) {\n\tfor i := range in {\n\t\tfmt.Println(i)\n\t}\n}\n\nfunc main() {\n\tch1 := make(chan int)\n\tch2 := make(chan int)\n\tgo counter(ch1)\n\tgo squarer(ch2, ch1)\n\tprinter(ch2)\n}\n```\n\n其中，\n\n- `chan<- int`是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；\n- `<-chan int`是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。\n\n在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。\n\n### 通道总结\n\n`channel`常见的异常总结，如下图：![channel异常总结](/1.png)\n\n关闭已经关闭的`channel`也会引发`panic`。\n\n## worker pool（goroutine池）\n\n在工作中我们通常会使用可以指定启动的goroutine数量–`worker pool`模式，控制`goroutine`的数量，防止`goroutine`泄漏和暴涨。\n\n一个简易的`work pool`示例代码如下：\n\n```go\nfunc worker(id int, jobs <-chan int, results chan<- int) {\n\tfor j := range jobs {\n\t\tfmt.Printf(\"worker:%d start job:%d\\n\", id, j)\n\t\ttime.Sleep(time.Second)\n\t\tfmt.Printf(\"worker:%d end job:%d\\n\", id, j)\n\t\tresults <- j * 2\n\t}\n}\n\n\nfunc main() {\n\tjobs := make(chan int, 100)\n\tresults := make(chan int, 100)\n\t// 开启3个goroutine\n\tfor w := 1; w <= 3; w++ {\n\t\tgo worker(w, jobs, results)\n\t}\n\t// 5个任务\n\tfor j := 1; j <= 5; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\t// 输出结果\n\tfor a := 1; a <= 5; a++ {\n\t\t<-results\n\t}\n}\n```\n\n## select多路复用\n\n在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：\n\n```go\nfor{\n    // 尝试从ch1接收值\n    data, ok := <-ch1\n    // 尝试从ch2接收值\n    data, ok := <-ch2\n    …\n}\n```\n\n这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了`select`关键字，可以同时响应多个通道的操作。\n\n`select`的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。`select`会一直等待，直到某个`case`的通信操作完成时，就会执行`case`分支对应的语句。具体格式如下：\n\n```go\nselect{\n    case <-ch1:\n        ...\n    case data := <-ch2:\n        ...\n    case ch3<-data:\n        ...\n    default:\n        默认操作\n}\n```\n\n举个小例子来演示下`select`的使用：\n\n```go\nfunc main() {\n\tch := make(chan int, 1)\n\tfor i := 0; i < 10; i++ {\n\t\tselect {\n\t\tcase x := <-ch:\n\t\t\tfmt.Println(x)\n\t\tcase ch <- i:\n\t\t}\n\t}\n}\n```\n\n使用`select`语句能提高代码的可读性。\n\n- 可处理一个或多个channel的发送/接收操作。\n- 如果多个`case`同时满足，`select`会随机选择一个。\n- 对于没有`case`的`select{}`会一直等待，可用于阻塞main函数。\n\n## 并发安全和锁\n\n有时候在Go代码中可能会存在多个`goroutine`同时操作一个资源（临界区），这种情况会发生`竞态问题`（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。\n\n举个例子：\n\n```go\nvar x int64\nvar wg sync.WaitGroup\n\nfunc add() {\n\tfor i := 0; i < 5000; i++ {\n\t\tx = x + 1\n\t}\n\twg.Done()\n}\nfunc main() {\n\twg.Add(2)\n\tgo add()\n\tgo add()\n\twg.Wait()\n\tfmt.Println(x)\n}\n```\n\n上面的代码中我们开启了两个`goroutine`去累加变量x的值，这两个`goroutine`在访问和修改`x`变量的时候就会存在数据竞争，导致最后的结果与期待的不符。\n\n### 互斥锁\n\n互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个`goroutine`可以访问共享资源。Go语言中使用`sync`包的`Mutex`类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：\n\n```go\nvar x int64\nvar wg sync.WaitGroup\nvar lock sync.Mutex\n\nfunc add() {\n\tfor i := 0; i < 5000; i++ {\n\t\tlock.Lock() // 加锁\n\t\tx = x + 1\n\t\tlock.Unlock() // 解锁\n\t}\n\twg.Done()\n}\nfunc main() {\n\twg.Add(2)\n\tgo add()\n\tgo add()\n\twg.Wait()\n\tfmt.Println(x)\n}\n```\n\n使用互斥锁能够保证同一时间有且只有一个`goroutine`进入临界区，其他的`goroutine`则在等待锁；当互斥锁释放后，等待的`goroutine`才可以获取锁进入临界区，多个`goroutine`同时等待一个锁时，唤醒的策略是随机的。\n\n### 读写互斥锁\n\n互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用`sync`包中的`RWMutex`类型。\n\n读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的`goroutine`如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个`goroutine`获取写锁之后，其他的`goroutine`无论是获取读锁还是写锁都会等待。\n\n读写锁示例：\n\n```go\nvar (\n\tx      int64\n\twg     sync.WaitGroup\n\tlock   sync.Mutex\n\trwlock sync.RWMutex\n)\n\nfunc write() {\n\t// lock.Lock()   // 加互斥锁\n\trwlock.Lock() // 加写锁\n\tx = x + 1\n\ttime.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒\n\trwlock.Unlock()                   // 解写锁\n\t// lock.Unlock()                     // 解互斥锁\n\twg.Done()\n}\n\nfunc read() {\n\t// lock.Lock()                  // 加互斥锁\n\trwlock.RLock()               // 加读锁\n\ttime.Sleep(time.Millisecond) // 假设读操作耗时1毫秒\n\trwlock.RUnlock()             // 解读锁\n\t// lock.Unlock()                // 解互斥锁\n\twg.Done()\n}\n\nfunc main() {\n\tstart := time.Now()\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo write()\n\t}\n\n\tfor i := 0; i < 1000; i++ {\n\t\twg.Add(1)\n\t\tgo read()\n\t}\n\n\twg.Wait()\n\tend := time.Now()\n\tfmt.Println(end.Sub(start))\n}\n```\n\n需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。\n\n### sync.WaitGroup\n\n在代码中生硬的使用`time.Sleep`肯定是不合适的，Go语言中可以使用`sync.WaitGroup`来实现并发任务的同步。`sync.WaitGroup`有以下几个方法：\n\n|             方法名              |        功能         |\n| :-----------------------------: | :-----------------: |\n| (wg * WaitGroup) Add(delta int) |    计数器+delta     |\n|     (wg *WaitGroup) Done()      |      计数器-1       |\n|     (wg *WaitGroup) Wait()      | 阻塞直到计数器变为0 |\n\n`sync.WaitGroup`内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。\n\n我们利用`sync.WaitGroup`将上面的代码优化一下：\n\n```go\nvar wg sync.WaitGroup\n\nfunc hello() {\n\tdefer wg.Done()\n\tfmt.Println(\"Hello Goroutine!\")\n}\nfunc main() {\n\twg.Add(1)\n\tgo hello() // 启动另外一个goroutine去执行hello函数\n\tfmt.Println(\"main goroutine done!\")\n\twg.Wait()\n}\n```\n\n需要注意`sync.WaitGroup`是一个结构体，传递的时候要传递指针。\n\n### sync.Once\n\n说在前面的话：这是一个进阶知识点。\n\n在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。\n\nGo语言中的`sync`包中提供了一个针对只执行一次场景的解决方案–`sync.Once`。\n\n`sync.Once`只有一个`Do`方法，其签名如下：\n\n```go\nfunc (o *Once) Do(f func()) {}\n```\n\n*备注：如果要执行的函数`f`需要传递参数就需要搭配闭包来使用。*\n\n#### 加载配置文件示例\n\n延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：\n\n```go\nvar icons map[string]image.Image\n\nfunc loadIcons() {\n\ticons = map[string]image.Image{\n\t\t\"left\":  loadIcon(\"left.png\"),\n\t\t\"up\":    loadIcon(\"up.png\"),\n\t\t\"right\": loadIcon(\"right.png\"),\n\t\t\"down\":  loadIcon(\"down.png\"),\n\t}\n}\n\n// Icon 被多个goroutine调用时不是并发安全的\nfunc Icon(name string) image.Image {\n\tif icons == nil {\n\t\tloadIcons()\n\t}\n\treturn icons[name]\n}\n```\n\n多个`goroutine`并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个`goroutine`都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：\n\n```go\nfunc loadIcons() {\n\ticons = make(map[string]image.Image)\n\ticons[\"left\"] = loadIcon(\"left.png\")\n\ticons[\"up\"] = loadIcon(\"up.png\")\n\ticons[\"right\"] = loadIcon(\"right.png\")\n\ticons[\"down\"] = loadIcon(\"down.png\")\n}\n```\n\n在这种情况下就会出现即使判断了`icons`不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化`icons`的时候不会被其他的`goroutine`操作，但是这样做又会引发性能问题。\n\n使用`sync.Once`改造的示例代码如下：\n\n```go\nvar icons map[string]image.Image\n\nvar loadIconsOnce sync.Once\n\nfunc loadIcons() {\n\ticons = map[string]image.Image{\n\t\t\"left\":  loadIcon(\"left.png\"),\n\t\t\"up\":    loadIcon(\"up.png\"),\n\t\t\"right\": loadIcon(\"right.png\"),\n\t\t\"down\":  loadIcon(\"down.png\"),\n\t}\n}\n\n// Icon 是并发安全的\nfunc Icon(name string) image.Image {\n\tloadIconsOnce.Do(loadIcons)\n\treturn icons[name]\n}\n```\n\n#### 并发安全的单例模式\n\n下面是借助`sync.Once`实现的并发安全的单例模式：\n\n```go\npackage singleton\n\nimport (\n    \"sync\"\n)\n\ntype singleton struct {}\n\nvar instance *singleton\nvar once sync.Once\n\nfunc GetInstance() *singleton {\n    once.Do(func() {\n        instance = &singleton{}\n    })\n    return instance\n}\n```\n\n`sync.Once`其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。\n\n### sync.Map\n\nGo语言中内置的map不是并发安全的。请看下面的示例：\n\n```go\nvar m = make(map[string]int)\n\nfunc get(key string) int {\n\treturn m[key]\n}\n\nfunc set(key string, value int) {\n\tm[key] = value\n}\n\nfunc main() {\n\twg := sync.WaitGroup{}\n\tfor i := 0; i < 20; i++ {\n\t\twg.Add(1)\n\t\tgo func(n int) {\n\t\t\tkey := strconv.Itoa(n)\n\t\t\tset(key, n)\n\t\t\tfmt.Printf(\"k=:%v,v:=%v\\n\", key, get(key))\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\twg.Wait()\n}\n```\n\n上面的代码开启少量几个`goroutine`的时候可能没什么问题，当并发多了之后执行上面的代码就会报`fatal error: concurrent map writes`错误。\n\n像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的`sync`包中提供了一个开箱即用的并发安全版map–`sync.Map`。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时`sync.Map`内置了诸如`Store`、`Load`、`LoadOrStore`、`Delete`、`Range`等操作方法。\n\n```go\nvar m = sync.Map{}\n\nfunc main() {\n\twg := sync.WaitGroup{}\n\tfor i := 0; i < 20; i++ {\n\t\twg.Add(1)\n\t\tgo func(n int) {\n\t\t\tkey := strconv.Itoa(n)\n\t\t\tm.Store(key, n)\n\t\t\tvalue, _ := m.Load(key)\n\t\t\tfmt.Printf(\"k=:%v,v:=%v\\n\", key, value)\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\twg.Wait()\n}\n```\n\n## 原子操作\n\n代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库`sync/atomic`提供。\n\n### atomic包\n\n|                             方法                             |      解释      |\n| :----------------------------------------------------------: | :------------: |\n| func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer) |    读取操作    |\n| func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer) |    写入操作    |\n| func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr) |    修改操作    |\n| func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer) |    交换操作    |\n| func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool) | 比较并交换操作 |\n\n### 示例\n\n我们填写一个示例来比较下互斥锁和原子操作的性能。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype Counter interface {\n\tInc()\n\tLoad() int64\n}\n\n// 普通版\ntype CommonCounter struct {\n\tcounter int64\n}\n\nfunc (c CommonCounter) Inc() {\n\tc.counter++\n}\n\nfunc (c CommonCounter) Load() int64 {\n\treturn c.counter\n}\n\n// 互斥锁版\ntype MutexCounter struct {\n\tcounter int64\n\tlock    sync.Mutex\n}\n\nfunc (m *MutexCounter) Inc() {\n\tm.lock.Lock()\n\tdefer m.lock.Unlock()\n\tm.counter++\n}\n\nfunc (m *MutexCounter) Load() int64 {\n\tm.lock.Lock()\n\tdefer m.lock.Unlock()\n\treturn m.counter\n}\n\n// 原子操作版\ntype AtomicCounter struct {\n\tcounter int64\n}\n\nfunc (a *AtomicCounter) Inc() {\n\tatomic.AddInt64(&a.counter, 1)\n}\n\nfunc (a *AtomicCounter) Load() int64 {\n\treturn atomic.LoadInt64(&a.counter)\n}\n\nfunc test(c Counter) {\n\tvar wg sync.WaitGroup\n\tstart := time.Now()\n\tfor i := 0; i < 1000; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tc.Inc()\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n\tend := time.Now()\n\tfmt.Println(c.Load(), end.Sub(start))\n}\n\nfunc main() {\n\tc1 := CommonCounter{} // 非并发安全\n\ttest(c1)\n\tc2 := MutexCounter{} // 使用互斥锁实现并发安全\n\ttest(&c2)\n\tc3 := AtomicCounter{} // 并发安全且比互斥锁效率更高\n\ttest(&c3)\n}\n```\n\n`atomic`包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。","slug":"Go语言基础之并发","published":1,"updated":"2020-02-10T07:47:11.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rjb000dzd5b894i05um","content":"<h1 id=\"Go语言中的并发编程\"><a href=\"#Go语言中的并发编程\" class=\"headerlink\" title=\"Go语言中的并发编程\"></a>Go语言中的并发编程</h1><h2 id=\"并发与并行\"><a href=\"#并发与并行\" class=\"headerlink\" title=\"并发与并行\"></a>并发与并行</h2><p>并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。</p>\n<p>并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。</p>\n<p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。</p>\n<p>Go语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。</p>\n<h2 id=\"goroutine\"><a href=\"#goroutine\" class=\"headerlink\" title=\"goroutine\"></a>goroutine</h2><p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？</p>\n<p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p>\n<p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了，就是这么简单粗暴。</p>\n<h3 id=\"使用goroutine\"><a href=\"#使用goroutine\" class=\"headerlink\" title=\"使用goroutine\"></a>使用goroutine</h3><p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加上<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。</p>\n<p>一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p>\n<h3 id=\"启动单个goroutine\"><a href=\"#启动单个goroutine\" class=\"headerlink\" title=\"启动单个goroutine\"></a>启动单个goroutine</h3><p>启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个<code>go</code>关键字。</p>\n<p>举个例子如下：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello Goroutine!\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main goroutine done!\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完<code>Hello Goroutine!</code>后打印<code>main goroutine done!</code>。</p>\n<p>接下来我们在调用hello函数前面加上关键字<code>go</code>，也就是启动一个goroutine去执行hello这个函数。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">go</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 启动另外一个goroutine去执行hello函数</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main goroutine done!\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这一次的执行结果只打印了<code>main goroutine done!</code>，并没有打印<code>Hello Goroutine!</code>。为什么呢？</p>\n<p>在程序启动时，Go程序就会为<code>main()</code>函数创建一个默认的<code>goroutine</code>。</p>\n<p>当main()函数返回的时候该<code>goroutine</code>就结束了，所有在<code>main()</code>函数中启动的<code>goroutine</code>会一同结束，<code>main</code>函数所在的<code>goroutine</code>就像是权利的游戏中的夜王，其他的<code>goroutine</code>都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p>\n<p>所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是<code>time.Sleep</code>了。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">go</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 启动另外一个goroutine去执行hello函数</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main goroutine done!\"</span><span class=\"token punctuation\">)</span>\n    time<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>执行上面的代码你会发现，这一次先打印<code>main goroutine done!</code>，然后紧接着打印<code>Hello Goroutine!</code>。</p>\n<p>首先为什么会先打印<code>main goroutine done!</code>是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</p>\n<h3 id=\"启动多个goroutine\"><a href=\"#启动多个goroutine\" class=\"headerlink\" title=\"启动多个goroutine\"></a>启动多个goroutine</h3><p>在Go语言中实现并发就是这样简单，我们还可以启动多个<code>goroutine</code>。让我们再来一个例子： （这里使用了<code>sync.WaitGroup</code>来实现goroutine的同步）</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> wg sync<span class=\"token punctuation\">.</span>WaitGroup\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span>i <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">defer</span> wg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// goroutine结束就登记-1</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello Goroutine!\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        wg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 启动一个goroutine就登记+1</span>\n        <span class=\"token keyword\">go</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 等待所有登记的goroutine都结束</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个<code>goroutine</code>是并发执行的，而<code>goroutine</code>的调度是随机的。</p>\n<h2 id=\"goroutine与线程\"><a href=\"#goroutine与线程\" class=\"headerlink\" title=\"goroutine与线程\"></a>goroutine与线程</h2><h3 id=\"可增长的栈\"><a href=\"#可增长的栈\" class=\"headerlink\" title=\"可增长的栈\"></a>可增长的栈</h3><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个<code>goroutine</code>的栈在其生命周期开始时只有很小的栈（典型情况下2KB），<code>goroutine</code>的栈不是固定的，他可以按需增大和缩小，<code>goroutine</code>的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的<code>goroutine</code>也是可以的。</p>\n<h3 id=\"goroutine调度\"><a href=\"#goroutine调度\" class=\"headerlink\" title=\"goroutine调度\"></a>goroutine调度</h3><p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>\n<ul>\n<li><code>G</code>很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li>\n<li><code>P</code>管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li>\n<li><code>M（machine）</code>是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li>\n</ul>\n<p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p>\n<p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p>\n<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，<code>goroutine</code>则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>\n<p><a href=\"https://www.cnblogs.com/sunsky303/p/9705727.html\" target=\"_blank\" rel=\"noopener\">点我了解更多</a></p>\n<h3 id=\"GOMAXPROCS\"><a href=\"#GOMAXPROCS\" class=\"headerlink\" title=\"GOMAXPROCS\"></a>GOMAXPROCS</h3><p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p>\n<p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p>\n<p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>\n<p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A:\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"B:\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    runtime<span class=\"token punctuation\">.</span><span class=\"token function\">GOMAXPROCS</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">go</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">go</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    time<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A:\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"B:\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    runtime<span class=\"token punctuation\">.</span><span class=\"token function\">GOMAXPROCS</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">go</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">go</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    time<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Go语言中的操作系统线程和goroutine的关系：</p>\n<ol>\n<li>一个操作系统线程对应用户态多个goroutine。</li>\n<li>go程序可以同时使用多个操作系统线程。</li>\n<li>goroutine和OS线程是多对多的关系，即m:n。</li>\n</ol>\n<h2 id=\"channel\"><a href=\"#channel\" class=\"headerlink\" title=\"channel\"></a>channel</h2><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p>\n<p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的<code>goroutine</code>中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p>\n<p>Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p>\n<p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p>\n<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p>\n<h3 id=\"channel类型\"><a href=\"#channel类型\" class=\"headerlink\" title=\"channel类型\"></a>channel类型</h3><p><code>channel</code>是一种类型，一种引用类型。声明通道类型的格式如下：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> 变量 <span class=\"token keyword\">chan</span> 元素类型</code></pre>\n<p>举几个例子：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> ch1 <span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span>   <span class=\"token comment\" spellcheck=\"true\">// 声明一个传递整型的通道</span>\n<span class=\"token keyword\">var</span> ch2 <span class=\"token keyword\">chan</span> <span class=\"token builtin\">bool</span>  <span class=\"token comment\" spellcheck=\"true\">// 声明一个传递布尔型的通道</span>\n<span class=\"token keyword\">var</span> ch3 <span class=\"token keyword\">chan</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span> <span class=\"token comment\" spellcheck=\"true\">// 声明一个传递int切片的通道</span></code></pre>\n<h3 id=\"创建channel\"><a href=\"#创建channel\" class=\"headerlink\" title=\"创建channel\"></a>创建channel</h3><p>通道是引用类型，通道类型的空值是<code>nil</code>。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> ch <span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// &lt;nil></span></code></pre>\n<p>声明的通道后需要使用<code>make</code>函数初始化之后才能使用。</p>\n<p>创建channel的格式如下：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> 元素类型<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>缓冲大小<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre>\n<p>channel的缓冲大小是可选的。</p>\n<p>举几个例子：</p>\n<pre class=\" language-go\"><code class=\"language-go\">ch4 <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>\nch5 <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span>\nch6 <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span></code></pre>\n<h3 id=\"channel操作\"><a href=\"#channel操作\" class=\"headerlink\" title=\"channel操作\"></a>channel操作</h3><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p>\n<p>发送和接收都使用<code>&lt;-</code>符号。</p>\n<p>现在我们先使用以下语句定义一个通道：</p>\n<pre class=\" language-go\"><code class=\"language-go\">ch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span></code></pre>\n<h4 id=\"发送\"><a href=\"#发送\" class=\"headerlink\" title=\"发送\"></a>发送</h4><p>将一个值发送到通道中。</p>\n<pre class=\" language-go\"><code class=\"language-go\">ch <span class=\"token operator\">&lt;-</span> <span class=\"token number\">10</span> <span class=\"token comment\" spellcheck=\"true\">// 把10发送到ch中</span></code></pre>\n<h4 id=\"接收\"><a href=\"#接收\" class=\"headerlink\" title=\"接收\"></a>接收</h4><p>从一个通道中接收值。</p>\n<pre class=\" language-go\"><code class=\"language-go\">x <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span> ch <span class=\"token comment\" spellcheck=\"true\">// 从ch中接收值并赋值给变量x</span>\n<span class=\"token operator\">&lt;-</span>ch       <span class=\"token comment\" spellcheck=\"true\">// 从ch中接收值，忽略结果</span></code></pre>\n<h4 id=\"关闭\"><a href=\"#关闭\" class=\"headerlink\" title=\"关闭\"></a>关闭</h4><p>我们通过调用内置的<code>close</code>函数来关闭通道。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token function\">close</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span></code></pre>\n<p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p>\n<p>关闭后的通道有以下特点：</p>\n<ol>\n<li>对一个关闭的通道再发送值就会导致panic。</li>\n<li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li>\n<li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li>\n<li>关闭一个已经关闭的通道会导致panic。</li>\n</ol>\n<h3 id=\"无缓冲的通道\"><a href=\"#无缓冲的通道\" class=\"headerlink\" title=\"无缓冲的通道\"></a>无缓冲的通道</h3><p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>\n    ch <span class=\"token operator\">&lt;-</span> <span class=\"token number\">10</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"发送成功\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">fatal error: all goroutines are asleep - deadlock<span class=\"token operator\">!</span>\n\ngoroutine 1 <span class=\"token punctuation\">[</span>chan send<span class=\"token punctuation\">]</span>:\nmain.main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">..</span>./src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54</code></pre>\n<p>为什么会出现<code>deadlock</code>错误呢？</p>\n<p>因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。</p>\n<p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p>\n<p>一种方法是启用一个<code>goroutine</code>去接收值，例如：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">recv</span><span class=\"token punctuation\">(</span>c <span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ret <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>c\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"接收成功\"</span><span class=\"token punctuation\">,</span> ret<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">go</span> <span class=\"token function\">recv</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 启用goroutine从通道接收值</span>\n    ch <span class=\"token operator\">&lt;-</span> <span class=\"token number\">10</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"发送成功\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p>\n<p>使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p>\n<h3 id=\"有缓冲的通道\"><a href=\"#有缓冲的通道\" class=\"headerlink\" title=\"有缓冲的通道\"></a>有缓冲的通道</h3><p>解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 创建一个容量为1的有缓冲区通道</span>\n    ch <span class=\"token operator\">&lt;-</span> <span class=\"token number\">10</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"发送成功\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p>\n<p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p>\n<h3 id=\"for-range从通道循环取值\"><a href=\"#for-range从通道循环取值\" class=\"headerlink\" title=\"for range从通道循环取值\"></a>for range从通道循环取值</h3><p>当向通道中发送完数据时，我们可以通过<code>close</code>函数来关闭通道。</p>\n<p>当通道被关闭时，再往该通道发送值会引发panic，从该通道里接收的值一直都是类型零值。那如何判断一个通道是否被关闭了呢？</p>\n<p>我们来看下面这个例子：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">// channel 练习</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ch1 <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>\n    ch2 <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 开启goroutine将0~100的数发送到ch1中</span>\n    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n            ch1 <span class=\"token operator\">&lt;-</span> i\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>ch1<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span>\n    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n            i<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>ch1 <span class=\"token comment\" spellcheck=\"true\">// 通道关闭后再取值ok=false</span>\n            <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>ok <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">break</span>\n            <span class=\"token punctuation\">}</span>\n            ch2 <span class=\"token operator\">&lt;-</span> i <span class=\"token operator\">*</span> i\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>ch2<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 在主goroutine中从ch2中接收值打印</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> ch2 <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 通道关闭后会退出for range循环</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是<code>for range</code>的方式。使用<code>for range</code>遍历通道，当通道被关闭的时候就会退出<code>for range</code>。</p>\n<h3 id=\"单向通道\"><a href=\"#单向通道\" class=\"headerlink\" title=\"单向通道\"></a>单向通道</h3><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p>\n<p>Go语言中提供了<strong>单向通道</strong>来处理这种情况。例如，我们把上面的例子改造如下：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">counter</span><span class=\"token punctuation\">(</span>out <span class=\"token keyword\">chan</span><span class=\"token operator\">&lt;-</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        out <span class=\"token operator\">&lt;-</span> i\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>out<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">squarer</span><span class=\"token punctuation\">(</span>out <span class=\"token keyword\">chan</span><span class=\"token operator\">&lt;-</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> in <span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> in <span class=\"token punctuation\">{</span>\n        out <span class=\"token operator\">&lt;-</span> i <span class=\"token operator\">*</span> i\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>out<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">printer</span><span class=\"token punctuation\">(</span>in <span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> in <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ch1 <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>\n    ch2 <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">go</span> <span class=\"token function\">counter</span><span class=\"token punctuation\">(</span>ch1<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">go</span> <span class=\"token function\">squarer</span><span class=\"token punctuation\">(</span>ch2<span class=\"token punctuation\">,</span> ch1<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">printer</span><span class=\"token punctuation\">(</span>ch2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>其中，</p>\n<ul>\n<li><code>chan&lt;- int</code>是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；</li>\n<li><code>&lt;-chan int</code>是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。</li>\n</ul>\n<p>在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</p>\n<h3 id=\"通道总结\"><a href=\"#通道总结\" class=\"headerlink\" title=\"通道总结\"></a>通道总结</h3><p><code>channel</code>常见的异常总结，如下图：<img src=\"/2020/02/08/go-yu-yan-ji-chu-zhi-bing-fa/1.png\" alt=\"channel异常总结\"></p>\n<p>关闭已经关闭的<code>channel</code>也会引发<code>panic</code>。</p>\n<h2 id=\"worker-pool（goroutine池）\"><a href=\"#worker-pool（goroutine池）\" class=\"headerlink\" title=\"worker pool（goroutine池）\"></a>worker pool（goroutine池）</h2><p>在工作中我们通常会使用可以指定启动的goroutine数量–<code>worker pool</code>模式，控制<code>goroutine</code>的数量，防止<code>goroutine</code>泄漏和暴涨。</p>\n<p>一个简易的<code>work pool</code>示例代码如下：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">worker</span><span class=\"token punctuation\">(</span>id <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> jobs <span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> results <span class=\"token keyword\">chan</span><span class=\"token operator\">&lt;-</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> j <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> jobs <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"worker:%d start job:%d\\n\"</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">)</span>\n        time<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">)</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"worker:%d end job:%d\\n\"</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">)</span>\n        results <span class=\"token operator\">&lt;-</span> j <span class=\"token operator\">*</span> <span class=\"token number\">2</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    jobs <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n    results <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 开启3个goroutine</span>\n    <span class=\"token keyword\">for</span> w <span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> w <span class=\"token operator\">&lt;=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> w<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">go</span> <span class=\"token function\">worker</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">,</span> jobs<span class=\"token punctuation\">,</span> results<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 5个任务</span>\n    <span class=\"token keyword\">for</span> j <span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        jobs <span class=\"token operator\">&lt;-</span> j\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>jobs<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 输出结果</span>\n    <span class=\"token keyword\">for</span> a <span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> a <span class=\"token operator\">&lt;=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> a<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token operator\">&lt;-</span>results\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"select多路复用\"><a href=\"#select多路复用\" class=\"headerlink\" title=\"select多路复用\"></a>select多路复用</h2><p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 尝试从ch1接收值</span>\n    data<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>ch1\n    <span class=\"token comment\" spellcheck=\"true\">// 尝试从ch2接收值</span>\n    data<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>ch2\n    …\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了<code>select</code>关键字，可以同时响应多个通道的操作。</p>\n<p><code>select</code>的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。具体格式如下：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">select</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token operator\">&lt;-</span>ch1<span class=\"token punctuation\">:</span>\n        <span class=\"token operator\">...</span>\n    <span class=\"token keyword\">case</span> data <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>ch2<span class=\"token punctuation\">:</span>\n        <span class=\"token operator\">...</span>\n    <span class=\"token keyword\">case</span> ch3<span class=\"token operator\">&lt;-</span>data<span class=\"token punctuation\">:</span>\n        <span class=\"token operator\">...</span>\n    <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n        默认操作\n<span class=\"token punctuation\">}</span></code></pre>\n<p>举个小例子来演示下<code>select</code>的使用：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">select</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> x <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>ch<span class=\"token punctuation\">:</span>\n            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">case</span> ch <span class=\"token operator\">&lt;-</span> i<span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>使用<code>select</code>语句能提高代码的可读性。</p>\n<ul>\n<li>可处理一个或多个channel的发送/接收操作。</li>\n<li>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</li>\n<li>对于没有<code>case</code>的<code>select{}</code>会一直等待，可用于阻塞main函数。</li>\n</ul>\n<h2 id=\"并发安全和锁\"><a href=\"#并发安全和锁\" class=\"headerlink\" title=\"并发安全和锁\"></a>并发安全和锁</h2><p>有时候在Go代码中可能会存在多个<code>goroutine</code>同时操作一个资源（临界区），这种情况会发生<code>竞态问题</code>（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。</p>\n<p>举个例子：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> x <span class=\"token builtin\">int64</span>\n<span class=\"token keyword\">var</span> wg sync<span class=\"token punctuation\">.</span>WaitGroup\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        x <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n    <span class=\"token punctuation\">}</span>\n    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">go</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">go</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>上面的代码中我们开启了两个<code>goroutine</code>去累加变量x的值，这两个<code>goroutine</code>在访问和修改<code>x</code>变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p>\n<h3 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h3><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> x <span class=\"token builtin\">int64</span>\n<span class=\"token keyword\">var</span> wg sync<span class=\"token punctuation\">.</span>WaitGroup\n<span class=\"token keyword\">var</span> lock sync<span class=\"token punctuation\">.</span>Mutex\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        lock<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 加锁</span>\n        x <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n        lock<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 解锁</span>\n    <span class=\"token punctuation\">}</span>\n    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">go</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">go</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，唤醒的策略是随机的。</p>\n<h3 id=\"读写互斥锁\"><a href=\"#读写互斥锁\" class=\"headerlink\" title=\"读写互斥锁\"></a>读写互斥锁</h3><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p>\n<p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的<code>goroutine</code>如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p>\n<p>读写锁示例：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> <span class=\"token punctuation\">(</span>\n    x      <span class=\"token builtin\">int64</span>\n    wg     sync<span class=\"token punctuation\">.</span>WaitGroup\n    lock   sync<span class=\"token punctuation\">.</span>Mutex\n    rwlock sync<span class=\"token punctuation\">.</span>RWMutex\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// lock.Lock()   // 加互斥锁</span>\n    rwlock<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 加写锁</span>\n    x <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n    time<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span> <span class=\"token operator\">*</span> time<span class=\"token punctuation\">.</span>Millisecond<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 假设读操作耗时10毫秒</span>\n    rwlock<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                   <span class=\"token comment\" spellcheck=\"true\">// 解写锁</span>\n    <span class=\"token comment\" spellcheck=\"true\">// lock.Unlock()                     // 解互斥锁</span>\n    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// lock.Lock()                  // 加互斥锁</span>\n    rwlock<span class=\"token punctuation\">.</span><span class=\"token function\">RLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>               <span class=\"token comment\" spellcheck=\"true\">// 加读锁</span>\n    time<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>Millisecond<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 假设读操作耗时1毫秒</span>\n    rwlock<span class=\"token punctuation\">.</span><span class=\"token function\">RUnlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>             <span class=\"token comment\" spellcheck=\"true\">// 解读锁</span>\n    <span class=\"token comment\" spellcheck=\"true\">// lock.Unlock()                // 解互斥锁</span>\n    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    start <span class=\"token operator\">:=</span> time<span class=\"token punctuation\">.</span><span class=\"token function\">Now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        wg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">go</span> <span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        wg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">go</span> <span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    end <span class=\"token operator\">:=</span> time<span class=\"token punctuation\">.</span><span class=\"token function\">Now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>end<span class=\"token punctuation\">.</span><span class=\"token function\">Sub</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p>\n<h3 id=\"sync-WaitGroup\"><a href=\"#sync-WaitGroup\" class=\"headerlink\" title=\"sync.WaitGroup\"></a>sync.WaitGroup</h3><p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。<code>sync.WaitGroup</code>有以下几个方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">(wg * WaitGroup) Add(delta int)</td>\n<td align=\"center\">计数器+delta</td>\n</tr>\n<tr>\n<td align=\"center\">(wg *WaitGroup) Done()</td>\n<td align=\"center\">计数器-1</td>\n</tr>\n<tr>\n<td align=\"center\">(wg *WaitGroup) Wait()</td>\n<td align=\"center\">阻塞直到计数器变为0</td>\n</tr>\n</tbody></table>\n<p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p>\n<p>我们利用<code>sync.WaitGroup</code>将上面的代码优化一下：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> wg sync<span class=\"token punctuation\">.</span>WaitGroup\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">defer</span> wg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello Goroutine!\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">go</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 启动另外一个goroutine去执行hello函数</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main goroutine done!\"</span><span class=\"token punctuation\">)</span>\n    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>需要注意<code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。</p>\n<h3 id=\"sync-Once\"><a href=\"#sync-Once\" class=\"headerlink\" title=\"sync.Once\"></a>sync.Once</h3><p>说在前面的话：这是一个进阶知识点。</p>\n<p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p>\n<p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案–<code>sync.Once</code>。</p>\n<p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>o <span class=\"token operator\">*</span>Once<span class=\"token punctuation\">)</span> <span class=\"token function\">Do</span><span class=\"token punctuation\">(</span>f <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre>\n<p><em>备注：如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</em></p>\n<h4 id=\"加载配置文件示例\"><a href=\"#加载配置文件示例\" class=\"headerlink\" title=\"加载配置文件示例\"></a>加载配置文件示例</h4><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> icons <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span>image<span class=\"token punctuation\">.</span>Image\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">loadIcons</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    icons <span class=\"token operator\">=</span> <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span>image<span class=\"token punctuation\">.</span>Image<span class=\"token punctuation\">{</span>\n        <span class=\"token string\">\"left\"</span><span class=\"token punctuation\">:</span>  <span class=\"token function\">loadIcon</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"left.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"up\"</span><span class=\"token punctuation\">:</span>    <span class=\"token function\">loadIcon</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"up.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"right\"</span><span class=\"token punctuation\">:</span> <span class=\"token function\">loadIcon</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"right.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"down\"</span><span class=\"token punctuation\">:</span>  <span class=\"token function\">loadIcon</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"down.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Icon 被多个goroutine调用时不是并发安全的</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">Icon</span><span class=\"token punctuation\">(</span>name <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> image<span class=\"token punctuation\">.</span>Image <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> icons <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">loadIcons</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> icons<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>多个<code>goroutine</code>并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个<code>goroutine</code>都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">loadIcons</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    icons <span class=\"token operator\">=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span>image<span class=\"token punctuation\">.</span>Image<span class=\"token punctuation\">)</span>\n    icons<span class=\"token punctuation\">[</span><span class=\"token string\">\"left\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">loadIcon</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"left.png\"</span><span class=\"token punctuation\">)</span>\n    icons<span class=\"token punctuation\">[</span><span class=\"token string\">\"up\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">loadIcon</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"up.png\"</span><span class=\"token punctuation\">)</span>\n    icons<span class=\"token punctuation\">[</span><span class=\"token string\">\"right\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">loadIcon</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"right.png\"</span><span class=\"token punctuation\">)</span>\n    icons<span class=\"token punctuation\">[</span><span class=\"token string\">\"down\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">loadIcon</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"down.png\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的<code>goroutine</code>操作，但是这样做又会引发性能问题。</p>\n<p>使用<code>sync.Once</code>改造的示例代码如下：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> icons <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span>image<span class=\"token punctuation\">.</span>Image\n\n<span class=\"token keyword\">var</span> loadIconsOnce sync<span class=\"token punctuation\">.</span>Once\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">loadIcons</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    icons <span class=\"token operator\">=</span> <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span>image<span class=\"token punctuation\">.</span>Image<span class=\"token punctuation\">{</span>\n        <span class=\"token string\">\"left\"</span><span class=\"token punctuation\">:</span>  <span class=\"token function\">loadIcon</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"left.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"up\"</span><span class=\"token punctuation\">:</span>    <span class=\"token function\">loadIcon</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"up.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"right\"</span><span class=\"token punctuation\">:</span> <span class=\"token function\">loadIcon</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"right.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"down\"</span><span class=\"token punctuation\">:</span>  <span class=\"token function\">loadIcon</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"down.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Icon 是并发安全的</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">Icon</span><span class=\"token punctuation\">(</span>name <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> image<span class=\"token punctuation\">.</span>Image <span class=\"token punctuation\">{</span>\n    loadIconsOnce<span class=\"token punctuation\">.</span><span class=\"token function\">Do</span><span class=\"token punctuation\">(</span>loadIcons<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> icons<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"并发安全的单例模式\"><a href=\"#并发安全的单例模式\" class=\"headerlink\" title=\"并发安全的单例模式\"></a>并发安全的单例模式</h4><p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> singleton\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"sync\"</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">type</span> singleton <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> instance <span class=\"token operator\">*</span>singleton\n<span class=\"token keyword\">var</span> once sync<span class=\"token punctuation\">.</span>Once\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">GetInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>singleton <span class=\"token punctuation\">{</span>\n    once<span class=\"token punctuation\">.</span><span class=\"token function\">Do</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        instance <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>singleton<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> instance\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p>\n<h3 id=\"sync-Map\"><a href=\"#sync-Map\" class=\"headerlink\" title=\"sync.Map\"></a>sync.Map</h3><p>Go语言中内置的map不是并发安全的。请看下面的示例：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> m <span class=\"token operator\">=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> m<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">set</span><span class=\"token punctuation\">(</span>key <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> value <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    m<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    wg <span class=\"token operator\">:=</span> sync<span class=\"token punctuation\">.</span>WaitGroup<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        wg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>n <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            key <span class=\"token operator\">:=</span> strconv<span class=\"token punctuation\">.</span><span class=\"token function\">Itoa</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n            <span class=\"token function\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span>\n            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"k=:%v,v:=%v\\n\"</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            wg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p>\n<p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> m <span class=\"token operator\">=</span> sync<span class=\"token punctuation\">.</span>Map<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    wg <span class=\"token operator\">:=</span> sync<span class=\"token punctuation\">.</span>WaitGroup<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        wg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>n <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            key <span class=\"token operator\">:=</span> strconv<span class=\"token punctuation\">.</span><span class=\"token function\">Itoa</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n            m<span class=\"token punctuation\">.</span><span class=\"token function\">Store</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span>\n            value<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> m<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"k=:%v,v:=%v\\n\"</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span>\n            wg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h2><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p>\n<h3 id=\"atomic包\"><a href=\"#atomic包\" class=\"headerlink\" title=\"atomic包\"></a>atomic包</h3><table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</td>\n<td align=\"center\">读取操作</td>\n</tr>\n<tr>\n<td align=\"center\">func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</td>\n<td align=\"center\">写入操作</td>\n</tr>\n<tr>\n<td align=\"center\">func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td>\n<td align=\"center\">修改操作</td>\n</tr>\n<tr>\n<td align=\"center\">func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td>\n<td align=\"center\">交换操作</td>\n</tr>\n<tr>\n<td align=\"center\">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td>\n<td align=\"center\">比较并交换操作</td>\n</tr>\n</tbody></table>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"fmt\"</span>\n    <span class=\"token string\">\"sync\"</span>\n    <span class=\"token string\">\"sync/atomic\"</span>\n    <span class=\"token string\">\"time\"</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">type</span> Counter <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Inc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int64</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 普通版</span>\n<span class=\"token keyword\">type</span> CommonCounter <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    counter <span class=\"token builtin\">int64</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>c CommonCounter<span class=\"token punctuation\">)</span> <span class=\"token function\">Inc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    c<span class=\"token punctuation\">.</span>counter<span class=\"token operator\">++</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>c CommonCounter<span class=\"token punctuation\">)</span> <span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int64</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> c<span class=\"token punctuation\">.</span>counter\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 互斥锁版</span>\n<span class=\"token keyword\">type</span> MutexCounter <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    counter <span class=\"token builtin\">int64</span>\n    lock    sync<span class=\"token punctuation\">.</span>Mutex\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>MutexCounter<span class=\"token punctuation\">)</span> <span class=\"token function\">Inc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    m<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">defer</span> m<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    m<span class=\"token punctuation\">.</span>counter<span class=\"token operator\">++</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>MutexCounter<span class=\"token punctuation\">)</span> <span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int64</span> <span class=\"token punctuation\">{</span>\n    m<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">defer</span> m<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> m<span class=\"token punctuation\">.</span>counter\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 原子操作版</span>\n<span class=\"token keyword\">type</span> AtomicCounter <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    counter <span class=\"token builtin\">int64</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">*</span>AtomicCounter<span class=\"token punctuation\">)</span> <span class=\"token function\">Inc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    atomic<span class=\"token punctuation\">.</span><span class=\"token function\">AddInt64</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">.</span>counter<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">*</span>AtomicCounter<span class=\"token punctuation\">)</span> <span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int64</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">LoadInt64</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">.</span>counter<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span>c Counter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> wg sync<span class=\"token punctuation\">.</span>WaitGroup\n    start <span class=\"token operator\">:=</span> time<span class=\"token punctuation\">.</span><span class=\"token function\">Now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        wg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            c<span class=\"token punctuation\">.</span><span class=\"token function\">Inc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            wg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    end <span class=\"token operator\">:=</span> time<span class=\"token punctuation\">.</span><span class=\"token function\">Now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">.</span><span class=\"token function\">Sub</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    c1 <span class=\"token operator\">:=</span> CommonCounter<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// 非并发安全</span>\n    <span class=\"token function\">test</span><span class=\"token punctuation\">(</span>c1<span class=\"token punctuation\">)</span>\n    c2 <span class=\"token operator\">:=</span> MutexCounter<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// 使用互斥锁实现并发安全</span>\n    <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c2<span class=\"token punctuation\">)</span>\n    c3 <span class=\"token operator\">:=</span> AtomicCounter<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// 并发安全且比互斥锁效率更高</span>\n    <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c3<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<h1 id=\"Go语言中的并发编程\"><a href=\"#Go语言中的并发编程\" class=\"headerlink\" title=\"Go语言中的并发编程\"></a>Go语言中的并发编程</h1><h2 id=\"并发与并行\"><a href=\"#并发与并行\" class=\"headerlink\" title=\"并发与并行\"></a>并发与并行</h2><p>并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。</p>\n<p>并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。</p>\n<p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。</p>\n<p>Go语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。</p>\n<h2 id=\"goroutine\"><a href=\"#goroutine\" class=\"headerlink\" title=\"goroutine\"></a>goroutine</h2><p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？</p>\n<p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p>\n<p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了，就是这么简单粗暴。</p>\n<h3 id=\"使用goroutine\"><a href=\"#使用goroutine\" class=\"headerlink\" title=\"使用goroutine\"></a>使用goroutine</h3><p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加上<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。</p>\n<p>一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p>\n<h3 id=\"启动单个goroutine\"><a href=\"#启动单个goroutine\" class=\"headerlink\" title=\"启动单个goroutine\"></a>启动单个goroutine</h3><p>启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个<code>go</code>关键字。</p>\n<p>举个例子如下：</p>\n<pre><code class=\"go\">func hello() {\n    fmt.Println(&quot;Hello Goroutine!&quot;)\n}\nfunc main() {\n    hello()\n    fmt.Println(&quot;main goroutine done!&quot;)\n}</code></pre>\n<p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完<code>Hello Goroutine!</code>后打印<code>main goroutine done!</code>。</p>\n<p>接下来我们在调用hello函数前面加上关键字<code>go</code>，也就是启动一个goroutine去执行hello这个函数。</p>\n<pre><code class=\"go\">func main() {\n    go hello() // 启动另外一个goroutine去执行hello函数\n    fmt.Println(&quot;main goroutine done!&quot;)\n}</code></pre>\n<p>这一次的执行结果只打印了<code>main goroutine done!</code>，并没有打印<code>Hello Goroutine!</code>。为什么呢？</p>\n<p>在程序启动时，Go程序就会为<code>main()</code>函数创建一个默认的<code>goroutine</code>。</p>\n<p>当main()函数返回的时候该<code>goroutine</code>就结束了，所有在<code>main()</code>函数中启动的<code>goroutine</code>会一同结束，<code>main</code>函数所在的<code>goroutine</code>就像是权利的游戏中的夜王，其他的<code>goroutine</code>都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p>\n<p>所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是<code>time.Sleep</code>了。</p>\n<pre><code class=\"go\">func main() {\n    go hello() // 启动另外一个goroutine去执行hello函数\n    fmt.Println(&quot;main goroutine done!&quot;)\n    time.Sleep(time.Second)\n}</code></pre>\n<p>执行上面的代码你会发现，这一次先打印<code>main goroutine done!</code>，然后紧接着打印<code>Hello Goroutine!</code>。</p>\n<p>首先为什么会先打印<code>main goroutine done!</code>是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</p>\n<h3 id=\"启动多个goroutine\"><a href=\"#启动多个goroutine\" class=\"headerlink\" title=\"启动多个goroutine\"></a>启动多个goroutine</h3><p>在Go语言中实现并发就是这样简单，我们还可以启动多个<code>goroutine</code>。让我们再来一个例子： （这里使用了<code>sync.WaitGroup</code>来实现goroutine的同步）</p>\n<pre><code class=\"go\">var wg sync.WaitGroup\n\nfunc hello(i int) {\n    defer wg.Done() // goroutine结束就登记-1\n    fmt.Println(&quot;Hello Goroutine!&quot;, i)\n}\nfunc main() {\n\n    for i := 0; i &lt; 10; i++ {\n        wg.Add(1) // 启动一个goroutine就登记+1\n        go hello(i)\n    }\n    wg.Wait() // 等待所有登记的goroutine都结束\n}</code></pre>\n<p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个<code>goroutine</code>是并发执行的，而<code>goroutine</code>的调度是随机的。</p>\n<h2 id=\"goroutine与线程\"><a href=\"#goroutine与线程\" class=\"headerlink\" title=\"goroutine与线程\"></a>goroutine与线程</h2><h3 id=\"可增长的栈\"><a href=\"#可增长的栈\" class=\"headerlink\" title=\"可增长的栈\"></a>可增长的栈</h3><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个<code>goroutine</code>的栈在其生命周期开始时只有很小的栈（典型情况下2KB），<code>goroutine</code>的栈不是固定的，他可以按需增大和缩小，<code>goroutine</code>的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的<code>goroutine</code>也是可以的。</p>\n<h3 id=\"goroutine调度\"><a href=\"#goroutine调度\" class=\"headerlink\" title=\"goroutine调度\"></a>goroutine调度</h3><p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>\n<ul>\n<li><code>G</code>很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li>\n<li><code>P</code>管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li>\n<li><code>M（machine）</code>是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li>\n</ul>\n<p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p>\n<p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p>\n<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，<code>goroutine</code>则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>\n<p><a href=\"https://www.cnblogs.com/sunsky303/p/9705727.html\" target=\"_blank\" rel=\"noopener\">点我了解更多</a></p>\n<h3 id=\"GOMAXPROCS\"><a href=\"#GOMAXPROCS\" class=\"headerlink\" title=\"GOMAXPROCS\"></a>GOMAXPROCS</h3><p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p>\n<p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p>\n<p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>\n<p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p>\n<pre><code class=\"go\">func a() {\n    for i := 1; i &lt; 10; i++ {\n        fmt.Println(&quot;A:&quot;, i)\n    }\n}\n\nfunc b() {\n    for i := 1; i &lt; 10; i++ {\n        fmt.Println(&quot;B:&quot;, i)\n    }\n}\n\nfunc main() {\n    runtime.GOMAXPROCS(1)\n    go a()\n    go b()\n    time.Sleep(time.Second)\n}</code></pre>\n<p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。</p>\n<pre><code class=\"go\">func a() {\n    for i := 1; i &lt; 10; i++ {\n        fmt.Println(&quot;A:&quot;, i)\n    }\n}\n\nfunc b() {\n    for i := 1; i &lt; 10; i++ {\n        fmt.Println(&quot;B:&quot;, i)\n    }\n}\n\nfunc main() {\n    runtime.GOMAXPROCS(2)\n    go a()\n    go b()\n    time.Sleep(time.Second)\n}</code></pre>\n<p>Go语言中的操作系统线程和goroutine的关系：</p>\n<ol>\n<li>一个操作系统线程对应用户态多个goroutine。</li>\n<li>go程序可以同时使用多个操作系统线程。</li>\n<li>goroutine和OS线程是多对多的关系，即m:n。</li>\n</ol>\n<h2 id=\"channel\"><a href=\"#channel\" class=\"headerlink\" title=\"channel\"></a>channel</h2><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p>\n<p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的<code>goroutine</code>中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p>\n<p>Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p>\n<p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p>\n<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p>\n<h3 id=\"channel类型\"><a href=\"#channel类型\" class=\"headerlink\" title=\"channel类型\"></a>channel类型</h3><p><code>channel</code>是一种类型，一种引用类型。声明通道类型的格式如下：</p>\n<pre><code class=\"go\">var 变量 chan 元素类型</code></pre>\n<p>举几个例子：</p>\n<pre><code class=\"go\">var ch1 chan int   // 声明一个传递整型的通道\nvar ch2 chan bool  // 声明一个传递布尔型的通道\nvar ch3 chan []int // 声明一个传递int切片的通道</code></pre>\n<h3 id=\"创建channel\"><a href=\"#创建channel\" class=\"headerlink\" title=\"创建channel\"></a>创建channel</h3><p>通道是引用类型，通道类型的空值是<code>nil</code>。</p>\n<pre><code class=\"go\">var ch chan int\nfmt.Println(ch) // &lt;nil&gt;</code></pre>\n<p>声明的通道后需要使用<code>make</code>函数初始化之后才能使用。</p>\n<p>创建channel的格式如下：</p>\n<pre><code class=\"go\">make(chan 元素类型, [缓冲大小])</code></pre>\n<p>channel的缓冲大小是可选的。</p>\n<p>举几个例子：</p>\n<pre><code class=\"go\">ch4 := make(chan int)\nch5 := make(chan bool)\nch6 := make(chan []int)</code></pre>\n<h3 id=\"channel操作\"><a href=\"#channel操作\" class=\"headerlink\" title=\"channel操作\"></a>channel操作</h3><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p>\n<p>发送和接收都使用<code>&lt;-</code>符号。</p>\n<p>现在我们先使用以下语句定义一个通道：</p>\n<pre><code class=\"go\">ch := make(chan int)</code></pre>\n<h4 id=\"发送\"><a href=\"#发送\" class=\"headerlink\" title=\"发送\"></a>发送</h4><p>将一个值发送到通道中。</p>\n<pre><code class=\"go\">ch &lt;- 10 // 把10发送到ch中</code></pre>\n<h4 id=\"接收\"><a href=\"#接收\" class=\"headerlink\" title=\"接收\"></a>接收</h4><p>从一个通道中接收值。</p>\n<pre><code class=\"go\">x := &lt;- ch // 从ch中接收值并赋值给变量x\n&lt;-ch       // 从ch中接收值，忽略结果</code></pre>\n<h4 id=\"关闭\"><a href=\"#关闭\" class=\"headerlink\" title=\"关闭\"></a>关闭</h4><p>我们通过调用内置的<code>close</code>函数来关闭通道。</p>\n<pre><code class=\"go\">close(ch)</code></pre>\n<p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p>\n<p>关闭后的通道有以下特点：</p>\n<ol>\n<li>对一个关闭的通道再发送值就会导致panic。</li>\n<li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li>\n<li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li>\n<li>关闭一个已经关闭的通道会导致panic。</li>\n</ol>\n<h3 id=\"无缓冲的通道\"><a href=\"#无缓冲的通道\" class=\"headerlink\" title=\"无缓冲的通道\"></a>无缓冲的通道</h3><p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p>\n<pre><code class=\"go\">func main() {\n    ch := make(chan int)\n    ch &lt;- 10\n    fmt.Println(&quot;发送成功&quot;)\n}</code></pre>\n<p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p>\n<pre><code class=\"bash\">fatal error: all goroutines are asleep - deadlock!\n\ngoroutine 1 [chan send]:\nmain.main()\n        .../src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54</code></pre>\n<p>为什么会出现<code>deadlock</code>错误呢？</p>\n<p>因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。</p>\n<p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p>\n<p>一种方法是启用一个<code>goroutine</code>去接收值，例如：</p>\n<pre><code class=\"go\">func recv(c chan int) {\n    ret := &lt;-c\n    fmt.Println(&quot;接收成功&quot;, ret)\n}\nfunc main() {\n    ch := make(chan int)\n    go recv(ch) // 启用goroutine从通道接收值\n    ch &lt;- 10\n    fmt.Println(&quot;发送成功&quot;)\n}</code></pre>\n<p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p>\n<p>使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p>\n<h3 id=\"有缓冲的通道\"><a href=\"#有缓冲的通道\" class=\"headerlink\" title=\"有缓冲的通道\"></a>有缓冲的通道</h3><p>解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p>\n<pre><code class=\"go\">func main() {\n    ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道\n    ch &lt;- 10\n    fmt.Println(&quot;发送成功&quot;)\n}</code></pre>\n<p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p>\n<p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p>\n<h3 id=\"for-range从通道循环取值\"><a href=\"#for-range从通道循环取值\" class=\"headerlink\" title=\"for range从通道循环取值\"></a>for range从通道循环取值</h3><p>当向通道中发送完数据时，我们可以通过<code>close</code>函数来关闭通道。</p>\n<p>当通道被关闭时，再往该通道发送值会引发panic，从该通道里接收的值一直都是类型零值。那如何判断一个通道是否被关闭了呢？</p>\n<p>我们来看下面这个例子：</p>\n<pre><code class=\"go\">// channel 练习\nfunc main() {\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n    // 开启goroutine将0~100的数发送到ch1中\n    go func() {\n        for i := 0; i &lt; 100; i++ {\n            ch1 &lt;- i\n        }\n        close(ch1)\n    }()\n    // 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中\n    go func() {\n        for {\n            i, ok := &lt;-ch1 // 通道关闭后再取值ok=false\n            if !ok {\n                break\n            }\n            ch2 &lt;- i * i\n        }\n        close(ch2)\n    }()\n    // 在主goroutine中从ch2中接收值打印\n    for i := range ch2 { // 通道关闭后会退出for range循环\n        fmt.Println(i)\n    }\n}</code></pre>\n<p>从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是<code>for range</code>的方式。使用<code>for range</code>遍历通道，当通道被关闭的时候就会退出<code>for range</code>。</p>\n<h3 id=\"单向通道\"><a href=\"#单向通道\" class=\"headerlink\" title=\"单向通道\"></a>单向通道</h3><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p>\n<p>Go语言中提供了<strong>单向通道</strong>来处理这种情况。例如，我们把上面的例子改造如下：</p>\n<pre><code class=\"go\">func counter(out chan&lt;- int) {\n    for i := 0; i &lt; 100; i++ {\n        out &lt;- i\n    }\n    close(out)\n}\n\nfunc squarer(out chan&lt;- int, in &lt;-chan int) {\n    for i := range in {\n        out &lt;- i * i\n    }\n    close(out)\n}\nfunc printer(in &lt;-chan int) {\n    for i := range in {\n        fmt.Println(i)\n    }\n}\n\nfunc main() {\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n    go counter(ch1)\n    go squarer(ch2, ch1)\n    printer(ch2)\n}</code></pre>\n<p>其中，</p>\n<ul>\n<li><code>chan&lt;- int</code>是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；</li>\n<li><code>&lt;-chan int</code>是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。</li>\n</ul>\n<p>在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</p>\n<h3 id=\"通道总结\"><a href=\"#通道总结\" class=\"headerlink\" title=\"通道总结\"></a>通道总结</h3><p><code>channel</code>常见的异常总结，如下图：<img src=\"/2020/02/08/go-yu-yan-ji-chu-zhi-bing-fa/1.png\" alt=\"channel异常总结\"></p>\n<p>关闭已经关闭的<code>channel</code>也会引发<code>panic</code>。</p>\n<h2 id=\"worker-pool（goroutine池）\"><a href=\"#worker-pool（goroutine池）\" class=\"headerlink\" title=\"worker pool（goroutine池）\"></a>worker pool（goroutine池）</h2><p>在工作中我们通常会使用可以指定启动的goroutine数量–<code>worker pool</code>模式，控制<code>goroutine</code>的数量，防止<code>goroutine</code>泄漏和暴涨。</p>\n<p>一个简易的<code>work pool</code>示例代码如下：</p>\n<pre><code class=\"go\">func worker(id int, jobs &lt;-chan int, results chan&lt;- int) {\n    for j := range jobs {\n        fmt.Printf(&quot;worker:%d start job:%d\\n&quot;, id, j)\n        time.Sleep(time.Second)\n        fmt.Printf(&quot;worker:%d end job:%d\\n&quot;, id, j)\n        results &lt;- j * 2\n    }\n}\n\n\nfunc main() {\n    jobs := make(chan int, 100)\n    results := make(chan int, 100)\n    // 开启3个goroutine\n    for w := 1; w &lt;= 3; w++ {\n        go worker(w, jobs, results)\n    }\n    // 5个任务\n    for j := 1; j &lt;= 5; j++ {\n        jobs &lt;- j\n    }\n    close(jobs)\n    // 输出结果\n    for a := 1; a &lt;= 5; a++ {\n        &lt;-results\n    }\n}</code></pre>\n<h2 id=\"select多路复用\"><a href=\"#select多路复用\" class=\"headerlink\" title=\"select多路复用\"></a>select多路复用</h2><p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：</p>\n<pre><code class=\"go\">for{\n    // 尝试从ch1接收值\n    data, ok := &lt;-ch1\n    // 尝试从ch2接收值\n    data, ok := &lt;-ch2\n    …\n}</code></pre>\n<p>这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了<code>select</code>关键字，可以同时响应多个通道的操作。</p>\n<p><code>select</code>的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。具体格式如下：</p>\n<pre><code class=\"go\">select{\n    case &lt;-ch1:\n        ...\n    case data := &lt;-ch2:\n        ...\n    case ch3&lt;-data:\n        ...\n    default:\n        默认操作\n}</code></pre>\n<p>举个小例子来演示下<code>select</code>的使用：</p>\n<pre><code class=\"go\">func main() {\n    ch := make(chan int, 1)\n    for i := 0; i &lt; 10; i++ {\n        select {\n        case x := &lt;-ch:\n            fmt.Println(x)\n        case ch &lt;- i:\n        }\n    }\n}</code></pre>\n<p>使用<code>select</code>语句能提高代码的可读性。</p>\n<ul>\n<li>可处理一个或多个channel的发送/接收操作。</li>\n<li>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</li>\n<li>对于没有<code>case</code>的<code>select{}</code>会一直等待，可用于阻塞main函数。</li>\n</ul>\n<h2 id=\"并发安全和锁\"><a href=\"#并发安全和锁\" class=\"headerlink\" title=\"并发安全和锁\"></a>并发安全和锁</h2><p>有时候在Go代码中可能会存在多个<code>goroutine</code>同时操作一个资源（临界区），这种情况会发生<code>竞态问题</code>（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。</p>\n<p>举个例子：</p>\n<pre><code class=\"go\">var x int64\nvar wg sync.WaitGroup\n\nfunc add() {\n    for i := 0; i &lt; 5000; i++ {\n        x = x + 1\n    }\n    wg.Done()\n}\nfunc main() {\n    wg.Add(2)\n    go add()\n    go add()\n    wg.Wait()\n    fmt.Println(x)\n}</code></pre>\n<p>上面的代码中我们开启了两个<code>goroutine</code>去累加变量x的值，这两个<code>goroutine</code>在访问和修改<code>x</code>变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p>\n<h3 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h3><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p>\n<pre><code class=\"go\">var x int64\nvar wg sync.WaitGroup\nvar lock sync.Mutex\n\nfunc add() {\n    for i := 0; i &lt; 5000; i++ {\n        lock.Lock() // 加锁\n        x = x + 1\n        lock.Unlock() // 解锁\n    }\n    wg.Done()\n}\nfunc main() {\n    wg.Add(2)\n    go add()\n    go add()\n    wg.Wait()\n    fmt.Println(x)\n}</code></pre>\n<p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，唤醒的策略是随机的。</p>\n<h3 id=\"读写互斥锁\"><a href=\"#读写互斥锁\" class=\"headerlink\" title=\"读写互斥锁\"></a>读写互斥锁</h3><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p>\n<p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的<code>goroutine</code>如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p>\n<p>读写锁示例：</p>\n<pre><code class=\"go\">var (\n    x      int64\n    wg     sync.WaitGroup\n    lock   sync.Mutex\n    rwlock sync.RWMutex\n)\n\nfunc write() {\n    // lock.Lock()   // 加互斥锁\n    rwlock.Lock() // 加写锁\n    x = x + 1\n    time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒\n    rwlock.Unlock()                   // 解写锁\n    // lock.Unlock()                     // 解互斥锁\n    wg.Done()\n}\n\nfunc read() {\n    // lock.Lock()                  // 加互斥锁\n    rwlock.RLock()               // 加读锁\n    time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒\n    rwlock.RUnlock()             // 解读锁\n    // lock.Unlock()                // 解互斥锁\n    wg.Done()\n}\n\nfunc main() {\n    start := time.Now()\n    for i := 0; i &lt; 10; i++ {\n        wg.Add(1)\n        go write()\n    }\n\n    for i := 0; i &lt; 1000; i++ {\n        wg.Add(1)\n        go read()\n    }\n\n    wg.Wait()\n    end := time.Now()\n    fmt.Println(end.Sub(start))\n}</code></pre>\n<p>需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p>\n<h3 id=\"sync-WaitGroup\"><a href=\"#sync-WaitGroup\" class=\"headerlink\" title=\"sync.WaitGroup\"></a>sync.WaitGroup</h3><p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。<code>sync.WaitGroup</code>有以下几个方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">(wg * WaitGroup) Add(delta int)</td>\n<td align=\"center\">计数器+delta</td>\n</tr>\n<tr>\n<td align=\"center\">(wg *WaitGroup) Done()</td>\n<td align=\"center\">计数器-1</td>\n</tr>\n<tr>\n<td align=\"center\">(wg *WaitGroup) Wait()</td>\n<td align=\"center\">阻塞直到计数器变为0</td>\n</tr>\n</tbody></table>\n<p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p>\n<p>我们利用<code>sync.WaitGroup</code>将上面的代码优化一下：</p>\n<pre><code class=\"go\">var wg sync.WaitGroup\n\nfunc hello() {\n    defer wg.Done()\n    fmt.Println(&quot;Hello Goroutine!&quot;)\n}\nfunc main() {\n    wg.Add(1)\n    go hello() // 启动另外一个goroutine去执行hello函数\n    fmt.Println(&quot;main goroutine done!&quot;)\n    wg.Wait()\n}</code></pre>\n<p>需要注意<code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。</p>\n<h3 id=\"sync-Once\"><a href=\"#sync-Once\" class=\"headerlink\" title=\"sync.Once\"></a>sync.Once</h3><p>说在前面的话：这是一个进阶知识点。</p>\n<p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p>\n<p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案–<code>sync.Once</code>。</p>\n<p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p>\n<pre><code class=\"go\">func (o *Once) Do(f func()) {}</code></pre>\n<p><em>备注：如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</em></p>\n<h4 id=\"加载配置文件示例\"><a href=\"#加载配置文件示例\" class=\"headerlink\" title=\"加载配置文件示例\"></a>加载配置文件示例</h4><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p>\n<pre><code class=\"go\">var icons map[string]image.Image\n\nfunc loadIcons() {\n    icons = map[string]image.Image{\n        &quot;left&quot;:  loadIcon(&quot;left.png&quot;),\n        &quot;up&quot;:    loadIcon(&quot;up.png&quot;),\n        &quot;right&quot;: loadIcon(&quot;right.png&quot;),\n        &quot;down&quot;:  loadIcon(&quot;down.png&quot;),\n    }\n}\n\n// Icon 被多个goroutine调用时不是并发安全的\nfunc Icon(name string) image.Image {\n    if icons == nil {\n        loadIcons()\n    }\n    return icons[name]\n}</code></pre>\n<p>多个<code>goroutine</code>并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个<code>goroutine</code>都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p>\n<pre><code class=\"go\">func loadIcons() {\n    icons = make(map[string]image.Image)\n    icons[&quot;left&quot;] = loadIcon(&quot;left.png&quot;)\n    icons[&quot;up&quot;] = loadIcon(&quot;up.png&quot;)\n    icons[&quot;right&quot;] = loadIcon(&quot;right.png&quot;)\n    icons[&quot;down&quot;] = loadIcon(&quot;down.png&quot;)\n}</code></pre>\n<p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的<code>goroutine</code>操作，但是这样做又会引发性能问题。</p>\n<p>使用<code>sync.Once</code>改造的示例代码如下：</p>\n<pre><code class=\"go\">var icons map[string]image.Image\n\nvar loadIconsOnce sync.Once\n\nfunc loadIcons() {\n    icons = map[string]image.Image{\n        &quot;left&quot;:  loadIcon(&quot;left.png&quot;),\n        &quot;up&quot;:    loadIcon(&quot;up.png&quot;),\n        &quot;right&quot;: loadIcon(&quot;right.png&quot;),\n        &quot;down&quot;:  loadIcon(&quot;down.png&quot;),\n    }\n}\n\n// Icon 是并发安全的\nfunc Icon(name string) image.Image {\n    loadIconsOnce.Do(loadIcons)\n    return icons[name]\n}</code></pre>\n<h4 id=\"并发安全的单例模式\"><a href=\"#并发安全的单例模式\" class=\"headerlink\" title=\"并发安全的单例模式\"></a>并发安全的单例模式</h4><p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p>\n<pre><code class=\"go\">package singleton\n\nimport (\n    &quot;sync&quot;\n)\n\ntype singleton struct {}\n\nvar instance *singleton\nvar once sync.Once\n\nfunc GetInstance() *singleton {\n    once.Do(func() {\n        instance = &amp;singleton{}\n    })\n    return instance\n}</code></pre>\n<p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p>\n<h3 id=\"sync-Map\"><a href=\"#sync-Map\" class=\"headerlink\" title=\"sync.Map\"></a>sync.Map</h3><p>Go语言中内置的map不是并发安全的。请看下面的示例：</p>\n<pre><code class=\"go\">var m = make(map[string]int)\n\nfunc get(key string) int {\n    return m[key]\n}\n\nfunc set(key string, value int) {\n    m[key] = value\n}\n\nfunc main() {\n    wg := sync.WaitGroup{}\n    for i := 0; i &lt; 20; i++ {\n        wg.Add(1)\n        go func(n int) {\n            key := strconv.Itoa(n)\n            set(key, n)\n            fmt.Printf(&quot;k=:%v,v:=%v\\n&quot;, key, get(key))\n            wg.Done()\n        }(i)\n    }\n    wg.Wait()\n}</code></pre>\n<p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p>\n<p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p>\n<pre><code class=\"go\">var m = sync.Map{}\n\nfunc main() {\n    wg := sync.WaitGroup{}\n    for i := 0; i &lt; 20; i++ {\n        wg.Add(1)\n        go func(n int) {\n            key := strconv.Itoa(n)\n            m.Store(key, n)\n            value, _ := m.Load(key)\n            fmt.Printf(&quot;k=:%v,v:=%v\\n&quot;, key, value)\n            wg.Done()\n        }(i)\n    }\n    wg.Wait()\n}</code></pre>\n<h2 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h2><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p>\n<h3 id=\"atomic包\"><a href=\"#atomic包\" class=\"headerlink\" title=\"atomic包\"></a>atomic包</h3><table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</td>\n<td align=\"center\">读取操作</td>\n</tr>\n<tr>\n<td align=\"center\">func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</td>\n<td align=\"center\">写入操作</td>\n</tr>\n<tr>\n<td align=\"center\">func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td>\n<td align=\"center\">修改操作</td>\n</tr>\n<tr>\n<td align=\"center\">func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td>\n<td align=\"center\">交换操作</td>\n</tr>\n<tr>\n<td align=\"center\">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td>\n<td align=\"center\">比较并交换操作</td>\n</tr>\n</tbody></table>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p>\n<pre><code class=\"go\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;sync&quot;\n    &quot;sync/atomic&quot;\n    &quot;time&quot;\n)\n\ntype Counter interface {\n    Inc()\n    Load() int64\n}\n\n// 普通版\ntype CommonCounter struct {\n    counter int64\n}\n\nfunc (c CommonCounter) Inc() {\n    c.counter++\n}\n\nfunc (c CommonCounter) Load() int64 {\n    return c.counter\n}\n\n// 互斥锁版\ntype MutexCounter struct {\n    counter int64\n    lock    sync.Mutex\n}\n\nfunc (m *MutexCounter) Inc() {\n    m.lock.Lock()\n    defer m.lock.Unlock()\n    m.counter++\n}\n\nfunc (m *MutexCounter) Load() int64 {\n    m.lock.Lock()\n    defer m.lock.Unlock()\n    return m.counter\n}\n\n// 原子操作版\ntype AtomicCounter struct {\n    counter int64\n}\n\nfunc (a *AtomicCounter) Inc() {\n    atomic.AddInt64(&amp;a.counter, 1)\n}\n\nfunc (a *AtomicCounter) Load() int64 {\n    return atomic.LoadInt64(&amp;a.counter)\n}\n\nfunc test(c Counter) {\n    var wg sync.WaitGroup\n    start := time.Now()\n    for i := 0; i &lt; 1000; i++ {\n        wg.Add(1)\n        go func() {\n            c.Inc()\n            wg.Done()\n        }()\n    }\n    wg.Wait()\n    end := time.Now()\n    fmt.Println(c.Load(), end.Sub(start))\n}\n\nfunc main() {\n    c1 := CommonCounter{} // 非并发安全\n    test(c1)\n    c2 := MutexCounter{} // 使用互斥锁实现并发安全\n    test(&amp;c2)\n    c3 := AtomicCounter{} // 并发安全且比互斥锁效率更高\n    test(&amp;c3)\n}</code></pre>\n<p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p>\n"},{"title":"Kubernetes第一章 组件简介","date":"2020-02-05T02:17:34.000Z","_content":"\n## 云服务\n\n- 基础设施及服务 [ Infrastructure as a Service ( IAAS ) ] \t\t国内以阿里云为代表\n- 平台及服务 [ Platform as a Service  ( PAAS ) ]                      以新浪云为代表的的新浪平台套件 Sina SAE\n- 软件设施及服务 [ SoftWare as a Service (SAAS) ]                以Micaosoft的基础软件构建，Office的B/S套件\n\n以新浪的SAE服务来说，在申请一个PAAS服务来运行Java相关服务器程序的时候，在向sina云申请一个服务，sina后台接收到以后，会通过后台配置相对应地Java基础环境。但此时不是通过自动化的部署。\n\n然后出现一些自动运维工具的出现，降低了环境配置的繁琐工作，但是这还不是真正的自动化，随着**Docker**的出现，这些像PAAS服务的自动化才正真实现，所以Docker自然成为PAAS的下一代标准。\n\n虽然Docker解决了PAAS的容器化的相关问题，但是Docker容器内的相关联通交流映射问提就会显得非常复杂，比如：\n\n在物理环境下，构建服务器集群使用标准的Tcp访问到对应的主机的数据库服务或者Ngix相关服务这是很简单的事。但我们有很多的物理机被Docker虚拟化为容器以后，物理机上的相应端口和Docker容器的端口通过防火墙进行数据包的传递，同时容器的集群化也是一个很大的问题。\n\n## 资源管理器\n\n![](/mesos.jpg)\n\n### MESOS\n\n为了解决容器化集群带来的复杂性问题，MESOS诞生，[Mesos](https://baike.baidu.com/item/Mesos)是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。但是起初他不是为了解决容器化问题而诞生的，而是为了解决资源问题而产生的。但是Mesos只是一个管理平台，并没有很长久的使用。\n\n![](/dockerswarm.png)\n\n### DockerSwarm\n\nSwarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。目前，Swarm 是 Docker 社区提供的唯一一个原生支持 Docker 集群管理的工具。它可以把多个 Docker 主机组成的系统转换为单一的虚拟 Docker 主机，使得容器可以组成跨主机的子网网络。\n\nDocker Swarm 是一个为 IT 运维团队提供集群和调度能力的编排工具。用户可以把集群中所有 Docker Engine 整合进一个「虚拟 Engine」的资源池，通过执行命令与单一的主 Swarm 进行沟通，而不必分别和每个 Docker Engine 沟通。在灵活的调度策略下，IT 团队可以更好地管理可用的主机资源，保证应用容器的高效运行。\n\n实践中会发现，生产环境中使用单个 Docker 节点是远远不够的，搭建 Docker 集群势在必行。然而，面对 Kubernetes, Mesos 以及 Swarm 等众多容器集群系统，我们该如何选择呢？它们之中，Swarm 是 Docker 原生的，同时也是最简单，最易学，最节省资源的，比较适合中小型公司使用。\n\n![](/kubernetes.png)\n\n### Kubernetes\n\nKubernetes是Google开源的一款容器编排工具，它是诞生在Google内部运行N多年的博格系统之上的产物，因此其成熟度从其诞生初期就广泛受到业界的关注，并且迅速成为编排工具市场的主流，其社区活跃度非常高，版本迭代速度也很惊人，它的主要作用是对Docker容器做编排工作，当然，Docker只是容器工具的一种引擎，K8s可支持多种容器引擎，但从目前来说Docker容器引擎是具有绝对优势的。\n\n容器需要编排，也很容易理解，因为我们最核心要跑到业务通常都是LNMT/P的不同形式的扩展，但NMT/P他们的运行是有先后顺序的，也就是说MySQL要先启动，然后是Tomcat或PHP，最后是Nginx，而控制这种顺序就需要有容器编排工具来帮我们实现，另外，我们的业务希望7x24小时在线，如何保障？靠人是很难做到实时的，但编排工具可以，K8s帮我们实现了很多控制器，这控制器可以帮我们监控容器运行的状态，并自动帮我们重建(在容器时代重启就是重建)容器，并且还可以在容器处理能力不足时，自动根据我们定义的扩展规则，自动创建新Pod(k8s中最小单元,每个Pod中可有一个或多个容器)，并且在压力下去后，自动删除Pod等等功能。\n\n","source":"_posts/Kubernetes第一章-组件简介.md","raw":"---\ntitle: Kubernetes第一章 组件简介\ndate: 2020-02-05 10:17:34\ntags: [Kubernetes,Micro Service,微服务]\ncategories: Go栈\n---\n\n## 云服务\n\n- 基础设施及服务 [ Infrastructure as a Service ( IAAS ) ] \t\t国内以阿里云为代表\n- 平台及服务 [ Platform as a Service  ( PAAS ) ]                      以新浪云为代表的的新浪平台套件 Sina SAE\n- 软件设施及服务 [ SoftWare as a Service (SAAS) ]                以Micaosoft的基础软件构建，Office的B/S套件\n\n以新浪的SAE服务来说，在申请一个PAAS服务来运行Java相关服务器程序的时候，在向sina云申请一个服务，sina后台接收到以后，会通过后台配置相对应地Java基础环境。但此时不是通过自动化的部署。\n\n然后出现一些自动运维工具的出现，降低了环境配置的繁琐工作，但是这还不是真正的自动化，随着**Docker**的出现，这些像PAAS服务的自动化才正真实现，所以Docker自然成为PAAS的下一代标准。\n\n虽然Docker解决了PAAS的容器化的相关问题，但是Docker容器内的相关联通交流映射问提就会显得非常复杂，比如：\n\n在物理环境下，构建服务器集群使用标准的Tcp访问到对应的主机的数据库服务或者Ngix相关服务这是很简单的事。但我们有很多的物理机被Docker虚拟化为容器以后，物理机上的相应端口和Docker容器的端口通过防火墙进行数据包的传递，同时容器的集群化也是一个很大的问题。\n\n## 资源管理器\n\n![](/mesos.jpg)\n\n### MESOS\n\n为了解决容器化集群带来的复杂性问题，MESOS诞生，[Mesos](https://baike.baidu.com/item/Mesos)是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。但是起初他不是为了解决容器化问题而诞生的，而是为了解决资源问题而产生的。但是Mesos只是一个管理平台，并没有很长久的使用。\n\n![](/dockerswarm.png)\n\n### DockerSwarm\n\nSwarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。目前，Swarm 是 Docker 社区提供的唯一一个原生支持 Docker 集群管理的工具。它可以把多个 Docker 主机组成的系统转换为单一的虚拟 Docker 主机，使得容器可以组成跨主机的子网网络。\n\nDocker Swarm 是一个为 IT 运维团队提供集群和调度能力的编排工具。用户可以把集群中所有 Docker Engine 整合进一个「虚拟 Engine」的资源池，通过执行命令与单一的主 Swarm 进行沟通，而不必分别和每个 Docker Engine 沟通。在灵活的调度策略下，IT 团队可以更好地管理可用的主机资源，保证应用容器的高效运行。\n\n实践中会发现，生产环境中使用单个 Docker 节点是远远不够的，搭建 Docker 集群势在必行。然而，面对 Kubernetes, Mesos 以及 Swarm 等众多容器集群系统，我们该如何选择呢？它们之中，Swarm 是 Docker 原生的，同时也是最简单，最易学，最节省资源的，比较适合中小型公司使用。\n\n![](/kubernetes.png)\n\n### Kubernetes\n\nKubernetes是Google开源的一款容器编排工具，它是诞生在Google内部运行N多年的博格系统之上的产物，因此其成熟度从其诞生初期就广泛受到业界的关注，并且迅速成为编排工具市场的主流，其社区活跃度非常高，版本迭代速度也很惊人，它的主要作用是对Docker容器做编排工作，当然，Docker只是容器工具的一种引擎，K8s可支持多种容器引擎，但从目前来说Docker容器引擎是具有绝对优势的。\n\n容器需要编排，也很容易理解，因为我们最核心要跑到业务通常都是LNMT/P的不同形式的扩展，但NMT/P他们的运行是有先后顺序的，也就是说MySQL要先启动，然后是Tomcat或PHP，最后是Nginx，而控制这种顺序就需要有容器编排工具来帮我们实现，另外，我们的业务希望7x24小时在线，如何保障？靠人是很难做到实时的，但编排工具可以，K8s帮我们实现了很多控制器，这控制器可以帮我们监控容器运行的状态，并自动帮我们重建(在容器时代重启就是重建)容器，并且还可以在容器处理能力不足时，自动根据我们定义的扩展规则，自动创建新Pod(k8s中最小单元,每个Pod中可有一个或多个容器)，并且在压力下去后，自动删除Pod等等功能。\n\n","slug":"Kubernetes第一章-组件简介","published":1,"updated":"2020-02-08T03:22:26.522Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rjd000hzd5b32lsc3ew","content":"<h2 id=\"云服务\"><a href=\"#云服务\" class=\"headerlink\" title=\"云服务\"></a>云服务</h2><ul>\n<li>基础设施及服务 [ Infrastructure as a Service ( IAAS ) ]         国内以阿里云为代表</li>\n<li>平台及服务 [ Platform as a Service  ( PAAS ) ]                      以新浪云为代表的的新浪平台套件 Sina SAE</li>\n<li>软件设施及服务 [ SoftWare as a Service (SAAS) ]                以Micaosoft的基础软件构建，Office的B/S套件</li>\n</ul>\n<p>以新浪的SAE服务来说，在申请一个PAAS服务来运行Java相关服务器程序的时候，在向sina云申请一个服务，sina后台接收到以后，会通过后台配置相对应地Java基础环境。但此时不是通过自动化的部署。</p>\n<p>然后出现一些自动运维工具的出现，降低了环境配置的繁琐工作，但是这还不是真正的自动化，随着<strong>Docker</strong>的出现，这些像PAAS服务的自动化才正真实现，所以Docker自然成为PAAS的下一代标准。</p>\n<p>虽然Docker解决了PAAS的容器化的相关问题，但是Docker容器内的相关联通交流映射问提就会显得非常复杂，比如：</p>\n<p>在物理环境下，构建服务器集群使用标准的Tcp访问到对应的主机的数据库服务或者Ngix相关服务这是很简单的事。但我们有很多的物理机被Docker虚拟化为容器以后，物理机上的相应端口和Docker容器的端口通过防火墙进行数据包的传递，同时容器的集群化也是一个很大的问题。</p>\n<h2 id=\"资源管理器\"><a href=\"#资源管理器\" class=\"headerlink\" title=\"资源管理器\"></a>资源管理器</h2><p><img src=\"/2020/02/05/kubernetes-di-yi-zhang-zu-jian-jian-jie/mesos.jpg\" alt></p>\n<h3 id=\"MESOS\"><a href=\"#MESOS\" class=\"headerlink\" title=\"MESOS\"></a>MESOS</h3><p>为了解决容器化集群带来的复杂性问题，MESOS诞生，<a href=\"https://baike.baidu.com/item/Mesos\" target=\"_blank\" rel=\"noopener\">Mesos</a>是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。但是起初他不是为了解决容器化问题而诞生的，而是为了解决资源问题而产生的。但是Mesos只是一个管理平台，并没有很长久的使用。</p>\n<p><img src=\"/2020/02/05/kubernetes-di-yi-zhang-zu-jian-jian-jie/dockerswarm.png\" alt></p>\n<h3 id=\"DockerSwarm\"><a href=\"#DockerSwarm\" class=\"headerlink\" title=\"DockerSwarm\"></a>DockerSwarm</h3><p>Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。目前，Swarm 是 Docker 社区提供的唯一一个原生支持 Docker 集群管理的工具。它可以把多个 Docker 主机组成的系统转换为单一的虚拟 Docker 主机，使得容器可以组成跨主机的子网网络。</p>\n<p>Docker Swarm 是一个为 IT 运维团队提供集群和调度能力的编排工具。用户可以把集群中所有 Docker Engine 整合进一个「虚拟 Engine」的资源池，通过执行命令与单一的主 Swarm 进行沟通，而不必分别和每个 Docker Engine 沟通。在灵活的调度策略下，IT 团队可以更好地管理可用的主机资源，保证应用容器的高效运行。</p>\n<p>实践中会发现，生产环境中使用单个 Docker 节点是远远不够的，搭建 Docker 集群势在必行。然而，面对 Kubernetes, Mesos 以及 Swarm 等众多容器集群系统，我们该如何选择呢？它们之中，Swarm 是 Docker 原生的，同时也是最简单，最易学，最节省资源的，比较适合中小型公司使用。</p>\n<p><img src=\"/2020/02/05/kubernetes-di-yi-zhang-zu-jian-jian-jie/kubernetes.png\" alt></p>\n<h3 id=\"Kubernetes\"><a href=\"#Kubernetes\" class=\"headerlink\" title=\"Kubernetes\"></a>Kubernetes</h3><p>Kubernetes是Google开源的一款容器编排工具，它是诞生在Google内部运行N多年的博格系统之上的产物，因此其成熟度从其诞生初期就广泛受到业界的关注，并且迅速成为编排工具市场的主流，其社区活跃度非常高，版本迭代速度也很惊人，它的主要作用是对Docker容器做编排工作，当然，Docker只是容器工具的一种引擎，K8s可支持多种容器引擎，但从目前来说Docker容器引擎是具有绝对优势的。</p>\n<p>容器需要编排，也很容易理解，因为我们最核心要跑到业务通常都是LNMT/P的不同形式的扩展，但NMT/P他们的运行是有先后顺序的，也就是说MySQL要先启动，然后是Tomcat或PHP，最后是Nginx，而控制这种顺序就需要有容器编排工具来帮我们实现，另外，我们的业务希望7x24小时在线，如何保障？靠人是很难做到实时的，但编排工具可以，K8s帮我们实现了很多控制器，这控制器可以帮我们监控容器运行的状态，并自动帮我们重建(在容器时代重启就是重建)容器，并且还可以在容器处理能力不足时，自动根据我们定义的扩展规则，自动创建新Pod(k8s中最小单元,每个Pod中可有一个或多个容器)，并且在压力下去后，自动删除Pod等等功能。</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<h2 id=\"云服务\"><a href=\"#云服务\" class=\"headerlink\" title=\"云服务\"></a>云服务</h2><ul>\n<li>基础设施及服务 [ Infrastructure as a Service ( IAAS ) ]         国内以阿里云为代表</li>\n<li>平台及服务 [ Platform as a Service  ( PAAS ) ]                      以新浪云为代表的的新浪平台套件 Sina SAE</li>\n<li>软件设施及服务 [ SoftWare as a Service (SAAS) ]                以Micaosoft的基础软件构建，Office的B/S套件</li>\n</ul>\n<p>以新浪的SAE服务来说，在申请一个PAAS服务来运行Java相关服务器程序的时候，在向sina云申请一个服务，sina后台接收到以后，会通过后台配置相对应地Java基础环境。但此时不是通过自动化的部署。</p>\n<p>然后出现一些自动运维工具的出现，降低了环境配置的繁琐工作，但是这还不是真正的自动化，随着<strong>Docker</strong>的出现，这些像PAAS服务的自动化才正真实现，所以Docker自然成为PAAS的下一代标准。</p>\n<p>虽然Docker解决了PAAS的容器化的相关问题，但是Docker容器内的相关联通交流映射问提就会显得非常复杂，比如：</p>\n<p>在物理环境下，构建服务器集群使用标准的Tcp访问到对应的主机的数据库服务或者Ngix相关服务这是很简单的事。但我们有很多的物理机被Docker虚拟化为容器以后，物理机上的相应端口和Docker容器的端口通过防火墙进行数据包的传递，同时容器的集群化也是一个很大的问题。</p>\n<h2 id=\"资源管理器\"><a href=\"#资源管理器\" class=\"headerlink\" title=\"资源管理器\"></a>资源管理器</h2><p><img src=\"/2020/02/05/kubernetes-di-yi-zhang-zu-jian-jian-jie/mesos.jpg\" alt></p>\n<h3 id=\"MESOS\"><a href=\"#MESOS\" class=\"headerlink\" title=\"MESOS\"></a>MESOS</h3><p>为了解决容器化集群带来的复杂性问题，MESOS诞生，<a href=\"https://baike.baidu.com/item/Mesos\" target=\"_blank\" rel=\"noopener\">Mesos</a>是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。但是起初他不是为了解决容器化问题而诞生的，而是为了解决资源问题而产生的。但是Mesos只是一个管理平台，并没有很长久的使用。</p>\n<p><img src=\"/2020/02/05/kubernetes-di-yi-zhang-zu-jian-jian-jie/dockerswarm.png\" alt></p>\n<h3 id=\"DockerSwarm\"><a href=\"#DockerSwarm\" class=\"headerlink\" title=\"DockerSwarm\"></a>DockerSwarm</h3><p>Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。目前，Swarm 是 Docker 社区提供的唯一一个原生支持 Docker 集群管理的工具。它可以把多个 Docker 主机组成的系统转换为单一的虚拟 Docker 主机，使得容器可以组成跨主机的子网网络。</p>\n<p>Docker Swarm 是一个为 IT 运维团队提供集群和调度能力的编排工具。用户可以把集群中所有 Docker Engine 整合进一个「虚拟 Engine」的资源池，通过执行命令与单一的主 Swarm 进行沟通，而不必分别和每个 Docker Engine 沟通。在灵活的调度策略下，IT 团队可以更好地管理可用的主机资源，保证应用容器的高效运行。</p>\n<p>实践中会发现，生产环境中使用单个 Docker 节点是远远不够的，搭建 Docker 集群势在必行。然而，面对 Kubernetes, Mesos 以及 Swarm 等众多容器集群系统，我们该如何选择呢？它们之中，Swarm 是 Docker 原生的，同时也是最简单，最易学，最节省资源的，比较适合中小型公司使用。</p>\n<p><img src=\"/2020/02/05/kubernetes-di-yi-zhang-zu-jian-jian-jie/kubernetes.png\" alt></p>\n<h3 id=\"Kubernetes\"><a href=\"#Kubernetes\" class=\"headerlink\" title=\"Kubernetes\"></a>Kubernetes</h3><p>Kubernetes是Google开源的一款容器编排工具，它是诞生在Google内部运行N多年的博格系统之上的产物，因此其成熟度从其诞生初期就广泛受到业界的关注，并且迅速成为编排工具市场的主流，其社区活跃度非常高，版本迭代速度也很惊人，它的主要作用是对Docker容器做编排工作，当然，Docker只是容器工具的一种引擎，K8s可支持多种容器引擎，但从目前来说Docker容器引擎是具有绝对优势的。</p>\n<p>容器需要编排，也很容易理解，因为我们最核心要跑到业务通常都是LNMT/P的不同形式的扩展，但NMT/P他们的运行是有先后顺序的，也就是说MySQL要先启动，然后是Tomcat或PHP，最后是Nginx，而控制这种顺序就需要有容器编排工具来帮我们实现，另外，我们的业务希望7x24小时在线，如何保障？靠人是很难做到实时的，但编排工具可以，K8s帮我们实现了很多控制器，这控制器可以帮我们监控容器运行的状态，并自动帮我们重建(在容器时代重启就是重建)容器，并且还可以在容器处理能力不足时，自动根据我们定义的扩展规则，自动创建新Pod(k8s中最小单元,每个Pod中可有一个或多个容器)，并且在压力下去后，自动删除Pod等等功能。</p>\n"},{"title":"Hexo博客搭建","date":"2018-01-06T15:39:42.000Z","_content":"\n\n# Hexo背景\n\n写blog虽然经历了N多不同时代的产品，恒久不变的始终是自己无人问津的网站。虽然没几个人看，还是隔断时间就要折腾一下。从最开始的wordpress，到tale，到现在的hexo，网站变得越来越简单，越来越轻量级，这里主要说说hexo的搭建和使用。\n\n## Hexo介绍\n\n[Hexo系统的主页]( https://hexo.io/zh-cn/)有非常详细的介绍，主页中有介绍内容我这里就不赘述了，这里主要说说主页中没有详细说明内容。\n\n- hexo 可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。其中的差别，有点意思。\n- hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。\n\n## Hexo的安装\n\n1. 安装nodejs  \n\n   ```bash\n   sudo su  //切换到管理员\n   npm install -g cnpm --registry=https://registry.npm.taobao.org. //安装cnpm 工具\n   ```\n\n   \n\n2. npm安装hexo博客\n\n   ```bash\n   cnpm install -g hexo-cli\n   ```\n\n3. 创建一个初始化博客的文件夹. pwd 查看当前目录位置 使用\n\n   ```bash\n   mkdir hexoblogs  创建目录\n   ```\n\n   当前目录是 /Usrs/daniel下\n\n4. 使用 cd hexoblogs 进入目录进行博客初始化 :\n\n   ```bash\n   sudo hexo init\n   ```\n\n5. 启动hexo博客 默认是4000端口 \n\n   ```bash\n   hexo s \n   ```\n\n   至此，hexo博客可以正常启动了，可以通过 [本地回路](localhost:4000) 访问博客\n\n   ![](/start.png)\n\n### 博客文件夹的目录结构\n\n- | 文件/文件夹 | 说明                                                  |\n  | ----------- | ----------------------------------------------------- |\n  | _config.yml | 配置文件,用于修改相关的服务器生成配置                 |\n  | public      | 生成的静态文件，这个目录最终会发布到服务器            |\n  | scaffolds   | 一些通用的markdown模板                                |\n  | source      | 编写的markdown文件，_drafts草稿文件，_posts发布的文章 |\n  | themes      | 博客的模板主题                                        |\n\n### Hexo常用命令\n\n- Hexo 创建新的博客\n\n  ```bash\n  hexo n \"博客名字\"\n  ```\n\n  \n\n- Hexo 清除相关记录\n\n  ```bash\n  hexo clean / hexo cl /hexo c 每个都可以\n  ```\n\n  \n\n- Hexo 重新新城相关博客文件\n\n  ```bash\n  hexo g\n  ```\n\n  \n\n- Hexo 启动\n\n  ```bash\n  hexo s\n  ```\n\n\n\n## 博客部署\n\n##### 由于Hexo是静态的博客系统，所以可以通过Github仓库托管并且部署，当然也可以通过国内的码云进行托管，毕竟速度甩Github几条街。当然也可以部署在自己的服务器上面。\n\n- ### Github托管方式\n\n  1. 在自己的仓库里面新建一个response \n\n     ```bash\n     注意：名字是固定的 是自己的  Github名字 + .github.io\n     如 ： NielJun.github.io\n     ```\n\n  2. 在hexoblogs目录下安装git插件\n\n     ```bash\n     命令为： cnpm install --save hexo-deployer-git\n     ```\n\n  3. 然后打开当前目录下面的_config.yml \n\n     ```bash\n     vim _config.yml \n     ```\n\n  4. 在文件底部修改![](/hexo_config.png)\n\n     其中type为git  repo 为创建的仓库地址 branch为master\n\n  5. 最后将本地修改好的博客部署提交到github\n\n     ```bash\n     hexo d\n     ```\n\n  Github部署就完成啦。\n\n- ### Gittee 码云仓库部署\n\n  待更新\n\n- ### **个人服务器部署**  \n\n  ​\t\t步骤其实很简单，就是在自己的服务器上**建一个仓库**，然后通过**nginx反代**，**本地修改提交的目录**即可\n\n1. 通过ssl到自己的后台，我的云服务器是centeros系统，安装git\n\n   ```bash\n   yum install git\n   ```\n\n   \n\n2. 添加git用户\n\n   ```bash\n   useradd git\n   ```\n\n   \n\n3. 重新设置一下git仓库密码，当然不设置的话密码是无效的。\n\n   ```bash\n   passwd git\n   输入两次验证即可更新令牌\n   ```\n\n   \n\n4. 切换到git用户\n\n   ```bash\n   su git\n   ```\n\n   \n\n5. 管理hexo在云服务器上的目录地址： \n\n   ```bash\n   cd /home/git //切换到git目录\n   mkdir -p HexoBlogs \t//新建博客目录\n   mkdir repos && cd repos\t\t\t//新建并进入新建的仓库地址\n   ```\n\n   \n\n6. 新建一个 bare [空的] 仓库\n\n   ```bash\n   git init --bare HexoBlogs  \t\t\t // --bare表示空的\n   cd HexoBlogs/Hooks \t\t\t\t\t\t\t // 进入hooks目录\n   ```\n\n   \n\n7. 编辑（或者是创建) post-receive 文件\n\n   ```bash\n   vim post-receive\n   ```\n\n   ```bash\n   //编辑内容如下\n   #!/bin/sh\n   git \t\t--work-tree=/home/git/HexoBlogs       --git-dir=/home/git/repos/HexoBlogs.git checkout -f\n   ```\n\n   \n\n8. 修改刚刚新建的文件的权限\n\n   ```bash\n   chmod +x post-receive\n   ```\n\n   \n\n9. 退出Hooks\n\n   ```bash\n   exit\n   ```\n\n10. 修改仓库权限\n\n    ```bash\n    chown -R git:git /home/git/repos/HexoBlogs.git/\n    ```\n\n11. 【**测试步骤**】服务器上面的地址新建完成，可以在本地机器上面实验是否可以拉取到Git 中间段是服务器ip\n\n    ```bash\n    git clone git@175.24.15.152:/home/git/repos/HexoBlogs.git test/blogs\n    ```\n\n    \n\n12. **这里插一句，游戏我们的本机和服务器建立的是访客关系每次登陆都需要密码，我们可以建立一个私有关系，让登陆无密码。**[**此部分可跳过 第12步**]\n\n    1. 准备ssh-copy-id\n\n       ```bash\n       brew install ssh-copy-id\n       ```\n\n       \n\n    2. 生成私钥公钥\n\n       ```bash\n       ssh-keygen -t rsa -b 1024\n       ```\n\n       \n\n    3. 将公钥上传致服务器(~/.ssh/authorized_keys)\n\n       ```bash\n       ssh-copy-id -i 公钥 root@175.24.15.152\n       ```\n\n       \n\n    4. 在本地~/.ssh/config文件中添加(如果没有则新建)\n\n       ```bash\n       Host git.oschina.net\n       \n       IdentityFile ~/.ssh/weiwei.sun\n       \n        \n       \n       Host 192.168.50.100\n       \n       IdentityFile ~/.ssh/weiwei.sun\n       ```\n\n       \n\n    **注:** 不过在mac下这里需要 **brew** 附带其安装和卸载吧\n\n    - **安装brew**\n\n    ```bash\n    /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n    ```\n\n    - **卸载brew**\n\n      ```bash\n      /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\n      ```\n\n      \n\n13. 在本地拉取完成以后，直接修改本地hexo的配置\n\n    ```bash\n    # Deployment\n    ## Docs: https://hexo.io/docs/deployment.html\n    deploy:\n      type: git\n      #repo: https://github.com/NielJun/NielJun.github.io.git     //之前的在github上托管\n      repo: git@175.24.15.152:/home/git/repos/HexoBlogs.git\t\t\t\t//放在自己的服务器上\n      branch: master\n    ```\n\n14. 最后一步，nginx反代，关于nginx可以参考我的nignx相关博客。\n\n    ```bash\n    修改的 nginx.config条目\n    \n    \ta.  顶端取消注释修改为  user root  开启权限\n    \tb.\t在server区  server_name 修改为ip\n    \tc.\tserver{location{}} 中间\n    \t\n             location / {\n                      root   /home/git/HexoBlogs/;\n                      #proxy_pass http://175.24.15.152:5897/blogs/NielJun;\n                      index  index.html index.htm;\n                  }\n    \n    \n    ```\n\n    再重新热更配置:\n\n    ```bash\n    nginx -s reload\n    ```\n\n    本地照常修改和生成博客，只是提交以后就是在服务器上自己的git仓库了。\n\n    至此，可以直接用ip/域名访问到[博客](http://www.rubyboy.cn)了，皆大欢喜。\n\n## Hexo换主题\n\n![](/hexothemes.jpg)\n\nhexo更换主题很简单，注需简单的几步：\n\n1. 先找到一个主题的git仓库 如 [hexo-theme-yilia](https://github.com/litten/hexo-theme-yilia.git)\n\n2. 把其拉到themes目录下面 \n\n   ```bash\n   git clone https://github.com/litten/hexo-theme-yilia.git  themes/yilia\n   ```\n\n   \n\n3. 修改_config.yml文件 把其中的them条目改成yilia 保存退出 这个配置文件是博客系统根目录下面的_config.yml\n\n4. 本地预览没问题以后再hexo d 推送到远端\n\n   ```bash\n   hexo clean\n   hexo g\n   hexo s 本地查看\n   hexo d 推送到远端\n   ```\n\n   \n\n   ","source":"_posts/Hexo博客搭建.md","raw":"---\ntitle: Hexo博客搭建\ndate: 2018-01-06 23:39:42\ntags: \ncategories: Go栈\n---\n\n\n# Hexo背景\n\n写blog虽然经历了N多不同时代的产品，恒久不变的始终是自己无人问津的网站。虽然没几个人看，还是隔断时间就要折腾一下。从最开始的wordpress，到tale，到现在的hexo，网站变得越来越简单，越来越轻量级，这里主要说说hexo的搭建和使用。\n\n## Hexo介绍\n\n[Hexo系统的主页]( https://hexo.io/zh-cn/)有非常详细的介绍，主页中有介绍内容我这里就不赘述了，这里主要说说主页中没有详细说明内容。\n\n- hexo 可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。其中的差别，有点意思。\n- hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。\n\n## Hexo的安装\n\n1. 安装nodejs  \n\n   ```bash\n   sudo su  //切换到管理员\n   npm install -g cnpm --registry=https://registry.npm.taobao.org. //安装cnpm 工具\n   ```\n\n   \n\n2. npm安装hexo博客\n\n   ```bash\n   cnpm install -g hexo-cli\n   ```\n\n3. 创建一个初始化博客的文件夹. pwd 查看当前目录位置 使用\n\n   ```bash\n   mkdir hexoblogs  创建目录\n   ```\n\n   当前目录是 /Usrs/daniel下\n\n4. 使用 cd hexoblogs 进入目录进行博客初始化 :\n\n   ```bash\n   sudo hexo init\n   ```\n\n5. 启动hexo博客 默认是4000端口 \n\n   ```bash\n   hexo s \n   ```\n\n   至此，hexo博客可以正常启动了，可以通过 [本地回路](localhost:4000) 访问博客\n\n   ![](/start.png)\n\n### 博客文件夹的目录结构\n\n- | 文件/文件夹 | 说明                                                  |\n  | ----------- | ----------------------------------------------------- |\n  | _config.yml | 配置文件,用于修改相关的服务器生成配置                 |\n  | public      | 生成的静态文件，这个目录最终会发布到服务器            |\n  | scaffolds   | 一些通用的markdown模板                                |\n  | source      | 编写的markdown文件，_drafts草稿文件，_posts发布的文章 |\n  | themes      | 博客的模板主题                                        |\n\n### Hexo常用命令\n\n- Hexo 创建新的博客\n\n  ```bash\n  hexo n \"博客名字\"\n  ```\n\n  \n\n- Hexo 清除相关记录\n\n  ```bash\n  hexo clean / hexo cl /hexo c 每个都可以\n  ```\n\n  \n\n- Hexo 重新新城相关博客文件\n\n  ```bash\n  hexo g\n  ```\n\n  \n\n- Hexo 启动\n\n  ```bash\n  hexo s\n  ```\n\n\n\n## 博客部署\n\n##### 由于Hexo是静态的博客系统，所以可以通过Github仓库托管并且部署，当然也可以通过国内的码云进行托管，毕竟速度甩Github几条街。当然也可以部署在自己的服务器上面。\n\n- ### Github托管方式\n\n  1. 在自己的仓库里面新建一个response \n\n     ```bash\n     注意：名字是固定的 是自己的  Github名字 + .github.io\n     如 ： NielJun.github.io\n     ```\n\n  2. 在hexoblogs目录下安装git插件\n\n     ```bash\n     命令为： cnpm install --save hexo-deployer-git\n     ```\n\n  3. 然后打开当前目录下面的_config.yml \n\n     ```bash\n     vim _config.yml \n     ```\n\n  4. 在文件底部修改![](/hexo_config.png)\n\n     其中type为git  repo 为创建的仓库地址 branch为master\n\n  5. 最后将本地修改好的博客部署提交到github\n\n     ```bash\n     hexo d\n     ```\n\n  Github部署就完成啦。\n\n- ### Gittee 码云仓库部署\n\n  待更新\n\n- ### **个人服务器部署**  \n\n  ​\t\t步骤其实很简单，就是在自己的服务器上**建一个仓库**，然后通过**nginx反代**，**本地修改提交的目录**即可\n\n1. 通过ssl到自己的后台，我的云服务器是centeros系统，安装git\n\n   ```bash\n   yum install git\n   ```\n\n   \n\n2. 添加git用户\n\n   ```bash\n   useradd git\n   ```\n\n   \n\n3. 重新设置一下git仓库密码，当然不设置的话密码是无效的。\n\n   ```bash\n   passwd git\n   输入两次验证即可更新令牌\n   ```\n\n   \n\n4. 切换到git用户\n\n   ```bash\n   su git\n   ```\n\n   \n\n5. 管理hexo在云服务器上的目录地址： \n\n   ```bash\n   cd /home/git //切换到git目录\n   mkdir -p HexoBlogs \t//新建博客目录\n   mkdir repos && cd repos\t\t\t//新建并进入新建的仓库地址\n   ```\n\n   \n\n6. 新建一个 bare [空的] 仓库\n\n   ```bash\n   git init --bare HexoBlogs  \t\t\t // --bare表示空的\n   cd HexoBlogs/Hooks \t\t\t\t\t\t\t // 进入hooks目录\n   ```\n\n   \n\n7. 编辑（或者是创建) post-receive 文件\n\n   ```bash\n   vim post-receive\n   ```\n\n   ```bash\n   //编辑内容如下\n   #!/bin/sh\n   git \t\t--work-tree=/home/git/HexoBlogs       --git-dir=/home/git/repos/HexoBlogs.git checkout -f\n   ```\n\n   \n\n8. 修改刚刚新建的文件的权限\n\n   ```bash\n   chmod +x post-receive\n   ```\n\n   \n\n9. 退出Hooks\n\n   ```bash\n   exit\n   ```\n\n10. 修改仓库权限\n\n    ```bash\n    chown -R git:git /home/git/repos/HexoBlogs.git/\n    ```\n\n11. 【**测试步骤**】服务器上面的地址新建完成，可以在本地机器上面实验是否可以拉取到Git 中间段是服务器ip\n\n    ```bash\n    git clone git@175.24.15.152:/home/git/repos/HexoBlogs.git test/blogs\n    ```\n\n    \n\n12. **这里插一句，游戏我们的本机和服务器建立的是访客关系每次登陆都需要密码，我们可以建立一个私有关系，让登陆无密码。**[**此部分可跳过 第12步**]\n\n    1. 准备ssh-copy-id\n\n       ```bash\n       brew install ssh-copy-id\n       ```\n\n       \n\n    2. 生成私钥公钥\n\n       ```bash\n       ssh-keygen -t rsa -b 1024\n       ```\n\n       \n\n    3. 将公钥上传致服务器(~/.ssh/authorized_keys)\n\n       ```bash\n       ssh-copy-id -i 公钥 root@175.24.15.152\n       ```\n\n       \n\n    4. 在本地~/.ssh/config文件中添加(如果没有则新建)\n\n       ```bash\n       Host git.oschina.net\n       \n       IdentityFile ~/.ssh/weiwei.sun\n       \n        \n       \n       Host 192.168.50.100\n       \n       IdentityFile ~/.ssh/weiwei.sun\n       ```\n\n       \n\n    **注:** 不过在mac下这里需要 **brew** 附带其安装和卸载吧\n\n    - **安装brew**\n\n    ```bash\n    /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n    ```\n\n    - **卸载brew**\n\n      ```bash\n      /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\n      ```\n\n      \n\n13. 在本地拉取完成以后，直接修改本地hexo的配置\n\n    ```bash\n    # Deployment\n    ## Docs: https://hexo.io/docs/deployment.html\n    deploy:\n      type: git\n      #repo: https://github.com/NielJun/NielJun.github.io.git     //之前的在github上托管\n      repo: git@175.24.15.152:/home/git/repos/HexoBlogs.git\t\t\t\t//放在自己的服务器上\n      branch: master\n    ```\n\n14. 最后一步，nginx反代，关于nginx可以参考我的nignx相关博客。\n\n    ```bash\n    修改的 nginx.config条目\n    \n    \ta.  顶端取消注释修改为  user root  开启权限\n    \tb.\t在server区  server_name 修改为ip\n    \tc.\tserver{location{}} 中间\n    \t\n             location / {\n                      root   /home/git/HexoBlogs/;\n                      #proxy_pass http://175.24.15.152:5897/blogs/NielJun;\n                      index  index.html index.htm;\n                  }\n    \n    \n    ```\n\n    再重新热更配置:\n\n    ```bash\n    nginx -s reload\n    ```\n\n    本地照常修改和生成博客，只是提交以后就是在服务器上自己的git仓库了。\n\n    至此，可以直接用ip/域名访问到[博客](http://www.rubyboy.cn)了，皆大欢喜。\n\n## Hexo换主题\n\n![](/hexothemes.jpg)\n\nhexo更换主题很简单，注需简单的几步：\n\n1. 先找到一个主题的git仓库 如 [hexo-theme-yilia](https://github.com/litten/hexo-theme-yilia.git)\n\n2. 把其拉到themes目录下面 \n\n   ```bash\n   git clone https://github.com/litten/hexo-theme-yilia.git  themes/yilia\n   ```\n\n   \n\n3. 修改_config.yml文件 把其中的them条目改成yilia 保存退出 这个配置文件是博客系统根目录下面的_config.yml\n\n4. 本地预览没问题以后再hexo d 推送到远端\n\n   ```bash\n   hexo clean\n   hexo g\n   hexo s 本地查看\n   hexo d 推送到远端\n   ```\n\n   \n\n   ","slug":"Hexo博客搭建","published":1,"updated":"2020-02-08T03:23:35.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rjd000kzd5balr467b9","content":"<h1 id=\"Hexo背景\"><a href=\"#Hexo背景\" class=\"headerlink\" title=\"Hexo背景\"></a>Hexo背景</h1><p>写blog虽然经历了N多不同时代的产品，恒久不变的始终是自己无人问津的网站。虽然没几个人看，还是隔断时间就要折腾一下。从最开始的wordpress，到tale，到现在的hexo，网站变得越来越简单，越来越轻量级，这里主要说说hexo的搭建和使用。</p>\n<h2 id=\"Hexo介绍\"><a href=\"#Hexo介绍\" class=\"headerlink\" title=\"Hexo介绍\"></a>Hexo介绍</h2><p><a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo系统的主页</a>有非常详细的介绍，主页中有介绍内容我这里就不赘述了，这里主要说说主页中没有详细说明内容。</p>\n<ul>\n<li>hexo 可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。其中的差别，有点意思。</li>\n<li>hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。</li>\n</ul>\n<h2 id=\"Hexo的安装\"><a href=\"#Hexo的安装\" class=\"headerlink\" title=\"Hexo的安装\"></a>Hexo的安装</h2><ol>\n<li><p>安装nodejs  </p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">su</span>  //切换到管理员\n<span class=\"token function\">npm</span> <span class=\"token function\">install</span> -g cnpm --registry<span class=\"token operator\">=</span>https://registry.npm.taobao.org. //安装cnpm 工具</code></pre>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>npm安装hexo博客</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">cnpm <span class=\"token function\">install</span> -g hexo-cli</code></pre>\n</li>\n<li><p>创建一个初始化博客的文件夹. pwd 查看当前目录位置 使用</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">mkdir</span> hexoblogs  创建目录</code></pre>\n<p>当前目录是 /Usrs/daniel下</p>\n</li>\n<li><p>使用 cd hexoblogs 进入目录进行博客初始化 :</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> hexo init</code></pre>\n</li>\n<li><p>启动hexo博客 默认是4000端口 </p>\n<pre class=\" language-bash\"><code class=\"language-bash\">hexo s </code></pre>\n<p>至此，hexo博客可以正常启动了，可以通过 <a href=\"localhost:4000\">本地回路</a> 访问博客</p>\n<p><img src=\"/2018/01/06/hexo-bo-ke-da-jian/start.png\" alt></p>\n</li>\n</ol>\n<h3 id=\"博客文件夹的目录结构\"><a href=\"#博客文件夹的目录结构\" class=\"headerlink\" title=\"博客文件夹的目录结构\"></a>博客文件夹的目录结构</h3><ul>\n<li><table>\n<thead>\n<tr>\n<th>文件/文件夹</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>_config.yml</td>\n<td>配置文件,用于修改相关的服务器生成配置</td>\n</tr>\n<tr>\n<td>public</td>\n<td>生成的静态文件，这个目录最终会发布到服务器</td>\n</tr>\n<tr>\n<td>scaffolds</td>\n<td>一些通用的markdown模板</td>\n</tr>\n<tr>\n<td>source</td>\n<td>编写的markdown文件，_drafts草稿文件，_posts发布的文章</td>\n</tr>\n<tr>\n<td>themes</td>\n<td>博客的模板主题</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"Hexo常用命令\"><a href=\"#Hexo常用命令\" class=\"headerlink\" title=\"Hexo常用命令\"></a>Hexo常用命令</h3><ul>\n<li><p>Hexo 创建新的博客</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">hexo n <span class=\"token string\">\"博客名字\"</span></code></pre>\n</li>\n</ul>\n<ul>\n<li><p>Hexo 清除相关记录</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">hexo clean / hexo cl /hexo c 每个都可以</code></pre>\n</li>\n</ul>\n<ul>\n<li><p>Hexo 重新新城相关博客文件</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">hexo g</code></pre>\n</li>\n</ul>\n<ul>\n<li><p>Hexo 启动</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">hexo s</code></pre>\n</li>\n</ul>\n<h2 id=\"博客部署\"><a href=\"#博客部署\" class=\"headerlink\" title=\"博客部署\"></a>博客部署</h2><h5 id=\"由于Hexo是静态的博客系统，所以可以通过Github仓库托管并且部署，当然也可以通过国内的码云进行托管，毕竟速度甩Github几条街。当然也可以部署在自己的服务器上面。\"><a href=\"#由于Hexo是静态的博客系统，所以可以通过Github仓库托管并且部署，当然也可以通过国内的码云进行托管，毕竟速度甩Github几条街。当然也可以部署在自己的服务器上面。\" class=\"headerlink\" title=\"由于Hexo是静态的博客系统，所以可以通过Github仓库托管并且部署，当然也可以通过国内的码云进行托管，毕竟速度甩Github几条街。当然也可以部署在自己的服务器上面。\"></a>由于Hexo是静态的博客系统，所以可以通过Github仓库托管并且部署，当然也可以通过国内的码云进行托管，毕竟速度甩Github几条街。当然也可以部署在自己的服务器上面。</h5><ul>\n<li><h3 id=\"Github托管方式\"><a href=\"#Github托管方式\" class=\"headerlink\" title=\"Github托管方式\"></a>Github托管方式</h3><ol>\n<li><p>在自己的仓库里面新建一个response </p>\n<pre class=\" language-bash\"><code class=\"language-bash\">注意：名字是固定的 是自己的  Github名字 + .github.io\n如 ： NielJun.github.io</code></pre>\n</li>\n<li><p>在hexoblogs目录下安装git插件</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">命令为： cnpm <span class=\"token function\">install</span> --save hexo-deployer-git</code></pre>\n</li>\n<li><p>然后打开当前目录下面的_config.yml </p>\n<pre class=\" language-bash\"><code class=\"language-bash\">vim _config.yml </code></pre>\n</li>\n<li><p>在文件底部修改<img src=\"/2018/01/06/hexo-bo-ke-da-jian/hexo_config.png\" alt></p>\n<p>其中type为git  repo 为创建的仓库地址 branch为master</p>\n</li>\n<li><p>最后将本地修改好的博客部署提交到github</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">hexo d</code></pre>\n</li>\n</ol>\n<p>Github部署就完成啦。</p>\n</li>\n<li><h3 id=\"Gittee-码云仓库部署\"><a href=\"#Gittee-码云仓库部署\" class=\"headerlink\" title=\"Gittee 码云仓库部署\"></a>Gittee 码云仓库部署</h3><p>待更新</p>\n</li>\n<li><h3 id=\"个人服务器部署\"><a href=\"#个人服务器部署\" class=\"headerlink\" title=\"个人服务器部署\"></a><strong>个人服务器部署</strong></h3><p>​        步骤其实很简单，就是在自己的服务器上<strong>建一个仓库</strong>，然后通过<strong>nginx反代</strong>，<strong>本地修改提交的目录</strong>即可</p>\n</li>\n</ul>\n<ol>\n<li><p>通过ssl到自己的后台，我的云服务器是centeros系统，安装git</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">yum <span class=\"token function\">install</span> <span class=\"token function\">git</span></code></pre>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>添加git用户</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">useradd</span> <span class=\"token function\">git</span></code></pre>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>重新设置一下git仓库密码，当然不设置的话密码是无效的。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">passwd</span> <span class=\"token function\">git</span>\n输入两次验证即可更新令牌</code></pre>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>切换到git用户</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">su</span> <span class=\"token function\">git</span></code></pre>\n</li>\n</ol>\n<ol start=\"5\">\n<li><p>管理hexo在云服务器上的目录地址： </p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">cd</span> /home/git //切换到git目录\n<span class=\"token function\">mkdir</span> -p HexoBlogs     //新建博客目录\n<span class=\"token function\">mkdir</span> repos <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">cd</span> repos            //新建并进入新建的仓库地址</code></pre>\n</li>\n</ol>\n<ol start=\"6\">\n<li><p>新建一个 bare [空的] 仓库</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> init --bare HexoBlogs               // --bare表示空的\n<span class=\"token function\">cd</span> HexoBlogs/Hooks                              // 进入hooks目录</code></pre>\n</li>\n</ol>\n<ol start=\"7\">\n<li><p>编辑（或者是创建) post-receive 文件</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">vim post-receive</code></pre>\n<pre class=\" language-bash\"><code class=\"language-bash\">//编辑内容如下\n<span class=\"token comment\" spellcheck=\"true\">#!/bin/sh</span>\n<span class=\"token function\">git</span>         --work-tree<span class=\"token operator\">=</span>/home/git/HexoBlogs       --git-dir<span class=\"token operator\">=</span>/home/git/repos/HexoBlogs.git checkout -f</code></pre>\n</li>\n</ol>\n<ol start=\"8\">\n<li><p>修改刚刚新建的文件的权限</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">chmod</span> +x post-receive</code></pre>\n</li>\n</ol>\n<ol start=\"9\">\n<li><p>退出Hooks</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">exit</span></code></pre>\n</li>\n<li><p>修改仓库权限</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">chown</span> -R git:git /home/git/repos/HexoBlogs.git/</code></pre>\n</li>\n<li><p>【<strong>测试步骤</strong>】服务器上面的地址新建完成，可以在本地机器上面实验是否可以拉取到Git 中间段是服务器ip</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> clone git@175.24.15.152:/home/git/repos/HexoBlogs.git test/blogs</code></pre>\n</li>\n</ol>\n<ol start=\"12\">\n<li><p><strong>这里插一句，游戏我们的本机和服务器建立的是访客关系每次登陆都需要密码，我们可以建立一个私有关系，让登陆无密码。</strong>[<strong>此部分可跳过 第12步</strong>]</p>\n<ol>\n<li><p>准备ssh-copy-id</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">brew <span class=\"token function\">install</span> ssh-copy-id</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<pre><code>2. 生成私钥公钥\n\n   ```bash\n   ssh-keygen -t rsa -b 1024\n   ```\n\n\n\n3. 将公钥上传致服务器(~/.ssh/authorized_keys)\n\n   ```bash\n   ssh-copy-id -i 公钥 root@175.24.15.152\n   ```\n\n\n\n4. 在本地~/.ssh/config文件中添加(如果没有则新建)\n\n   ```bash\n   Host git.oschina.net\n\n   IdentityFile ~/.ssh/weiwei.sun\n\n\n\n   Host 192.168.50.100\n\n   IdentityFile ~/.ssh/weiwei.sun\n   ```\n\n\n\n**注:** 不过在mac下这里需要 **brew** 附带其安装和卸载吧\n\n- **安装brew**\n\n```bash\n/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\n```\n\n- **卸载brew**\n\n  ```bash\n  /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;\n  ```</code></pre><ol start=\"13\">\n<li><p>在本地拉取完成以后，直接修改本地hexo的配置</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># Deployment</span>\n<span class=\"token comment\" spellcheck=\"true\">## Docs: https://hexo.io/docs/deployment.html</span>\ndeploy:\n  type: <span class=\"token function\">git</span>\n  <span class=\"token comment\" spellcheck=\"true\">#repo: https://github.com/NielJun/NielJun.github.io.git     //之前的在github上托管</span>\n  repo: git@175.24.15.152:/home/git/repos/HexoBlogs.git                //放在自己的服务器上\n  branch: master</code></pre>\n</li>\n<li><p>最后一步，nginx反代，关于nginx可以参考我的nignx相关博客。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">修改的 nginx.config条目\n\n    a.  顶端取消注释修改为  user root  开启权限\n    b.    在server区  server_name 修改为ip\n    c.    server<span class=\"token punctuation\">{</span>location<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span> 中间\n\n         location / <span class=\"token punctuation\">{</span>\n                  root   /home/git/HexoBlogs/<span class=\"token punctuation\">;</span>\n                  <span class=\"token comment\" spellcheck=\"true\">#proxy_pass http://175.24.15.152:5897/blogs/NielJun;</span>\n                  index  index.html index.htm<span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span>\n\n</code></pre>\n</li>\n</ol>\n<pre><code>```\n\n再重新热更配置:\n\n```bash\nnginx -s reload\n```\n\n本地照常修改和生成博客，只是提交以后就是在服务器上自己的git仓库了。\n\n至此，可以直接用ip/域名访问到[博客](http://www.rubyboy.cn)了，皆大欢喜。</code></pre><h2 id=\"Hexo换主题\"><a href=\"#Hexo换主题\" class=\"headerlink\" title=\"Hexo换主题\"></a>Hexo换主题</h2><p><img src=\"/2018/01/06/hexo-bo-ke-da-jian/hexothemes.jpg\" alt></p>\n<p>hexo更换主题很简单，注需简单的几步：</p>\n<ol>\n<li><p>先找到一个主题的git仓库 如 <a href=\"https://github.com/litten/hexo-theme-yilia.git\" target=\"_blank\" rel=\"noopener\">hexo-theme-yilia</a></p>\n</li>\n<li><p>把其拉到themes目录下面 </p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> clone https://github.com/litten/hexo-theme-yilia.git  themes/yilia</code></pre>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>修改_config.yml文件 把其中的them条目改成yilia 保存退出 这个配置文件是博客系统根目录下面的_config.yml</p>\n</li>\n<li><p>本地预览没问题以后再hexo d 推送到远端</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">hexo clean\nhexo g\nhexo s 本地查看\nhexo d 推送到远端</code></pre>\n</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<h1 id=\"Hexo背景\"><a href=\"#Hexo背景\" class=\"headerlink\" title=\"Hexo背景\"></a>Hexo背景</h1><p>写blog虽然经历了N多不同时代的产品，恒久不变的始终是自己无人问津的网站。虽然没几个人看，还是隔断时间就要折腾一下。从最开始的wordpress，到tale，到现在的hexo，网站变得越来越简单，越来越轻量级，这里主要说说hexo的搭建和使用。</p>\n<h2 id=\"Hexo介绍\"><a href=\"#Hexo介绍\" class=\"headerlink\" title=\"Hexo介绍\"></a>Hexo介绍</h2><p><a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo系统的主页</a>有非常详细的介绍，主页中有介绍内容我这里就不赘述了，这里主要说说主页中没有详细说明内容。</p>\n<ul>\n<li>hexo 可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。其中的差别，有点意思。</li>\n<li>hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。</li>\n</ul>\n<h2 id=\"Hexo的安装\"><a href=\"#Hexo的安装\" class=\"headerlink\" title=\"Hexo的安装\"></a>Hexo的安装</h2><ol>\n<li><p>安装nodejs  </p>\n<pre><code class=\"bash\">sudo su  //切换到管理员\nnpm install -g cnpm --registry=https://registry.npm.taobao.org. //安装cnpm 工具</code></pre>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>npm安装hexo博客</p>\n<pre><code class=\"bash\">cnpm install -g hexo-cli</code></pre>\n</li>\n<li><p>创建一个初始化博客的文件夹. pwd 查看当前目录位置 使用</p>\n<pre><code class=\"bash\">mkdir hexoblogs  创建目录</code></pre>\n<p>当前目录是 /Usrs/daniel下</p>\n</li>\n<li><p>使用 cd hexoblogs 进入目录进行博客初始化 :</p>\n<pre><code class=\"bash\">sudo hexo init</code></pre>\n</li>\n<li><p>启动hexo博客 默认是4000端口 </p>\n<pre><code class=\"bash\">hexo s </code></pre>\n<p>至此，hexo博客可以正常启动了，可以通过 <a href=\"localhost:4000\">本地回路</a> 访问博客</p>\n<p><img src=\"/2018/01/06/hexo-bo-ke-da-jian/start.png\" alt></p>\n</li>\n</ol>\n<h3 id=\"博客文件夹的目录结构\"><a href=\"#博客文件夹的目录结构\" class=\"headerlink\" title=\"博客文件夹的目录结构\"></a>博客文件夹的目录结构</h3><ul>\n<li><table>\n<thead>\n<tr>\n<th>文件/文件夹</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>_config.yml</td>\n<td>配置文件,用于修改相关的服务器生成配置</td>\n</tr>\n<tr>\n<td>public</td>\n<td>生成的静态文件，这个目录最终会发布到服务器</td>\n</tr>\n<tr>\n<td>scaffolds</td>\n<td>一些通用的markdown模板</td>\n</tr>\n<tr>\n<td>source</td>\n<td>编写的markdown文件，_drafts草稿文件，_posts发布的文章</td>\n</tr>\n<tr>\n<td>themes</td>\n<td>博客的模板主题</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"Hexo常用命令\"><a href=\"#Hexo常用命令\" class=\"headerlink\" title=\"Hexo常用命令\"></a>Hexo常用命令</h3><ul>\n<li><p>Hexo 创建新的博客</p>\n<pre><code class=\"bash\">hexo n &quot;博客名字&quot;</code></pre>\n</li>\n</ul>\n<ul>\n<li><p>Hexo 清除相关记录</p>\n<pre><code class=\"bash\">hexo clean / hexo cl /hexo c 每个都可以</code></pre>\n</li>\n</ul>\n<ul>\n<li><p>Hexo 重新新城相关博客文件</p>\n<pre><code class=\"bash\">hexo g</code></pre>\n</li>\n</ul>\n<ul>\n<li><p>Hexo 启动</p>\n<pre><code class=\"bash\">hexo s</code></pre>\n</li>\n</ul>\n<h2 id=\"博客部署\"><a href=\"#博客部署\" class=\"headerlink\" title=\"博客部署\"></a>博客部署</h2><h5 id=\"由于Hexo是静态的博客系统，所以可以通过Github仓库托管并且部署，当然也可以通过国内的码云进行托管，毕竟速度甩Github几条街。当然也可以部署在自己的服务器上面。\"><a href=\"#由于Hexo是静态的博客系统，所以可以通过Github仓库托管并且部署，当然也可以通过国内的码云进行托管，毕竟速度甩Github几条街。当然也可以部署在自己的服务器上面。\" class=\"headerlink\" title=\"由于Hexo是静态的博客系统，所以可以通过Github仓库托管并且部署，当然也可以通过国内的码云进行托管，毕竟速度甩Github几条街。当然也可以部署在自己的服务器上面。\"></a>由于Hexo是静态的博客系统，所以可以通过Github仓库托管并且部署，当然也可以通过国内的码云进行托管，毕竟速度甩Github几条街。当然也可以部署在自己的服务器上面。</h5><ul>\n<li><h3 id=\"Github托管方式\"><a href=\"#Github托管方式\" class=\"headerlink\" title=\"Github托管方式\"></a>Github托管方式</h3><ol>\n<li><p>在自己的仓库里面新建一个response </p>\n<pre><code class=\"bash\">注意：名字是固定的 是自己的  Github名字 + .github.io\n如 ： NielJun.github.io</code></pre>\n</li>\n<li><p>在hexoblogs目录下安装git插件</p>\n<pre><code class=\"bash\">命令为： cnpm install --save hexo-deployer-git</code></pre>\n</li>\n<li><p>然后打开当前目录下面的_config.yml </p>\n<pre><code class=\"bash\">vim _config.yml </code></pre>\n</li>\n<li><p>在文件底部修改<img src=\"/2018/01/06/hexo-bo-ke-da-jian/hexo_config.png\" alt></p>\n<p>其中type为git  repo 为创建的仓库地址 branch为master</p>\n</li>\n<li><p>最后将本地修改好的博客部署提交到github</p>\n<pre><code class=\"bash\">hexo d</code></pre>\n</li>\n</ol>\n<p>Github部署就完成啦。</p>\n</li>\n<li><h3 id=\"Gittee-码云仓库部署\"><a href=\"#Gittee-码云仓库部署\" class=\"headerlink\" title=\"Gittee 码云仓库部署\"></a>Gittee 码云仓库部署</h3><p>待更新</p>\n</li>\n<li><h3 id=\"个人服务器部署\"><a href=\"#个人服务器部署\" class=\"headerlink\" title=\"个人服务器部署\"></a><strong>个人服务器部署</strong></h3><p>​        步骤其实很简单，就是在自己的服务器上<strong>建一个仓库</strong>，然后通过<strong>nginx反代</strong>，<strong>本地修改提交的目录</strong>即可</p>\n</li>\n</ul>\n<ol>\n<li><p>通过ssl到自己的后台，我的云服务器是centeros系统，安装git</p>\n<pre><code class=\"bash\">yum install git</code></pre>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>添加git用户</p>\n<pre><code class=\"bash\">useradd git</code></pre>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>重新设置一下git仓库密码，当然不设置的话密码是无效的。</p>\n<pre><code class=\"bash\">passwd git\n输入两次验证即可更新令牌</code></pre>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>切换到git用户</p>\n<pre><code class=\"bash\">su git</code></pre>\n</li>\n</ol>\n<ol start=\"5\">\n<li><p>管理hexo在云服务器上的目录地址： </p>\n<pre><code class=\"bash\">cd /home/git //切换到git目录\nmkdir -p HexoBlogs     //新建博客目录\nmkdir repos &amp;&amp; cd repos            //新建并进入新建的仓库地址</code></pre>\n</li>\n</ol>\n<ol start=\"6\">\n<li><p>新建一个 bare [空的] 仓库</p>\n<pre><code class=\"bash\">git init --bare HexoBlogs               // --bare表示空的\ncd HexoBlogs/Hooks                              // 进入hooks目录</code></pre>\n</li>\n</ol>\n<ol start=\"7\">\n<li><p>编辑（或者是创建) post-receive 文件</p>\n<pre><code class=\"bash\">vim post-receive</code></pre>\n<pre><code class=\"bash\">//编辑内容如下\n#!/bin/sh\ngit         --work-tree=/home/git/HexoBlogs       --git-dir=/home/git/repos/HexoBlogs.git checkout -f</code></pre>\n</li>\n</ol>\n<ol start=\"8\">\n<li><p>修改刚刚新建的文件的权限</p>\n<pre><code class=\"bash\">chmod +x post-receive</code></pre>\n</li>\n</ol>\n<ol start=\"9\">\n<li><p>退出Hooks</p>\n<pre><code class=\"bash\">exit</code></pre>\n</li>\n<li><p>修改仓库权限</p>\n<pre><code class=\"bash\">chown -R git:git /home/git/repos/HexoBlogs.git/</code></pre>\n</li>\n<li><p>【<strong>测试步骤</strong>】服务器上面的地址新建完成，可以在本地机器上面实验是否可以拉取到Git 中间段是服务器ip</p>\n<pre><code class=\"bash\">git clone git@175.24.15.152:/home/git/repos/HexoBlogs.git test/blogs</code></pre>\n</li>\n</ol>\n<ol start=\"12\">\n<li><p><strong>这里插一句，游戏我们的本机和服务器建立的是访客关系每次登陆都需要密码，我们可以建立一个私有关系，让登陆无密码。</strong>[<strong>此部分可跳过 第12步</strong>]</p>\n<ol>\n<li><p>准备ssh-copy-id</p>\n<pre><code class=\"bash\">brew install ssh-copy-id</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<pre><code>2. 生成私钥公钥\n\n   ```bash\n   ssh-keygen -t rsa -b 1024\n   ```\n\n\n\n3. 将公钥上传致服务器(~/.ssh/authorized_keys)\n\n   ```bash\n   ssh-copy-id -i 公钥 root@175.24.15.152\n   ```\n\n\n\n4. 在本地~/.ssh/config文件中添加(如果没有则新建)\n\n   ```bash\n   Host git.oschina.net\n\n   IdentityFile ~/.ssh/weiwei.sun\n\n\n\n   Host 192.168.50.100\n\n   IdentityFile ~/.ssh/weiwei.sun\n   ```\n\n\n\n**注:** 不过在mac下这里需要 **brew** 附带其安装和卸载吧\n\n- **安装brew**\n\n```bash\n/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\n```\n\n- **卸载brew**\n\n  ```bash\n  /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;\n  ```</code></pre><ol start=\"13\">\n<li><p>在本地拉取完成以后，直接修改本地hexo的配置</p>\n<pre><code class=\"bash\"># Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  #repo: https://github.com/NielJun/NielJun.github.io.git     //之前的在github上托管\n  repo: git@175.24.15.152:/home/git/repos/HexoBlogs.git                //放在自己的服务器上\n  branch: master</code></pre>\n</li>\n<li><p>最后一步，nginx反代，关于nginx可以参考我的nignx相关博客。</p>\n<pre><code class=\"bash\">修改的 nginx.config条目\n\n    a.  顶端取消注释修改为  user root  开启权限\n    b.    在server区  server_name 修改为ip\n    c.    server{location{}} 中间\n\n         location / {\n                  root   /home/git/HexoBlogs/;\n                  #proxy_pass http://175.24.15.152:5897/blogs/NielJun;\n                  index  index.html index.htm;\n              }\n\n</code></pre>\n</li>\n</ol>\n<pre><code>```\n\n再重新热更配置:\n\n```bash\nnginx -s reload\n```\n\n本地照常修改和生成博客，只是提交以后就是在服务器上自己的git仓库了。\n\n至此，可以直接用ip/域名访问到[博客](http://www.rubyboy.cn)了，皆大欢喜。</code></pre><h2 id=\"Hexo换主题\"><a href=\"#Hexo换主题\" class=\"headerlink\" title=\"Hexo换主题\"></a>Hexo换主题</h2><p><img src=\"/2018/01/06/hexo-bo-ke-da-jian/hexothemes.jpg\" alt></p>\n<p>hexo更换主题很简单，注需简单的几步：</p>\n<ol>\n<li><p>先找到一个主题的git仓库 如 <a href=\"https://github.com/litten/hexo-theme-yilia.git\" target=\"_blank\" rel=\"noopener\">hexo-theme-yilia</a></p>\n</li>\n<li><p>把其拉到themes目录下面 </p>\n<pre><code class=\"bash\">git clone https://github.com/litten/hexo-theme-yilia.git  themes/yilia</code></pre>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>修改_config.yml文件 把其中的them条目改成yilia 保存退出 这个配置文件是博客系统根目录下面的_config.yml</p>\n</li>\n<li><p>本地预览没问题以后再hexo d 推送到远端</p>\n<pre><code class=\"bash\">hexo clean\nhexo g\nhexo s 本地查看\nhexo d 推送到远端</code></pre>\n</li>\n</ol>\n"},{"title":"Mac设置文件权限问题","date":"2020-02-08T02:35:21.000Z","_content":"\n### Mac设置文件权限的问题\n\n​\t\t在使用mac时，经常我们遇到相关文件不能使用的情况，其实大多数情况都是，文件权限问题。\n\n　　文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件 作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的 任何组合。\n\n​\t\t比如使用Hexo生成博客文件的时候，在Mac上默认是只读的文件。\n\n![](/1.png)\n\n我们可以右键在简介里面修改，但是很繁琐。这里介绍一个权限命令可以一键修改，方便有用到的人使用。\n\nmac设置文件夹权限\n\n```\nchmod -R 777 testfile\n```\n\n　　设置文件权限\n\n```\nchmod 777 txt.txt\n```\n\n　　\n\n　　1，禁止.DS_store生成：打开  “终端” ，复制黏贴下面的命令，回车执行，重启Mac即可生效。　　\n\n　　禁止.DS_store 会导致文件信息记录丢失。\n\n```\ndefaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE\n```\n\n　　2，恢复.DS_store生成：\n\n```\ndefaults delete com.apple.desktopservices DSDontWriteNetworkStores\n```\n\n \n\n　　删除文件 rm file  只是删除文件夹里面没有嵌套文件夹 rm -r folder   反之则 rm -rf folder　　","source":"_posts/Mac设置文件权限问题.md","raw":"---\ntitle: Mac设置文件权限问题\ndate: 2020-02-08 10:35:21\ntags: [Mac,文件权限]\ncategories: Tips\n---\n\n### Mac设置文件权限的问题\n\n​\t\t在使用mac时，经常我们遇到相关文件不能使用的情况，其实大多数情况都是，文件权限问题。\n\n　　文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件 作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的 任何组合。\n\n​\t\t比如使用Hexo生成博客文件的时候，在Mac上默认是只读的文件。\n\n![](/1.png)\n\n我们可以右键在简介里面修改，但是很繁琐。这里介绍一个权限命令可以一键修改，方便有用到的人使用。\n\nmac设置文件夹权限\n\n```\nchmod -R 777 testfile\n```\n\n　　设置文件权限\n\n```\nchmod 777 txt.txt\n```\n\n　　\n\n　　1，禁止.DS_store生成：打开  “终端” ，复制黏贴下面的命令，回车执行，重启Mac即可生效。　　\n\n　　禁止.DS_store 会导致文件信息记录丢失。\n\n```\ndefaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE\n```\n\n　　2，恢复.DS_store生成：\n\n```\ndefaults delete com.apple.desktopservices DSDontWriteNetworkStores\n```\n\n \n\n　　删除文件 rm file  只是删除文件夹里面没有嵌套文件夹 rm -r folder   反之则 rm -rf folder　　","slug":"Mac设置文件权限问题","published":1,"updated":"2020-02-08T02:59:52.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rjf000ozd5berps0dwe","content":"<h3 id=\"Mac设置文件权限的问题\"><a href=\"#Mac设置文件权限的问题\" class=\"headerlink\" title=\"Mac设置文件权限的问题\"></a>Mac设置文件权限的问题</h3><p>​        在使用mac时，经常我们遇到相关文件不能使用的情况，其实大多数情况都是，文件权限问题。</p>\n<p>　　文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件 作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的 任何组合。</p>\n<p>​        比如使用Hexo生成博客文件的时候，在Mac上默认是只读的文件。</p>\n<p><img src=\"/2020/02/08/mac-she-zhi-wen-jian-quan-xian-wen-ti/1.png\" alt></p>\n<p>我们可以右键在简介里面修改，但是很繁琐。这里介绍一个权限命令可以一键修改，方便有用到的人使用。</p>\n<p>mac设置文件夹权限</p>\n<pre><code>chmod -R 777 testfile</code></pre><p>　　设置文件权限</p>\n<pre><code>chmod 777 txt.txt</code></pre><p>　　</p>\n<p>　　1，禁止.DS_store生成：打开  “终端” ，复制黏贴下面的命令，回车执行，重启Mac即可生效。　　</p>\n<p>　　禁止.DS_store 会导致文件信息记录丢失。</p>\n<pre><code>defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE</code></pre><p>　　2，恢复.DS_store生成：</p>\n<pre><code>defaults delete com.apple.desktopservices DSDontWriteNetworkStores</code></pre><p>　　删除文件 rm file  只是删除文件夹里面没有嵌套文件夹 rm -r folder   反之则 rm -rf folder　　</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<h3 id=\"Mac设置文件权限的问题\"><a href=\"#Mac设置文件权限的问题\" class=\"headerlink\" title=\"Mac设置文件权限的问题\"></a>Mac设置文件权限的问题</h3><p>​        在使用mac时，经常我们遇到相关文件不能使用的情况，其实大多数情况都是，文件权限问题。</p>\n<p>　　文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件 作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的 任何组合。</p>\n<p>​        比如使用Hexo生成博客文件的时候，在Mac上默认是只读的文件。</p>\n<p><img src=\"/2020/02/08/mac-she-zhi-wen-jian-quan-xian-wen-ti/1.png\" alt></p>\n<p>我们可以右键在简介里面修改，但是很繁琐。这里介绍一个权限命令可以一键修改，方便有用到的人使用。</p>\n<p>mac设置文件夹权限</p>\n<pre><code>chmod -R 777 testfile</code></pre><p>　　设置文件权限</p>\n<pre><code>chmod 777 txt.txt</code></pre><p>　　</p>\n<p>　　1，禁止.DS_store生成：打开  “终端” ，复制黏贴下面的命令，回车执行，重启Mac即可生效。　　</p>\n<p>　　禁止.DS_store 会导致文件信息记录丢失。</p>\n<pre><code>defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE</code></pre><p>　　2，恢复.DS_store生成：</p>\n<pre><code>defaults delete com.apple.desktopservices DSDontWriteNetworkStores</code></pre><p>　　删除文件 rm file  只是删除文件夹里面没有嵌套文件夹 rm -r folder   反之则 rm -rf folder　　</p>\n"},{"title":"ShaderGraph学习之二 让粒子更亮","date":"2020-01-24T10:49:07.000Z","_content":"","source":"_posts/ShaderGraph学习之二-让粒子更亮.md","raw":"---\ntitle: ShaderGraph学习之二 让粒子更亮\ndate: 2020-01-24 18:49:07\ntags:\ncategories: 游戏栈\n---\n","slug":"ShaderGraph学习之二-让粒子更亮","published":1,"updated":"2020-01-24T10:54:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rjf000qzd5bhbys4j2l","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":""},{"title":"Nginx服务器之一 安装","_content":"​      \t\t\t\t![](/nginx.jpg)\n\n> Nginx是一款轻量级的Web 服务器反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。\n\n## nginx安装\n\n- 推荐使用官网的压缩包解压再上传到linux进行安装\n\n###  进入 /usr/local/sbin/目录\n\n``` bash\n$ cd  /usr/local/sbin/\n```\n\n### 安装相关依赖\n\n``` bash\n$ yum -y install make zlib-devel gcc-c++ libtool  openssl openssl-devel\n```\n\n### 官网下载相关的linux安装包\n\n[Nginx官网](http://nginx.org/en/download.html)\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### 在linux上进入\n\n``` bash\n$ cd /usr/local/src/\n```\n\n### 然后把压缩包解压，解压命令如下\n\n```bash\n tar -xvf nginx-1.17.7.tar\n```\n\n### 执行./nginx 启动nginx服务 启动完成以后 查看linux进程查看相关nginx启动情况\n\n```bash\n ps -ef | grep —nginx\n```\n\n![Nginx后台进程](/bash.png)\n\n### 由于nginx默认的是80端口 所以我们可以直接访问ip地址看nginx是否启动成功浏览器打开ip: 175.24.15.152 出现如下 则表示启动成功\n\n![Nginx初次启动成功](/start.png)\n\n### 由于很多的linux系统的端口是被防火墙关闭的 所以我们得带开或者查看当前端口的情况\n\n#### 显示所有的端口情况\n\n```bash\nfirewall-cmd - -list -all \n```\n\n####  开启防火墙的8001端口\n\n```bash\nsudo firewall-cmd - -add-port=8001/tcp —permanent\n```\n\n#### 重启防火墙修改才生效\n\n```bash\nfirewall-cmd-reload \n```\n\n### Nginx 操作的常用命令\n\n#### 注意:使用命令先要进入 /usr/local/nginx/sbin/ 目录才可使用\n\n- 查看版本号\n\n  ```bash\n   ./nginx -v\n  ```\n\n  \n\n- 关闭nginx\n\n  ```bash\n  ./nginx -s  stop \n  ```\n\n  \n\n- 启动 nginx\n\n  ```bash\n  ./nginx\t\t\n  ```\n\n  \n\n- 修改了配置文件[ conf/nginx.conf ]后,无需重启服务器及生效的命令 [ 重加载命令 ]\n\n  ```\n  ./nginx -s reload\n  ```\n\n  \n\n\n\n","source":"_posts/Nginx安装.md","raw":"---\ntitle: Nginx服务器之一 安装\ntags: [Go,服务端开发,Ngix]\ncategories: Go栈\n---\n​      \t\t\t\t![](/nginx.jpg)\n\n> Nginx是一款轻量级的Web 服务器反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。\n\n## nginx安装\n\n- 推荐使用官网的压缩包解压再上传到linux进行安装\n\n###  进入 /usr/local/sbin/目录\n\n``` bash\n$ cd  /usr/local/sbin/\n```\n\n### 安装相关依赖\n\n``` bash\n$ yum -y install make zlib-devel gcc-c++ libtool  openssl openssl-devel\n```\n\n### 官网下载相关的linux安装包\n\n[Nginx官网](http://nginx.org/en/download.html)\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### 在linux上进入\n\n``` bash\n$ cd /usr/local/src/\n```\n\n### 然后把压缩包解压，解压命令如下\n\n```bash\n tar -xvf nginx-1.17.7.tar\n```\n\n### 执行./nginx 启动nginx服务 启动完成以后 查看linux进程查看相关nginx启动情况\n\n```bash\n ps -ef | grep —nginx\n```\n\n![Nginx后台进程](/bash.png)\n\n### 由于nginx默认的是80端口 所以我们可以直接访问ip地址看nginx是否启动成功浏览器打开ip: 175.24.15.152 出现如下 则表示启动成功\n\n![Nginx初次启动成功](/start.png)\n\n### 由于很多的linux系统的端口是被防火墙关闭的 所以我们得带开或者查看当前端口的情况\n\n#### 显示所有的端口情况\n\n```bash\nfirewall-cmd - -list -all \n```\n\n####  开启防火墙的8001端口\n\n```bash\nsudo firewall-cmd - -add-port=8001/tcp —permanent\n```\n\n#### 重启防火墙修改才生效\n\n```bash\nfirewall-cmd-reload \n```\n\n### Nginx 操作的常用命令\n\n#### 注意:使用命令先要进入 /usr/local/nginx/sbin/ 目录才可使用\n\n- 查看版本号\n\n  ```bash\n   ./nginx -v\n  ```\n\n  \n\n- 关闭nginx\n\n  ```bash\n  ./nginx -s  stop \n  ```\n\n  \n\n- 启动 nginx\n\n  ```bash\n  ./nginx\t\t\n  ```\n\n  \n\n- 修改了配置文件[ conf/nginx.conf ]后,无需重启服务器及生效的命令 [ 重加载命令 ]\n\n  ```\n  ./nginx -s reload\n  ```\n\n  \n\n\n\n","slug":"Nginx安装","published":1,"date":"2020-01-07T07:28:10.000Z","updated":"2020-02-07T05:33:41.776Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rjh000uzd5bh7h46q9h","content":"<p>​                      <img src=\"/2020/01/07/nginx-an-zhuang/nginx.jpg\" alt></p>\n<blockquote>\n<p>Nginx是一款轻量级的Web 服务器反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。</p>\n</blockquote>\n<h2 id=\"nginx安装\"><a href=\"#nginx安装\" class=\"headerlink\" title=\"nginx安装\"></a>nginx安装</h2><ul>\n<li>推荐使用官网的压缩包解压再上传到linux进行安装</li>\n</ul>\n<h3 id=\"进入-usr-local-sbin-目录\"><a href=\"#进入-usr-local-sbin-目录\" class=\"headerlink\" title=\"进入 /usr/local/sbin/目录\"></a>进入 /usr/local/sbin/目录</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cd</span>  /usr/local/sbin/</code></pre>\n<h3 id=\"安装相关依赖\"><a href=\"#安装相关依赖\" class=\"headerlink\" title=\"安装相关依赖\"></a>安装相关依赖</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ yum -y <span class=\"token function\">install</span> <span class=\"token function\">make</span> zlib-devel gcc-c++ libtool  openssl openssl-devel</code></pre>\n<h3 id=\"官网下载相关的linux安装包\"><a href=\"#官网下载相关的linux安装包\" class=\"headerlink\" title=\"官网下载相关的linux安装包\"></a>官网下载相关的linux安装包</h3><p><a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener\">Nginx官网</a></p>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"在linux上进入\"><a href=\"#在linux上进入\" class=\"headerlink\" title=\"在linux上进入\"></a>在linux上进入</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cd</span> /usr/local/src/</code></pre>\n<h3 id=\"然后把压缩包解压，解压命令如下\"><a href=\"#然后把压缩包解压，解压命令如下\" class=\"headerlink\" title=\"然后把压缩包解压，解压命令如下\"></a>然后把压缩包解压，解压命令如下</h3><pre class=\" language-bash\"><code class=\"language-bash\"> <span class=\"token function\">tar</span> -xvf nginx-1.17.7.tar</code></pre>\n<h3 id=\"执行-nginx-启动nginx服务-启动完成以后-查看linux进程查看相关nginx启动情况\"><a href=\"#执行-nginx-启动nginx服务-启动完成以后-查看linux进程查看相关nginx启动情况\" class=\"headerlink\" title=\"执行./nginx 启动nginx服务 启动完成以后 查看linux进程查看相关nginx启动情况\"></a>执行./nginx 启动nginx服务 启动完成以后 查看linux进程查看相关nginx启动情况</h3><pre class=\" language-bash\"><code class=\"language-bash\"> <span class=\"token function\">ps</span> -ef <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> —nginx</code></pre>\n<p><img src=\"/2020/01/07/nginx-an-zhuang/bash.png\" alt=\"Nginx后台进程\"></p>\n<h3 id=\"由于nginx默认的是80端口-所以我们可以直接访问ip地址看nginx是否启动成功浏览器打开ip-175-24-15-152-出现如下-则表示启动成功\"><a href=\"#由于nginx默认的是80端口-所以我们可以直接访问ip地址看nginx是否启动成功浏览器打开ip-175-24-15-152-出现如下-则表示启动成功\" class=\"headerlink\" title=\"由于nginx默认的是80端口 所以我们可以直接访问ip地址看nginx是否启动成功浏览器打开ip: 175.24.15.152 出现如下 则表示启动成功\"></a>由于nginx默认的是80端口 所以我们可以直接访问ip地址看nginx是否启动成功浏览器打开ip: 175.24.15.152 出现如下 则表示启动成功</h3><p><img src=\"/2020/01/07/nginx-an-zhuang/start.png\" alt=\"Nginx初次启动成功\"></p>\n<h3 id=\"由于很多的linux系统的端口是被防火墙关闭的-所以我们得带开或者查看当前端口的情况\"><a href=\"#由于很多的linux系统的端口是被防火墙关闭的-所以我们得带开或者查看当前端口的情况\" class=\"headerlink\" title=\"由于很多的linux系统的端口是被防火墙关闭的 所以我们得带开或者查看当前端口的情况\"></a>由于很多的linux系统的端口是被防火墙关闭的 所以我们得带开或者查看当前端口的情况</h3><h4 id=\"显示所有的端口情况\"><a href=\"#显示所有的端口情况\" class=\"headerlink\" title=\"显示所有的端口情况\"></a>显示所有的端口情况</h4><pre class=\" language-bash\"><code class=\"language-bash\">firewall-cmd - -list -all </code></pre>\n<h4 id=\"开启防火墙的8001端口\"><a href=\"#开启防火墙的8001端口\" class=\"headerlink\" title=\"开启防火墙的8001端口\"></a>开启防火墙的8001端口</h4><pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> firewall-cmd - -add-port<span class=\"token operator\">=</span>8001/tcp —permanent</code></pre>\n<h4 id=\"重启防火墙修改才生效\"><a href=\"#重启防火墙修改才生效\" class=\"headerlink\" title=\"重启防火墙修改才生效\"></a>重启防火墙修改才生效</h4><pre class=\" language-bash\"><code class=\"language-bash\">firewall-cmd-reload </code></pre>\n<h3 id=\"Nginx-操作的常用命令\"><a href=\"#Nginx-操作的常用命令\" class=\"headerlink\" title=\"Nginx 操作的常用命令\"></a>Nginx 操作的常用命令</h3><h4 id=\"注意-使用命令先要进入-usr-local-nginx-sbin-目录才可使用\"><a href=\"#注意-使用命令先要进入-usr-local-nginx-sbin-目录才可使用\" class=\"headerlink\" title=\"注意:使用命令先要进入 /usr/local/nginx/sbin/ 目录才可使用\"></a>注意:使用命令先要进入 /usr/local/nginx/sbin/ 目录才可使用</h4><ul>\n<li><p>查看版本号</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"> ./nginx -v</code></pre>\n</li>\n</ul>\n<ul>\n<li><p>关闭nginx</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">./nginx -s  stop </code></pre>\n</li>\n</ul>\n<ul>\n<li><p>启动 nginx</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">./nginx        </code></pre>\n</li>\n</ul>\n<ul>\n<li><p>修改了配置文件[ conf/nginx.conf ]后,无需重启服务器及生效的命令 [ 重加载命令 ]</p>\n<pre><code>./nginx -s reload</code></pre></li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<p>​                      <img src=\"/2020/01/07/nginx-an-zhuang/nginx.jpg\" alt></p>\n<blockquote>\n<p>Nginx是一款轻量级的Web 服务器反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。</p>\n</blockquote>\n<h2 id=\"nginx安装\"><a href=\"#nginx安装\" class=\"headerlink\" title=\"nginx安装\"></a>nginx安装</h2><ul>\n<li>推荐使用官网的压缩包解压再上传到linux进行安装</li>\n</ul>\n<h3 id=\"进入-usr-local-sbin-目录\"><a href=\"#进入-usr-local-sbin-目录\" class=\"headerlink\" title=\"进入 /usr/local/sbin/目录\"></a>进入 /usr/local/sbin/目录</h3><pre><code class=\"bash\">$ cd  /usr/local/sbin/</code></pre>\n<h3 id=\"安装相关依赖\"><a href=\"#安装相关依赖\" class=\"headerlink\" title=\"安装相关依赖\"></a>安装相关依赖</h3><pre><code class=\"bash\">$ yum -y install make zlib-devel gcc-c++ libtool  openssl openssl-devel</code></pre>\n<h3 id=\"官网下载相关的linux安装包\"><a href=\"#官网下载相关的linux安装包\" class=\"headerlink\" title=\"官网下载相关的linux安装包\"></a>官网下载相关的linux安装包</h3><p><a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener\">Nginx官网</a></p>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"在linux上进入\"><a href=\"#在linux上进入\" class=\"headerlink\" title=\"在linux上进入\"></a>在linux上进入</h3><pre><code class=\"bash\">$ cd /usr/local/src/</code></pre>\n<h3 id=\"然后把压缩包解压，解压命令如下\"><a href=\"#然后把压缩包解压，解压命令如下\" class=\"headerlink\" title=\"然后把压缩包解压，解压命令如下\"></a>然后把压缩包解压，解压命令如下</h3><pre><code class=\"bash\"> tar -xvf nginx-1.17.7.tar</code></pre>\n<h3 id=\"执行-nginx-启动nginx服务-启动完成以后-查看linux进程查看相关nginx启动情况\"><a href=\"#执行-nginx-启动nginx服务-启动完成以后-查看linux进程查看相关nginx启动情况\" class=\"headerlink\" title=\"执行./nginx 启动nginx服务 启动完成以后 查看linux进程查看相关nginx启动情况\"></a>执行./nginx 启动nginx服务 启动完成以后 查看linux进程查看相关nginx启动情况</h3><pre><code class=\"bash\"> ps -ef | grep —nginx</code></pre>\n<p><img src=\"/2020/01/07/nginx-an-zhuang/bash.png\" alt=\"Nginx后台进程\"></p>\n<h3 id=\"由于nginx默认的是80端口-所以我们可以直接访问ip地址看nginx是否启动成功浏览器打开ip-175-24-15-152-出现如下-则表示启动成功\"><a href=\"#由于nginx默认的是80端口-所以我们可以直接访问ip地址看nginx是否启动成功浏览器打开ip-175-24-15-152-出现如下-则表示启动成功\" class=\"headerlink\" title=\"由于nginx默认的是80端口 所以我们可以直接访问ip地址看nginx是否启动成功浏览器打开ip: 175.24.15.152 出现如下 则表示启动成功\"></a>由于nginx默认的是80端口 所以我们可以直接访问ip地址看nginx是否启动成功浏览器打开ip: 175.24.15.152 出现如下 则表示启动成功</h3><p><img src=\"/2020/01/07/nginx-an-zhuang/start.png\" alt=\"Nginx初次启动成功\"></p>\n<h3 id=\"由于很多的linux系统的端口是被防火墙关闭的-所以我们得带开或者查看当前端口的情况\"><a href=\"#由于很多的linux系统的端口是被防火墙关闭的-所以我们得带开或者查看当前端口的情况\" class=\"headerlink\" title=\"由于很多的linux系统的端口是被防火墙关闭的 所以我们得带开或者查看当前端口的情况\"></a>由于很多的linux系统的端口是被防火墙关闭的 所以我们得带开或者查看当前端口的情况</h3><h4 id=\"显示所有的端口情况\"><a href=\"#显示所有的端口情况\" class=\"headerlink\" title=\"显示所有的端口情况\"></a>显示所有的端口情况</h4><pre><code class=\"bash\">firewall-cmd - -list -all </code></pre>\n<h4 id=\"开启防火墙的8001端口\"><a href=\"#开启防火墙的8001端口\" class=\"headerlink\" title=\"开启防火墙的8001端口\"></a>开启防火墙的8001端口</h4><pre><code class=\"bash\">sudo firewall-cmd - -add-port=8001/tcp —permanent</code></pre>\n<h4 id=\"重启防火墙修改才生效\"><a href=\"#重启防火墙修改才生效\" class=\"headerlink\" title=\"重启防火墙修改才生效\"></a>重启防火墙修改才生效</h4><pre><code class=\"bash\">firewall-cmd-reload </code></pre>\n<h3 id=\"Nginx-操作的常用命令\"><a href=\"#Nginx-操作的常用命令\" class=\"headerlink\" title=\"Nginx 操作的常用命令\"></a>Nginx 操作的常用命令</h3><h4 id=\"注意-使用命令先要进入-usr-local-nginx-sbin-目录才可使用\"><a href=\"#注意-使用命令先要进入-usr-local-nginx-sbin-目录才可使用\" class=\"headerlink\" title=\"注意:使用命令先要进入 /usr/local/nginx/sbin/ 目录才可使用\"></a>注意:使用命令先要进入 /usr/local/nginx/sbin/ 目录才可使用</h4><ul>\n<li><p>查看版本号</p>\n<pre><code class=\"bash\"> ./nginx -v</code></pre>\n</li>\n</ul>\n<ul>\n<li><p>关闭nginx</p>\n<pre><code class=\"bash\">./nginx -s  stop </code></pre>\n</li>\n</ul>\n<ul>\n<li><p>启动 nginx</p>\n<pre><code class=\"bash\">./nginx        </code></pre>\n</li>\n</ul>\n<ul>\n<li><p>修改了配置文件[ conf/nginx.conf ]后,无需重启服务器及生效的命令 [ 重加载命令 ]</p>\n<pre><code>./nginx -s reload</code></pre></li>\n</ul>\n"},{"title":"ShaderGraph无贴图自制蓝色火焰","date":"2020-01-23T15:55:52.000Z","_content":"\n![](/png12.png)\n\n## ShaderGraph学习之一  不使用贴图制作火焰效果\n\n在制作火焰效果时，我们可以使用粒子系统加贴图等方式制作简单的火焰效果，但是今天我使用shadergraph在不使用贴图情况下制作蓝色小火焰。\n\n![](png1.png)\n\n制作思路：\n\n1. 使用Lerp噪声节点，然和多层混合颜色数据\n2. 使用自带的voronoi节点制作扭动效果\n3. 配合Time节点制作uv流动\n4. Distance配合UV制作蔗罩，配合制作图形\n5. remap，clamp，power配合处理计算数据\n\nLet `s do it。\n\n首先新建一个无光照的Shader，将主节点的透明模式改为Transparent透明模式。\n\n![](/png9.png)\n\n在这里先介绍Voronoi节点，这个节点是噪声节点下面的一个节点，效果时制作像泡泡一样的扭动的团噪。\n\n![](/png2.png)\n\n可以使用UV的TillingAndOffset节点让该噪声节点让上滚动，只需要将TillingAndOffset的Y分量让Time的节点作为输入即可。\n\n![](/png3.png)\n\n这样UV的滚动效果就呈现了，接着我们做两份重复的滚动UV只是参数不一样。\n\n![](/png4.png)\n\n接着我们对它们做一个Blend混合：\n\n![](/png5.png)\n\n接下来们需要把火焰的上半部分进行裁剪，由于现在效果时四方形，我们通过下面的节点做一个遮罩：\n\n![](/png6.png)\n\n解释一下：Distance节点是做某点在UV上面的映射距离计算的，而UV其实是贴图对于模型以 0.0-1.0 的比例进行映射的，打个比方，在一个2D坐标系里面UV的映射取值范围： U:(0.0f-1.0f),V(0.0f-1.0f)，模型的颜色就是通过坐标点的颜色值进行取样映射的。接着我们对得到的图像进行Remap将其映射到指定的范围得到一个上半圆的遮罩图形。通过Power(次方)节点进行虚化。\n\n然后将其Add成一个图形，就会把以前的UV滚动的上半部分进行遮罩覆盖。\n\n![](/png7.png)\n\n最后做火焰内外颜色的交替，其实就是用Lerp节点对外焰颜色(偏暗)和内焰颜色(偏亮)进行差值，差值系数就是Add和面的节点，其实这个节点最后是传给Alpha所以本身混合后就是一张0-1随机的贴图，我们通过clamp节点是保证值取值范围是0-1，然后Step节点是一个筛选节点，设置的值假设为0.8则贴图上所有没达到0.8的统统视作0处理，因为这样的话我们就可以找出内焰的区域，并加上颜色。\n\n![](/png8.png)\n\n当然这里面的一些参数自己都可以设置。最后说一下，主节点最下面的值的含义，其实是一个Alpha的阈值，也想相当于一个alpha测试的阈值，当Alpha通道输入的值小于它的时候，直接进行裁剪。\n\n![](/png10.png)\n\n最后面附上所有的节点图：\n\n![](/png11.png)\n\n可喜可贺，新年大吉！","source":"_posts/ShaderGraph无贴图自制蓝色火焰.md","raw":"---\ntitle: ShaderGraph无贴图自制蓝色火焰\ndate: 2020-01-23 23:55:52\ntags:\ncategories: 游戏栈\n---\n\n![](/png12.png)\n\n## ShaderGraph学习之一  不使用贴图制作火焰效果\n\n在制作火焰效果时，我们可以使用粒子系统加贴图等方式制作简单的火焰效果，但是今天我使用shadergraph在不使用贴图情况下制作蓝色小火焰。\n\n![](png1.png)\n\n制作思路：\n\n1. 使用Lerp噪声节点，然和多层混合颜色数据\n2. 使用自带的voronoi节点制作扭动效果\n3. 配合Time节点制作uv流动\n4. Distance配合UV制作蔗罩，配合制作图形\n5. remap，clamp，power配合处理计算数据\n\nLet `s do it。\n\n首先新建一个无光照的Shader，将主节点的透明模式改为Transparent透明模式。\n\n![](/png9.png)\n\n在这里先介绍Voronoi节点，这个节点是噪声节点下面的一个节点，效果时制作像泡泡一样的扭动的团噪。\n\n![](/png2.png)\n\n可以使用UV的TillingAndOffset节点让该噪声节点让上滚动，只需要将TillingAndOffset的Y分量让Time的节点作为输入即可。\n\n![](/png3.png)\n\n这样UV的滚动效果就呈现了，接着我们做两份重复的滚动UV只是参数不一样。\n\n![](/png4.png)\n\n接着我们对它们做一个Blend混合：\n\n![](/png5.png)\n\n接下来们需要把火焰的上半部分进行裁剪，由于现在效果时四方形，我们通过下面的节点做一个遮罩：\n\n![](/png6.png)\n\n解释一下：Distance节点是做某点在UV上面的映射距离计算的，而UV其实是贴图对于模型以 0.0-1.0 的比例进行映射的，打个比方，在一个2D坐标系里面UV的映射取值范围： U:(0.0f-1.0f),V(0.0f-1.0f)，模型的颜色就是通过坐标点的颜色值进行取样映射的。接着我们对得到的图像进行Remap将其映射到指定的范围得到一个上半圆的遮罩图形。通过Power(次方)节点进行虚化。\n\n然后将其Add成一个图形，就会把以前的UV滚动的上半部分进行遮罩覆盖。\n\n![](/png7.png)\n\n最后做火焰内外颜色的交替，其实就是用Lerp节点对外焰颜色(偏暗)和内焰颜色(偏亮)进行差值，差值系数就是Add和面的节点，其实这个节点最后是传给Alpha所以本身混合后就是一张0-1随机的贴图，我们通过clamp节点是保证值取值范围是0-1，然后Step节点是一个筛选节点，设置的值假设为0.8则贴图上所有没达到0.8的统统视作0处理，因为这样的话我们就可以找出内焰的区域，并加上颜色。\n\n![](/png8.png)\n\n当然这里面的一些参数自己都可以设置。最后说一下，主节点最下面的值的含义，其实是一个Alpha的阈值，也想相当于一个alpha测试的阈值，当Alpha通道输入的值小于它的时候，直接进行裁剪。\n\n![](/png10.png)\n\n最后面附上所有的节点图：\n\n![](/png11.png)\n\n可喜可贺，新年大吉！","slug":"ShaderGraph无贴图自制蓝色火焰","published":1,"updated":"2020-01-24T07:32:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rji000xzd5b9abo2cx0","content":"<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png12.png\" alt></p>\n<h2 id=\"ShaderGraph学习之一-不使用贴图制作火焰效果\"><a href=\"#ShaderGraph学习之一-不使用贴图制作火焰效果\" class=\"headerlink\" title=\"ShaderGraph学习之一  不使用贴图制作火焰效果\"></a>ShaderGraph学习之一  不使用贴图制作火焰效果</h2><p>在制作火焰效果时，我们可以使用粒子系统加贴图等方式制作简单的火焰效果，但是今天我使用shadergraph在不使用贴图情况下制作蓝色小火焰。</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png1.png\" alt></p>\n<p>制作思路：</p>\n<ol>\n<li>使用Lerp噪声节点，然和多层混合颜色数据</li>\n<li>使用自带的voronoi节点制作扭动效果</li>\n<li>配合Time节点制作uv流动</li>\n<li>Distance配合UV制作蔗罩，配合制作图形</li>\n<li>remap，clamp，power配合处理计算数据</li>\n</ol>\n<p>Let `s do it。</p>\n<p>首先新建一个无光照的Shader，将主节点的透明模式改为Transparent透明模式。</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png9.png\" alt></p>\n<p>在这里先介绍Voronoi节点，这个节点是噪声节点下面的一个节点，效果时制作像泡泡一样的扭动的团噪。</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png2.png\" alt></p>\n<p>可以使用UV的TillingAndOffset节点让该噪声节点让上滚动，只需要将TillingAndOffset的Y分量让Time的节点作为输入即可。</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png3.png\" alt></p>\n<p>这样UV的滚动效果就呈现了，接着我们做两份重复的滚动UV只是参数不一样。</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png4.png\" alt></p>\n<p>接着我们对它们做一个Blend混合：</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png5.png\" alt></p>\n<p>接下来们需要把火焰的上半部分进行裁剪，由于现在效果时四方形，我们通过下面的节点做一个遮罩：</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png6.png\" alt></p>\n<p>解释一下：Distance节点是做某点在UV上面的映射距离计算的，而UV其实是贴图对于模型以 0.0-1.0 的比例进行映射的，打个比方，在一个2D坐标系里面UV的映射取值范围： U:(0.0f-1.0f),V(0.0f-1.0f)，模型的颜色就是通过坐标点的颜色值进行取样映射的。接着我们对得到的图像进行Remap将其映射到指定的范围得到一个上半圆的遮罩图形。通过Power(次方)节点进行虚化。</p>\n<p>然后将其Add成一个图形，就会把以前的UV滚动的上半部分进行遮罩覆盖。</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png7.png\" alt></p>\n<p>最后做火焰内外颜色的交替，其实就是用Lerp节点对外焰颜色(偏暗)和内焰颜色(偏亮)进行差值，差值系数就是Add和面的节点，其实这个节点最后是传给Alpha所以本身混合后就是一张0-1随机的贴图，我们通过clamp节点是保证值取值范围是0-1，然后Step节点是一个筛选节点，设置的值假设为0.8则贴图上所有没达到0.8的统统视作0处理，因为这样的话我们就可以找出内焰的区域，并加上颜色。</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png8.png\" alt></p>\n<p>当然这里面的一些参数自己都可以设置。最后说一下，主节点最下面的值的含义，其实是一个Alpha的阈值，也想相当于一个alpha测试的阈值，当Alpha通道输入的值小于它的时候，直接进行裁剪。</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png10.png\" alt></p>\n<p>最后面附上所有的节点图：</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png11.png\" alt></p>\n<p>可喜可贺，新年大吉！</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png12.png\" alt></p>\n<h2 id=\"ShaderGraph学习之一-不使用贴图制作火焰效果\"><a href=\"#ShaderGraph学习之一-不使用贴图制作火焰效果\" class=\"headerlink\" title=\"ShaderGraph学习之一  不使用贴图制作火焰效果\"></a>ShaderGraph学习之一  不使用贴图制作火焰效果</h2><p>在制作火焰效果时，我们可以使用粒子系统加贴图等方式制作简单的火焰效果，但是今天我使用shadergraph在不使用贴图情况下制作蓝色小火焰。</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png1.png\" alt></p>\n<p>制作思路：</p>\n<ol>\n<li>使用Lerp噪声节点，然和多层混合颜色数据</li>\n<li>使用自带的voronoi节点制作扭动效果</li>\n<li>配合Time节点制作uv流动</li>\n<li>Distance配合UV制作蔗罩，配合制作图形</li>\n<li>remap，clamp，power配合处理计算数据</li>\n</ol>\n<p>Let `s do it。</p>\n<p>首先新建一个无光照的Shader，将主节点的透明模式改为Transparent透明模式。</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png9.png\" alt></p>\n<p>在这里先介绍Voronoi节点，这个节点是噪声节点下面的一个节点，效果时制作像泡泡一样的扭动的团噪。</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png2.png\" alt></p>\n<p>可以使用UV的TillingAndOffset节点让该噪声节点让上滚动，只需要将TillingAndOffset的Y分量让Time的节点作为输入即可。</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png3.png\" alt></p>\n<p>这样UV的滚动效果就呈现了，接着我们做两份重复的滚动UV只是参数不一样。</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png4.png\" alt></p>\n<p>接着我们对它们做一个Blend混合：</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png5.png\" alt></p>\n<p>接下来们需要把火焰的上半部分进行裁剪，由于现在效果时四方形，我们通过下面的节点做一个遮罩：</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png6.png\" alt></p>\n<p>解释一下：Distance节点是做某点在UV上面的映射距离计算的，而UV其实是贴图对于模型以 0.0-1.0 的比例进行映射的，打个比方，在一个2D坐标系里面UV的映射取值范围： U:(0.0f-1.0f),V(0.0f-1.0f)，模型的颜色就是通过坐标点的颜色值进行取样映射的。接着我们对得到的图像进行Remap将其映射到指定的范围得到一个上半圆的遮罩图形。通过Power(次方)节点进行虚化。</p>\n<p>然后将其Add成一个图形，就会把以前的UV滚动的上半部分进行遮罩覆盖。</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png7.png\" alt></p>\n<p>最后做火焰内外颜色的交替，其实就是用Lerp节点对外焰颜色(偏暗)和内焰颜色(偏亮)进行差值，差值系数就是Add和面的节点，其实这个节点最后是传给Alpha所以本身混合后就是一张0-1随机的贴图，我们通过clamp节点是保证值取值范围是0-1，然后Step节点是一个筛选节点，设置的值假设为0.8则贴图上所有没达到0.8的统统视作0处理，因为这样的话我们就可以找出内焰的区域，并加上颜色。</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png8.png\" alt></p>\n<p>当然这里面的一些参数自己都可以设置。最后说一下，主节点最下面的值的含义，其实是一个Alpha的阈值，也想相当于一个alpha测试的阈值，当Alpha通道输入的值小于它的时候，直接进行裁剪。</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png10.png\" alt></p>\n<p>最后面附上所有的节点图：</p>\n<p><img src=\"/2020/01/23/shadergraph-wu-tie-tu-zi-zhi-lan-se-huo-yan/png11.png\" alt></p>\n<p>可喜可贺，新年大吉！</p>\n"},{"title":"VMware Fusion 11 购买的序列号","date":"2020-02-10T07:53:10.000Z","Categories":"Tips","_content":"\n## VMware Fusion 11序列号\n\n刚刚购买了 VMware fusion的虚拟机，把序列号公开给有缘人～\n\n7HYY8-Z8WWY-F1MAN-ECKNY-LUXYX\n\n","source":"_posts/VMware-Fusion-11-购买的序列号.md","raw":"---\ntitle: VMware Fusion 11 购买的序列号\ndate: 2020-02-10 15:53:10\ntags: VMware fusion\nCategories: Tips\n---\n\n## VMware Fusion 11序列号\n\n刚刚购买了 VMware fusion的虚拟机，把序列号公开给有缘人～\n\n7HYY8-Z8WWY-F1MAN-ECKNY-LUXYX\n\n","slug":"VMware-Fusion-11-购买的序列号","published":1,"updated":"2020-02-10T07:55:28.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rjj0011zd5b3afo2yab","content":"<h2 id=\"VMware-Fusion-11序列号\"><a href=\"#VMware-Fusion-11序列号\" class=\"headerlink\" title=\"VMware Fusion 11序列号\"></a>VMware Fusion 11序列号</h2><p>刚刚购买了 VMware fusion的虚拟机，把序列号公开给有缘人～</p>\n<p>7HYY8-Z8WWY-F1MAN-ECKNY-LUXYX</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<h2 id=\"VMware-Fusion-11序列号\"><a href=\"#VMware-Fusion-11序列号\" class=\"headerlink\" title=\"VMware Fusion 11序列号\"></a>VMware Fusion 11序列号</h2><p>刚刚购买了 VMware fusion的虚拟机，把序列号公开给有缘人～</p>\n<p>7HYY8-Z8WWY-F1MAN-ECKNY-LUXYX</p>\n"},{"title":"blender 学习章","date":"2019-07-10T15:05:54.000Z","_content":"\n![](/start.jpg)\n\n由于自己是做独立游戏开发的，缄默是少不了的。\n开源免费的Blender近年来大热，做一般游戏建模肯定是没问题的，B站这个教程很不错：\n\n#### [【跟顺子老师学3D】blender零基础入门教程【全】](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D1)\n\n一晚上一口气就看了十几课，速度快一点的话两三天就可以学完，Blender的快捷键非常多而且使用频繁，对于一个初学者来说很容易就忘光了，然后回头在视频里查找又是比较没效率的事情，所以必须写点笔记。\n\n### 一、结合Unity\n\nUnity游戏开发用了5年多了，一开始使用blender时很困惑，因为坐标系跟Unity完全不一样， Z轴居然向上，在以前的Unity老版本里好像还要自己进行手动转换坐标，而在当前Unity 2018版本可以直接拖动blender的文件到项目里，会自动转换坐标，转换后的视角相当于blender里的后视图的视角。\n\n> **2018.7.3：今天特意试了一下把blender工程文件直接保存到unity目录下，然后加入到场景中，发现Cycles渲染模式下创建的材质全部都不能正常显示，又试了一下Blender渲染模式可以正常显示，而且在Blender中所作的修改可以在Unity中自动刷新载入显示。其实想想也正常，毕竟Cycles渲染是离线渲染而Unity是实时渲染，无法直接使用是很正常的。**\n> **因为我主要应用于Unity，所以平常还是多学习Blender渲染模式，除非一些高质量场景使用烘焙的情况才使用Cycles。**\n\n> **2018.7.6：尝试导出包含骨骼动画的fbx文件然后在Unity中载入。出现了很多奇怪的问题，比如人物部分位置偏移（好像是使用了IK骨的原因）。最终还是使用blender源文件直接载入到Unity中，然后一点问题都没有了，WTF！真是折腾死我了。**\n\n### 二、视频学习笔记\n\n目前Blender 2.8版本还没正式推出，视频里使用的是2.79版，我使用2.79b版本好像没什么区别。\n\n------\n\n#### [01. 简介](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D1)\n\n下载安装软件，没啥可说的。\n\n------\n\n#### [02. 界面及基本操作](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D2)\n\n中文界面设置：\"File\" -> \"User Preference\"->“System\"，将滚动条拉到下面，勾选“International Fonts”在下面，选择Language 为“simplified Chinese(简体中文)”。\n勾选下面的“Interface”和“Tooltips”，不要选择“New Data”（因为可能一些插件不支持中文路径。）\n\n同页面的Cycles Compute Device选择CUDA，再选中下面的显卡，这样在主窗口可以选择Cycles渲染。\n\n勾选“界面”页中的“自动透视模式”。\n\n关闭设置窗口前注意要点击左下角“保存用户设置”，否则重启后丢失修改的设置。\n\n滚动鼠标中键：视图缩放。\n按住鼠标中键：视图旋转。\nSHIFT+鼠标中键：视图平移。\n鼠标右键：选中目标。\n\n多窗口分割：拖动窗口边缘的三角形。\n多窗口关闭：拖动窗口边缘的三角形到反方向。\n每个分割窗口左下角或者右上角按钮可以切换不同视图。\n“T键”：切换工具栏显示。\n“N键”：切换属性栏显示。\n小键盘区：\n“5”：透视/正交视图切换。\n其他键懒得写了，各种视图切换。\n\n无小键盘（比如笔记本）：启用自带插件“3D View:3D Navigation，然后在工具栏的“显示”页里点击按钮代替小键盘。\n\n选择物体后：\n“G键”：（grab)移动物体。然后按X,Y,Z可以根据轴移动。按SHIFT+X/Y/Z可以锁定X/Y/Z，然后根据其他轴移动（此功能还不如直接在正交视图中移动）。\n“S键”：（scale)缩放物体。然后按X,Y,Z可以根据轴缩放。\n“R键”：（rotate)旋转物体。然后按X,Y,Z可以根据轴旋转。双击“R\"实现360度立体旋转。\nGSR操作时按住“SHIFT”键可以精细操作。\n切换GSR操作的参照坐标系：切换窗口下面的菜单栏里的“全局”和“自身”。\n\n“SHIFT+C”：3D游标恢复到视图中心。\n“SHIFT+A”：（add）（在3D游标处）添加物体。\n“X键”：删除物体。\n\n------\n\n#### [03. 主题安装及其他补充](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D3)\n\nenergy(能量)主题：\n原作者：[https://studiollb.wordpress.com/download/](https://links.jianshu.com/go?to=https%3A%2F%2Fstudiollb.wordpress.com%2Fdownload%2F)\n\n------\n\n#### [04. 保存和备份](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D4)\n\n保存时会自动产生一个备份文件。\n保存窗口里的“+”、“-”按钮可以自动递增递减文件名。\n\n------\n\n#### [05. 编辑模式基本操作](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D5)\n\n“TAB键”：切换编辑模式/物体模式。\n编辑模式：\n“CTRL+TAB键”：切换顶点/边/面。\n“A键”：全选或者取消全选。\n“SHIFT+鼠标右键”：多选点线面。\n\n------\n\n#### [06. 编辑模式下的多选](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D6)\n\n编辑模式：\n“CTRL+鼠标左键”：自动选择邻近点线面。\n“ALT+鼠标左键”：选中整行或者整列点线面。\n“C键”：自由刷选。可以滚动鼠标中键来控制刷选区大小。左键选中，中键按下取消选择。\n“B键”：（box)框选。\n“CTRL+鼠标左键拖动”：在按下后可以自由拖选。\n“L键”：全选鼠标所在点线面的物体。\n“CTRL+小键盘加号”：扩展选区。\n“CTRL+小键盘减号”：缩减选区。\n\n------\n\n#### [07. 环切](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D7)\n\n编辑模式：\n“CTRL+R”：环切。环切时滚动滚轮可以切多刀。\n\n------\n\n#### [08. 细分](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D8)\n\n编辑模式：\n细分：选中物体后按“W键”弹出菜单，选择“细分”。细分时工具栏的细分选项页可以控制切割次数。\n“SHIFT+R”：(repeat)重做上一次操作。\n\n细分主要对面操作，对边也可以细分但是细分为点。顶点无法细分。\n\n“CTRL+E”：反细分。（不在课程内，自己查的）。\n\n------\n\n#### [09. 挤出](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D9)\n\n编辑模式：\n“E键”：选中点线面都可以挤出，但一般主要对面操作。\n\n挤出时右键取消实际上还是挤出了，只不过重叠在原有位置。\n\n环切左键确定后可以按“S键”然后移动坐标轴进行缩放环切线。缩放时可以直接输入缩放倍数，在左下角有显示缩放当前倍数。\n\n------\n\n#### [10. 倒角](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D10)\n\n编辑模式：\n选中边，按“CTRL+B”进行倒角，此时可以滚动滚轮增加倒角边。\n\n环切确认后也可以按“CTRL+B”和滚轮增加环切边。\n\n------\n\n#### [11. 合并与分离](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D11)\n\n**物体的合并与分离：**\n物体模式：\n“CTRL+J”：“join”。合并选中的多个物体。合并后的轴心在最后选中物体的轴心。\n编辑模式：\n“P键”：选中物体后按P键弹跳出菜单可以进行多种分离模式。没选中任何物体时也可以按P键进行按松散块分离。\n\n**顶点的合并与分离：**\n“V键”：选中顶点后进行按键拖动分离。此模式比较坑的一点是就算按鼠标右键取消分离，其实也还是分离了，如果不想分离只能按CTRL+Z撤消操作。\n“ALT+M键”：选中两个点按键后弹出菜单合并。\n\n------\n\n#### [12. 创建边与面](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D12)\n\n编辑模式：\n“F键”：(fill)选中点或者边，然后按F键进行填充边或者面。\n\n------\n\n#### [13. 衰减编辑](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D13)\n\n编辑模式：\n“O键”：启用衰减编辑。底下菜单栏也可以选择，还可以切换衰减模式。\n衰减编辑模式：\n“G键”：此时滚动鼠标滚轮控制衰减范围。\n“ALT+O键”：“衰减编辑模式-相连项”：开启后不会影响不相连的其他物体。\n\n------\n\n#### [14. 轴心点](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D14)\n\n选中多个物体可以通过下面的菜单栏切换轴心点，默认轴心点为质心点。缩放旋转都是根据轴心点进行的。\n\n合并多个物体后，轴心点会被设置到最后一个选中的物体的轴心点上。分离物体后各个物体的轴心点不会恢复的原有的位置。\n\n“CTRL+ALT+SHIFT+C键”：弹出设置原点菜单，可以修改原点。原点即轴心点。\n\n编辑模式：\n“SHIFT+S键”：（snap）吸附菜单。可以修改游标位置等。\n\n------\n\n#### [15. 内插面&应用缩放比例](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D15)\n\n实体显示状态：属性栏->着色方式->Mapcap修改编辑时的着色方式，不影响渲染。\n\n编辑模式：\n内插面方式一：选择面按E挤出时右键取消实际上还是挤出了，只不过重叠在原有位置。然后按S修改面大小，然后再按E挤出。\n\n内插面方式二：\n“I键”：（insert）插入面。然后再按E挤出。\n\n物体模式：\n“CTRL+A键”：（apply）应用菜单。缩放物体后比例变化，可以应用比例把比例值变为1，其实意思就是应用保存修改。\n\n------\n\n#### [16. 表面细分](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D16)\n\n选中物体添加修改器，添加表面细分修改器。\n表面细分可以配合工具栏->工具中的着色方式（光滑、平直）使用。\n\n快捷键：选中物体按“CTRL+数字键”直接添加表面细分器，数字代表了细分的次数。\n\n------\n\n#### [17. 镜射](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D17)\n\n编辑模式：\n切分后线框模式下按B框选可以选择背后的边。按X删除顶点。添加镜射修改器，根据XYZ轴选择镜射。\n\n勾选镜射修改器的范围限制可以防止交界处分离或者越界。\n\n------\n\n#### [18. 布尔](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D18)\n\n添加布尔修改器，指定参照物体。\n\n布尔插件：Bool Tool。添加插件后，在工具栏->工具下有Bool Tool，选中两个物体可以进行布尔操作。\n\n有时按中键移动视图很慢，按小键盘小数点键恢复一下视图即可。\n\n------\n\n#### [19. 修改器顺序](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D19)\n\n修改器不同的顺序产生不同的效果。\n\n实体修改器增加厚度，比如平面、衣服等厚度。\n\n------\n\n#### [20. 相机设置及渲染](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D20)\n\n“SHIFT+Z键”：切换渲染模式（预览）。\n\n开启快捷切换插件：Pie Menu 3D ->View Numpad Pie: Q。 可以快速切换视图。\n前视图移动物体时按住CTRL可以按网格移动。\n“F12键”：开始渲染。\n“M键”：移动选中物体到不同图层。\n“小键盘0键”：显示相机视图。\n\n选中相机按N打开属性面板->锁定到视图，可以锁定相机视图，此时移动视图然后渲染所见即所得。\n\n渲染窗口：切换底部“槽”可以保存每次的渲染结果。可以使用大键盘数字键来切换槽。\n\n编辑窗口的大键盘数字键可以切换图层（自己试出来的）。\n\n最右属性栏->世界环境->背景->颜色旁的小点弹出菜单可以选择天空纹理。\n\n------\n\n#### [21. 灯光设置](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D21)\n\n灯光没啥好说的，自己试验修改各种参数看效果。日光只有旋转才会有不同效果，移动位置不影响。\n\n使用给平面增加材质来模拟光源：创建平面，增加纹理，修改漫射BSDF为自发光。\n选中这个发光的面，设置物体属性->Cycles 设定->Ray Visibilty->关闭摄像机可以隐藏这个面，但发出的光还是有效。\n可以对这个发光的面进行各种编辑（缩放旋转修改形状等）来产生不同的效果。\n\n基本打光技巧，3个光源（3点光）:\n主光源放在摄像机位置附近、辅助光源小一点放在摄像机侧面使主光源阴影更少一点，再增加一个光源放在摄像机所对物体后面。两个辅助光源都去掉投射阴影（只有灯光才有投射阴影，如果使用材质模拟光则没有。）。\n\n“ALT+S键”：还原缩放。\n“ALT+R键”：还原旋转。\n\n------\n\n#### [22. 提高Cycles渲染速度](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D22)\n\n最右属性栏->渲染->采样：影响渲染效果和速度。\n最右属性栏->渲染层->Denoising：降噪功能。此功能在我的烂显卡上不支持GPU渲染，只能CPU渲染。\n最右属性栏->渲染->分块大小：影响渲染速度。插件：Auto Tile Size，自动根据机器配置设置分块大小。\n\n最右属性栏->渲染->光程：适当调节减小值可以提高速度，我不想调就用默认的。\n\n------\n\n#### [23. 材质](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D23)\n\n各种材质没啥好说的，自己试效果就可以了。\n\n节点编辑器：各种快捷键跟3D视图编辑器差不多。可以新增着色器进行连线等操作。\n\n------\n\n#### [24. Principled着色器](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D24)\n\n世界环境->使用节点->背景->颜色（点按钮）->环境纹理->添加下载好的HDR文件。\n\nPrincipled着色器可以调出金属、塑料、透明等效果。\n\n------\n\n#### [25. blender渲染](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D25)\n\n主要是材质和灯光跟Cycle的不同。\n优势是速度快，但已经不再更新。\n\n------\n\n#### [26. blender卡通渲染](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D26)\n\n主要讲了Blender渲染模式下的卡通效果，具体的操作还是得参考视频。\nfreestyle描边。\n\n------\n\n#### [27. principled着色器补充](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D27)\n\n表面细分：光穿透物体的程度。\nSubsurface Radius：表面细分范围（RGB三色）。\n\n各向异性过滤：配合Metalic(金属）实现类似拉丝金属。\nAnisotropic Rotation：各向异性过滤的旋转角度。\n\n> 我自己网上找的，更详细的Principled 知识参考下面链接：\n> [2.79新材质节点 Principled 图解](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.blendercn.org%2F1771.html%2Fcomment-page-1%23comment-634)\n\n------\n\n#### [28. 表皮修改器制做小青蛙](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D28)\n\n创建平面，选中四点，ALT+M合并到中心，添加镜射修改器，挤出顶点，添加表皮修改器，添加表面细分修改器。\n\n表皮修改器标记根结点。\n对顶点不能直接使用S键缩放，缩放顶点周边使用CTRL+A。\n\n做出大概形状后应用表皮修改器，再进一步进行细化。\n需要先应用镜射修改器再应用表皮修改器。\n表皮修改器可以直接创建简单的骨架。\n\n------\n\n#### [29. UV展开与纹理](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D29)\n\n“U键”：UV映射菜单。\n“CTRL+E键”：(edge)选中边以后，按快捷键弹出边菜单，选择标记缝合边。\n标记缝合边以后再按U->展开UV，然后在底部图像菜单新建图像。\n底部UV菜单导出UV布局图。\n在外部修改UV图像以后，使用新建材质->颜色->图像纹理->载入图像然后即可在材质视图看到效果。\n\n进入底部菜单的“纹理绘制”模式可以直接进行绘制。\n\n------\n\n#### [30. 相机跟踪](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D30)\n\n创建空物体。\n选中摄像机添加标准跟随约束，设置目标为空物体。修改约束中的-Z和向上为Y。\n添加曲线->圆环，放大后CTRL+A应用缩放。\n选中摄像机添加跟随路径约束，设置目标为圆环。\n移动跟随路径约束到标准跟随约束上面。\n点击跟随路径约束的动画路径。\n播放即可实现动画。\n可以对圆环进行各种编辑。\n\n------\n\n#### [31. 父级](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D31)\n\n物体模式：\n“CTRL+P键”：设定父级。\n“ATL+P键”：清空父级。\n\n------\n\n#### [32.1 骨骼之骨骼建立](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D32)\n\n这节课里的lowpoly死侍模型挺好看，可以学着做一个。\n\n骨架的镜像：\n选中骨架->编辑模式->工具栏->选项->X轴镜像\n然后按“SHIFT+E键”挤出骨骼即可左右自动对称挤出。\n对于手臂和腿的挤出使用“ATL+P键”：断开骨骼连接。这样还保持着父级。\n\n头和臂从身体上段挤出，腿从身体下段挤出。\n\n------\n\n#### [32.2 骨骼之权重绘制](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D33)\n\n把骨架做为物体的父级（“CTRL+P键”），附带自动权重。\n“CTRL+TAB键”：骨架姿态模式或者物体权重绘制模式。\n\n权重绘制只对顶点绘制，一般使用工具栏->工具里的F Mix笔刷，权重0表示不受骨骼影响，1表示完全受骨骼影响，其他中间值为部分受骨骼影响。按“F键”可以对笔刷大小缩放。\n\n使用选中物体模块在最右工具栏中数据页指定骨骼的方式可以直接设置权重值。\n\n------\n\n#### [32.3 骨骼之IK骨](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D34)\n\n“SHIFT+I键”：添加IK骨。\n默认IK骨的链长为0会影响所有骨骼，要修改为想要的链长。\n关节处也要增加IK骨。\n精细的多顶点模型有益于Blender创建自动权重的计算。\n\n------\n\n#### [33. 动画](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D35)\n\n“I键”：添加关键帧。\n曲线编辑器：“T键”：修改关键帧插值模式。\n\nN键属性栏可以直接修改关键帧变换数值。\n\n材质的颜色也可以增加关键帧。\n\n------\n\n#### [34. 作业](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D36)\n\n没啥可说的，开始做作业吧。\n\n------\n\n### 三、自己的学习补充\n\n1. 摄像机视角控制\n   小键盘快捷键“0”进入摄像机视图，按“SHIFT+F”，此时可以使用WASD和QE来移动视角（不过有一次我突然发现在此模式下居然无法使用WASDQE移动，然后重启软件后又可以了。)\n\n------\n\n### 四、贴吧看到的Rigify骨架插件使用技巧\n\n还未实践。\n\n> 1.检查模型是否在世界中心，移动/旋转/缩放 模型，并Ctrl+A应用。\n> 2.灯光、摄像机移至其他图层，并将模型贴图设置为Shadeless（个人建议）。\n> 3.分离模型部件（如有需要的话）——分离的目的是为了待会儿更好地分类绑定与权重绘制。\n> 4.开启Rigify插件，Shift+A添加。\n> 5.大致匹配Rigify骨架于模型，并Ctrl+A应用骨架。\n> 6.Tab进入骨架编辑模式，注意开启左侧竖栏Options选项里面的X-Axis Mirror，X轴镜像编辑。\n> 7.对应骨点位置。\n> 8.Check Unity Doc. 删除手指根骨节。\n> 9.Normal Trans Orientation 去查看每个骨节的朝向。\n> 10.Save As，存盘。\n> 11.Generate生成带有控制器的骨架，并将原有基础骨架移至其他层。\n> 12.Check Unity Doc. 选择相应骨架层，重置某些骨节的父子关系。\n> 13.添加附加骨架（如果有需要的话），并为其设置对应的父子关系——需要配合项目骨节数要求。\n> 注意：有些L.R对应的镜像骨节，可以在Normal Trans Orientation（Edit Mode）下查看其轴向,\n> 以确保其在Pose Mode下可以被统一旋转。\n> 14.绑定（为模型与骨架建立父子关系）——建议：Ctrl+P → Automatic Weight\n> 15.选中模型，打开修改器面板下的Armature，勾选【Preserve Volume】如果有需要的话。\n> 16.权重绘制（巧用笔刷工具与顶点遮罩工具）\n> 17.眼球：Modifier, [Track to]\n> 18.表情：Shape Key\n> 19.武器（props）：利用[Child of]修改器与角色骨架建立关系。\n> 20.Remove WGT-Bones in The Hierarchy. Using This Way will Affect Smoothly into Unity.\n> 21.用极限POSE去检查绑定。\n\n暂时到这吧～\n\n![](/end.jpg)","source":"_posts/blender-学习章.md","raw":"---\ntitle: blender 学习章\ndate: 2019-07-10 23:05:54\ntags: [游戏美术,建模]\ncategories: 游戏栈\n---\n\n![](/start.jpg)\n\n由于自己是做独立游戏开发的，缄默是少不了的。\n开源免费的Blender近年来大热，做一般游戏建模肯定是没问题的，B站这个教程很不错：\n\n#### [【跟顺子老师学3D】blender零基础入门教程【全】](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D1)\n\n一晚上一口气就看了十几课，速度快一点的话两三天就可以学完，Blender的快捷键非常多而且使用频繁，对于一个初学者来说很容易就忘光了，然后回头在视频里查找又是比较没效率的事情，所以必须写点笔记。\n\n### 一、结合Unity\n\nUnity游戏开发用了5年多了，一开始使用blender时很困惑，因为坐标系跟Unity完全不一样， Z轴居然向上，在以前的Unity老版本里好像还要自己进行手动转换坐标，而在当前Unity 2018版本可以直接拖动blender的文件到项目里，会自动转换坐标，转换后的视角相当于blender里的后视图的视角。\n\n> **2018.7.3：今天特意试了一下把blender工程文件直接保存到unity目录下，然后加入到场景中，发现Cycles渲染模式下创建的材质全部都不能正常显示，又试了一下Blender渲染模式可以正常显示，而且在Blender中所作的修改可以在Unity中自动刷新载入显示。其实想想也正常，毕竟Cycles渲染是离线渲染而Unity是实时渲染，无法直接使用是很正常的。**\n> **因为我主要应用于Unity，所以平常还是多学习Blender渲染模式，除非一些高质量场景使用烘焙的情况才使用Cycles。**\n\n> **2018.7.6：尝试导出包含骨骼动画的fbx文件然后在Unity中载入。出现了很多奇怪的问题，比如人物部分位置偏移（好像是使用了IK骨的原因）。最终还是使用blender源文件直接载入到Unity中，然后一点问题都没有了，WTF！真是折腾死我了。**\n\n### 二、视频学习笔记\n\n目前Blender 2.8版本还没正式推出，视频里使用的是2.79版，我使用2.79b版本好像没什么区别。\n\n------\n\n#### [01. 简介](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D1)\n\n下载安装软件，没啥可说的。\n\n------\n\n#### [02. 界面及基本操作](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D2)\n\n中文界面设置：\"File\" -> \"User Preference\"->“System\"，将滚动条拉到下面，勾选“International Fonts”在下面，选择Language 为“simplified Chinese(简体中文)”。\n勾选下面的“Interface”和“Tooltips”，不要选择“New Data”（因为可能一些插件不支持中文路径。）\n\n同页面的Cycles Compute Device选择CUDA，再选中下面的显卡，这样在主窗口可以选择Cycles渲染。\n\n勾选“界面”页中的“自动透视模式”。\n\n关闭设置窗口前注意要点击左下角“保存用户设置”，否则重启后丢失修改的设置。\n\n滚动鼠标中键：视图缩放。\n按住鼠标中键：视图旋转。\nSHIFT+鼠标中键：视图平移。\n鼠标右键：选中目标。\n\n多窗口分割：拖动窗口边缘的三角形。\n多窗口关闭：拖动窗口边缘的三角形到反方向。\n每个分割窗口左下角或者右上角按钮可以切换不同视图。\n“T键”：切换工具栏显示。\n“N键”：切换属性栏显示。\n小键盘区：\n“5”：透视/正交视图切换。\n其他键懒得写了，各种视图切换。\n\n无小键盘（比如笔记本）：启用自带插件“3D View:3D Navigation，然后在工具栏的“显示”页里点击按钮代替小键盘。\n\n选择物体后：\n“G键”：（grab)移动物体。然后按X,Y,Z可以根据轴移动。按SHIFT+X/Y/Z可以锁定X/Y/Z，然后根据其他轴移动（此功能还不如直接在正交视图中移动）。\n“S键”：（scale)缩放物体。然后按X,Y,Z可以根据轴缩放。\n“R键”：（rotate)旋转物体。然后按X,Y,Z可以根据轴旋转。双击“R\"实现360度立体旋转。\nGSR操作时按住“SHIFT”键可以精细操作。\n切换GSR操作的参照坐标系：切换窗口下面的菜单栏里的“全局”和“自身”。\n\n“SHIFT+C”：3D游标恢复到视图中心。\n“SHIFT+A”：（add）（在3D游标处）添加物体。\n“X键”：删除物体。\n\n------\n\n#### [03. 主题安装及其他补充](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D3)\n\nenergy(能量)主题：\n原作者：[https://studiollb.wordpress.com/download/](https://links.jianshu.com/go?to=https%3A%2F%2Fstudiollb.wordpress.com%2Fdownload%2F)\n\n------\n\n#### [04. 保存和备份](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D4)\n\n保存时会自动产生一个备份文件。\n保存窗口里的“+”、“-”按钮可以自动递增递减文件名。\n\n------\n\n#### [05. 编辑模式基本操作](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D5)\n\n“TAB键”：切换编辑模式/物体模式。\n编辑模式：\n“CTRL+TAB键”：切换顶点/边/面。\n“A键”：全选或者取消全选。\n“SHIFT+鼠标右键”：多选点线面。\n\n------\n\n#### [06. 编辑模式下的多选](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D6)\n\n编辑模式：\n“CTRL+鼠标左键”：自动选择邻近点线面。\n“ALT+鼠标左键”：选中整行或者整列点线面。\n“C键”：自由刷选。可以滚动鼠标中键来控制刷选区大小。左键选中，中键按下取消选择。\n“B键”：（box)框选。\n“CTRL+鼠标左键拖动”：在按下后可以自由拖选。\n“L键”：全选鼠标所在点线面的物体。\n“CTRL+小键盘加号”：扩展选区。\n“CTRL+小键盘减号”：缩减选区。\n\n------\n\n#### [07. 环切](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D7)\n\n编辑模式：\n“CTRL+R”：环切。环切时滚动滚轮可以切多刀。\n\n------\n\n#### [08. 细分](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D8)\n\n编辑模式：\n细分：选中物体后按“W键”弹出菜单，选择“细分”。细分时工具栏的细分选项页可以控制切割次数。\n“SHIFT+R”：(repeat)重做上一次操作。\n\n细分主要对面操作，对边也可以细分但是细分为点。顶点无法细分。\n\n“CTRL+E”：反细分。（不在课程内，自己查的）。\n\n------\n\n#### [09. 挤出](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D9)\n\n编辑模式：\n“E键”：选中点线面都可以挤出，但一般主要对面操作。\n\n挤出时右键取消实际上还是挤出了，只不过重叠在原有位置。\n\n环切左键确定后可以按“S键”然后移动坐标轴进行缩放环切线。缩放时可以直接输入缩放倍数，在左下角有显示缩放当前倍数。\n\n------\n\n#### [10. 倒角](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D10)\n\n编辑模式：\n选中边，按“CTRL+B”进行倒角，此时可以滚动滚轮增加倒角边。\n\n环切确认后也可以按“CTRL+B”和滚轮增加环切边。\n\n------\n\n#### [11. 合并与分离](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D11)\n\n**物体的合并与分离：**\n物体模式：\n“CTRL+J”：“join”。合并选中的多个物体。合并后的轴心在最后选中物体的轴心。\n编辑模式：\n“P键”：选中物体后按P键弹跳出菜单可以进行多种分离模式。没选中任何物体时也可以按P键进行按松散块分离。\n\n**顶点的合并与分离：**\n“V键”：选中顶点后进行按键拖动分离。此模式比较坑的一点是就算按鼠标右键取消分离，其实也还是分离了，如果不想分离只能按CTRL+Z撤消操作。\n“ALT+M键”：选中两个点按键后弹出菜单合并。\n\n------\n\n#### [12. 创建边与面](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D12)\n\n编辑模式：\n“F键”：(fill)选中点或者边，然后按F键进行填充边或者面。\n\n------\n\n#### [13. 衰减编辑](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D13)\n\n编辑模式：\n“O键”：启用衰减编辑。底下菜单栏也可以选择，还可以切换衰减模式。\n衰减编辑模式：\n“G键”：此时滚动鼠标滚轮控制衰减范围。\n“ALT+O键”：“衰减编辑模式-相连项”：开启后不会影响不相连的其他物体。\n\n------\n\n#### [14. 轴心点](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D14)\n\n选中多个物体可以通过下面的菜单栏切换轴心点，默认轴心点为质心点。缩放旋转都是根据轴心点进行的。\n\n合并多个物体后，轴心点会被设置到最后一个选中的物体的轴心点上。分离物体后各个物体的轴心点不会恢复的原有的位置。\n\n“CTRL+ALT+SHIFT+C键”：弹出设置原点菜单，可以修改原点。原点即轴心点。\n\n编辑模式：\n“SHIFT+S键”：（snap）吸附菜单。可以修改游标位置等。\n\n------\n\n#### [15. 内插面&应用缩放比例](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D15)\n\n实体显示状态：属性栏->着色方式->Mapcap修改编辑时的着色方式，不影响渲染。\n\n编辑模式：\n内插面方式一：选择面按E挤出时右键取消实际上还是挤出了，只不过重叠在原有位置。然后按S修改面大小，然后再按E挤出。\n\n内插面方式二：\n“I键”：（insert）插入面。然后再按E挤出。\n\n物体模式：\n“CTRL+A键”：（apply）应用菜单。缩放物体后比例变化，可以应用比例把比例值变为1，其实意思就是应用保存修改。\n\n------\n\n#### [16. 表面细分](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D16)\n\n选中物体添加修改器，添加表面细分修改器。\n表面细分可以配合工具栏->工具中的着色方式（光滑、平直）使用。\n\n快捷键：选中物体按“CTRL+数字键”直接添加表面细分器，数字代表了细分的次数。\n\n------\n\n#### [17. 镜射](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D17)\n\n编辑模式：\n切分后线框模式下按B框选可以选择背后的边。按X删除顶点。添加镜射修改器，根据XYZ轴选择镜射。\n\n勾选镜射修改器的范围限制可以防止交界处分离或者越界。\n\n------\n\n#### [18. 布尔](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D18)\n\n添加布尔修改器，指定参照物体。\n\n布尔插件：Bool Tool。添加插件后，在工具栏->工具下有Bool Tool，选中两个物体可以进行布尔操作。\n\n有时按中键移动视图很慢，按小键盘小数点键恢复一下视图即可。\n\n------\n\n#### [19. 修改器顺序](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D19)\n\n修改器不同的顺序产生不同的效果。\n\n实体修改器增加厚度，比如平面、衣服等厚度。\n\n------\n\n#### [20. 相机设置及渲染](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D20)\n\n“SHIFT+Z键”：切换渲染模式（预览）。\n\n开启快捷切换插件：Pie Menu 3D ->View Numpad Pie: Q。 可以快速切换视图。\n前视图移动物体时按住CTRL可以按网格移动。\n“F12键”：开始渲染。\n“M键”：移动选中物体到不同图层。\n“小键盘0键”：显示相机视图。\n\n选中相机按N打开属性面板->锁定到视图，可以锁定相机视图，此时移动视图然后渲染所见即所得。\n\n渲染窗口：切换底部“槽”可以保存每次的渲染结果。可以使用大键盘数字键来切换槽。\n\n编辑窗口的大键盘数字键可以切换图层（自己试出来的）。\n\n最右属性栏->世界环境->背景->颜色旁的小点弹出菜单可以选择天空纹理。\n\n------\n\n#### [21. 灯光设置](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D21)\n\n灯光没啥好说的，自己试验修改各种参数看效果。日光只有旋转才会有不同效果，移动位置不影响。\n\n使用给平面增加材质来模拟光源：创建平面，增加纹理，修改漫射BSDF为自发光。\n选中这个发光的面，设置物体属性->Cycles 设定->Ray Visibilty->关闭摄像机可以隐藏这个面，但发出的光还是有效。\n可以对这个发光的面进行各种编辑（缩放旋转修改形状等）来产生不同的效果。\n\n基本打光技巧，3个光源（3点光）:\n主光源放在摄像机位置附近、辅助光源小一点放在摄像机侧面使主光源阴影更少一点，再增加一个光源放在摄像机所对物体后面。两个辅助光源都去掉投射阴影（只有灯光才有投射阴影，如果使用材质模拟光则没有。）。\n\n“ALT+S键”：还原缩放。\n“ALT+R键”：还原旋转。\n\n------\n\n#### [22. 提高Cycles渲染速度](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D22)\n\n最右属性栏->渲染->采样：影响渲染效果和速度。\n最右属性栏->渲染层->Denoising：降噪功能。此功能在我的烂显卡上不支持GPU渲染，只能CPU渲染。\n最右属性栏->渲染->分块大小：影响渲染速度。插件：Auto Tile Size，自动根据机器配置设置分块大小。\n\n最右属性栏->渲染->光程：适当调节减小值可以提高速度，我不想调就用默认的。\n\n------\n\n#### [23. 材质](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D23)\n\n各种材质没啥好说的，自己试效果就可以了。\n\n节点编辑器：各种快捷键跟3D视图编辑器差不多。可以新增着色器进行连线等操作。\n\n------\n\n#### [24. Principled着色器](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D24)\n\n世界环境->使用节点->背景->颜色（点按钮）->环境纹理->添加下载好的HDR文件。\n\nPrincipled着色器可以调出金属、塑料、透明等效果。\n\n------\n\n#### [25. blender渲染](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D25)\n\n主要是材质和灯光跟Cycle的不同。\n优势是速度快，但已经不再更新。\n\n------\n\n#### [26. blender卡通渲染](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D26)\n\n主要讲了Blender渲染模式下的卡通效果，具体的操作还是得参考视频。\nfreestyle描边。\n\n------\n\n#### [27. principled着色器补充](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D27)\n\n表面细分：光穿透物体的程度。\nSubsurface Radius：表面细分范围（RGB三色）。\n\n各向异性过滤：配合Metalic(金属）实现类似拉丝金属。\nAnisotropic Rotation：各向异性过滤的旋转角度。\n\n> 我自己网上找的，更详细的Principled 知识参考下面链接：\n> [2.79新材质节点 Principled 图解](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.blendercn.org%2F1771.html%2Fcomment-page-1%23comment-634)\n\n------\n\n#### [28. 表皮修改器制做小青蛙](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D28)\n\n创建平面，选中四点，ALT+M合并到中心，添加镜射修改器，挤出顶点，添加表皮修改器，添加表面细分修改器。\n\n表皮修改器标记根结点。\n对顶点不能直接使用S键缩放，缩放顶点周边使用CTRL+A。\n\n做出大概形状后应用表皮修改器，再进一步进行细化。\n需要先应用镜射修改器再应用表皮修改器。\n表皮修改器可以直接创建简单的骨架。\n\n------\n\n#### [29. UV展开与纹理](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D29)\n\n“U键”：UV映射菜单。\n“CTRL+E键”：(edge)选中边以后，按快捷键弹出边菜单，选择标记缝合边。\n标记缝合边以后再按U->展开UV，然后在底部图像菜单新建图像。\n底部UV菜单导出UV布局图。\n在外部修改UV图像以后，使用新建材质->颜色->图像纹理->载入图像然后即可在材质视图看到效果。\n\n进入底部菜单的“纹理绘制”模式可以直接进行绘制。\n\n------\n\n#### [30. 相机跟踪](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D30)\n\n创建空物体。\n选中摄像机添加标准跟随约束，设置目标为空物体。修改约束中的-Z和向上为Y。\n添加曲线->圆环，放大后CTRL+A应用缩放。\n选中摄像机添加跟随路径约束，设置目标为圆环。\n移动跟随路径约束到标准跟随约束上面。\n点击跟随路径约束的动画路径。\n播放即可实现动画。\n可以对圆环进行各种编辑。\n\n------\n\n#### [31. 父级](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D31)\n\n物体模式：\n“CTRL+P键”：设定父级。\n“ATL+P键”：清空父级。\n\n------\n\n#### [32.1 骨骼之骨骼建立](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D32)\n\n这节课里的lowpoly死侍模型挺好看，可以学着做一个。\n\n骨架的镜像：\n选中骨架->编辑模式->工具栏->选项->X轴镜像\n然后按“SHIFT+E键”挤出骨骼即可左右自动对称挤出。\n对于手臂和腿的挤出使用“ATL+P键”：断开骨骼连接。这样还保持着父级。\n\n头和臂从身体上段挤出，腿从身体下段挤出。\n\n------\n\n#### [32.2 骨骼之权重绘制](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D33)\n\n把骨架做为物体的父级（“CTRL+P键”），附带自动权重。\n“CTRL+TAB键”：骨架姿态模式或者物体权重绘制模式。\n\n权重绘制只对顶点绘制，一般使用工具栏->工具里的F Mix笔刷，权重0表示不受骨骼影响，1表示完全受骨骼影响，其他中间值为部分受骨骼影响。按“F键”可以对笔刷大小缩放。\n\n使用选中物体模块在最右工具栏中数据页指定骨骼的方式可以直接设置权重值。\n\n------\n\n#### [32.3 骨骼之IK骨](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D34)\n\n“SHIFT+I键”：添加IK骨。\n默认IK骨的链长为0会影响所有骨骼，要修改为想要的链长。\n关节处也要增加IK骨。\n精细的多顶点模型有益于Blender创建自动权重的计算。\n\n------\n\n#### [33. 动画](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D35)\n\n“I键”：添加关键帧。\n曲线编辑器：“T键”：修改关键帧插值模式。\n\nN键属性栏可以直接修改关键帧变换数值。\n\n材质的颜色也可以增加关键帧。\n\n------\n\n#### [34. 作业](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D36)\n\n没啥可说的，开始做作业吧。\n\n------\n\n### 三、自己的学习补充\n\n1. 摄像机视角控制\n   小键盘快捷键“0”进入摄像机视图，按“SHIFT+F”，此时可以使用WASD和QE来移动视角（不过有一次我突然发现在此模式下居然无法使用WASDQE移动，然后重启软件后又可以了。)\n\n------\n\n### 四、贴吧看到的Rigify骨架插件使用技巧\n\n还未实践。\n\n> 1.检查模型是否在世界中心，移动/旋转/缩放 模型，并Ctrl+A应用。\n> 2.灯光、摄像机移至其他图层，并将模型贴图设置为Shadeless（个人建议）。\n> 3.分离模型部件（如有需要的话）——分离的目的是为了待会儿更好地分类绑定与权重绘制。\n> 4.开启Rigify插件，Shift+A添加。\n> 5.大致匹配Rigify骨架于模型，并Ctrl+A应用骨架。\n> 6.Tab进入骨架编辑模式，注意开启左侧竖栏Options选项里面的X-Axis Mirror，X轴镜像编辑。\n> 7.对应骨点位置。\n> 8.Check Unity Doc. 删除手指根骨节。\n> 9.Normal Trans Orientation 去查看每个骨节的朝向。\n> 10.Save As，存盘。\n> 11.Generate生成带有控制器的骨架，并将原有基础骨架移至其他层。\n> 12.Check Unity Doc. 选择相应骨架层，重置某些骨节的父子关系。\n> 13.添加附加骨架（如果有需要的话），并为其设置对应的父子关系——需要配合项目骨节数要求。\n> 注意：有些L.R对应的镜像骨节，可以在Normal Trans Orientation（Edit Mode）下查看其轴向,\n> 以确保其在Pose Mode下可以被统一旋转。\n> 14.绑定（为模型与骨架建立父子关系）——建议：Ctrl+P → Automatic Weight\n> 15.选中模型，打开修改器面板下的Armature，勾选【Preserve Volume】如果有需要的话。\n> 16.权重绘制（巧用笔刷工具与顶点遮罩工具）\n> 17.眼球：Modifier, [Track to]\n> 18.表情：Shape Key\n> 19.武器（props）：利用[Child of]修改器与角色骨架建立关系。\n> 20.Remove WGT-Bones in The Hierarchy. Using This Way will Affect Smoothly into Unity.\n> 21.用极限POSE去检查绑定。\n\n暂时到这吧～\n\n![](/end.jpg)","slug":"blender-学习章","published":1,"updated":"2020-02-08T03:23:47.442Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rjk0014zd5b5ki42s1m","content":"<p><img src=\"/2019/07/10/blender-xue-xi-zhang/start.jpg\" alt></p>\n<p>由于自己是做独立游戏开发的，缄默是少不了的。<br>开源免费的Blender近年来大热，做一般游戏建模肯定是没问题的，B站这个教程很不错：</p>\n<h4 id=\"【跟顺子老师学3D】blender零基础入门教程【全】\"><a href=\"#【跟顺子老师学3D】blender零基础入门教程【全】\" class=\"headerlink\" title=\"【跟顺子老师学3D】blender零基础入门教程【全】\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D1\" target=\"_blank\" rel=\"noopener\">【跟顺子老师学3D】blender零基础入门教程【全】</a></h4><p>一晚上一口气就看了十几课，速度快一点的话两三天就可以学完，Blender的快捷键非常多而且使用频繁，对于一个初学者来说很容易就忘光了，然后回头在视频里查找又是比较没效率的事情，所以必须写点笔记。</p>\n<h3 id=\"一、结合Unity\"><a href=\"#一、结合Unity\" class=\"headerlink\" title=\"一、结合Unity\"></a>一、结合Unity</h3><p>Unity游戏开发用了5年多了，一开始使用blender时很困惑，因为坐标系跟Unity完全不一样， Z轴居然向上，在以前的Unity老版本里好像还要自己进行手动转换坐标，而在当前Unity 2018版本可以直接拖动blender的文件到项目里，会自动转换坐标，转换后的视角相当于blender里的后视图的视角。</p>\n<blockquote>\n<p><strong>2018.7.3：今天特意试了一下把blender工程文件直接保存到unity目录下，然后加入到场景中，发现Cycles渲染模式下创建的材质全部都不能正常显示，又试了一下Blender渲染模式可以正常显示，而且在Blender中所作的修改可以在Unity中自动刷新载入显示。其实想想也正常，毕竟Cycles渲染是离线渲染而Unity是实时渲染，无法直接使用是很正常的。</strong><br><strong>因为我主要应用于Unity，所以平常还是多学习Blender渲染模式，除非一些高质量场景使用烘焙的情况才使用Cycles。</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>2018.7.6：尝试导出包含骨骼动画的fbx文件然后在Unity中载入。出现了很多奇怪的问题，比如人物部分位置偏移（好像是使用了IK骨的原因）。最终还是使用blender源文件直接载入到Unity中，然后一点问题都没有了，WTF！真是折腾死我了。</strong></p>\n</blockquote>\n<h3 id=\"二、视频学习笔记\"><a href=\"#二、视频学习笔记\" class=\"headerlink\" title=\"二、视频学习笔记\"></a>二、视频学习笔记</h3><p>目前Blender 2.8版本还没正式推出，视频里使用的是2.79版，我使用2.79b版本好像没什么区别。</p>\n<hr>\n<h4 id=\"01-简介\"><a href=\"#01-简介\" class=\"headerlink\" title=\"01. 简介\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D1\" target=\"_blank\" rel=\"noopener\">01. 简介</a></h4><p>下载安装软件，没啥可说的。</p>\n<hr>\n<h4 id=\"02-界面及基本操作\"><a href=\"#02-界面及基本操作\" class=\"headerlink\" title=\"02. 界面及基本操作\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D2\" target=\"_blank\" rel=\"noopener\">02. 界面及基本操作</a></h4><p>中文界面设置：”File” -&gt; “User Preference”-&gt;“System”，将滚动条拉到下面，勾选“International Fonts”在下面，选择Language 为“simplified Chinese(简体中文)”。<br>勾选下面的“Interface”和“Tooltips”，不要选择“New Data”（因为可能一些插件不支持中文路径。）</p>\n<p>同页面的Cycles Compute Device选择CUDA，再选中下面的显卡，这样在主窗口可以选择Cycles渲染。</p>\n<p>勾选“界面”页中的“自动透视模式”。</p>\n<p>关闭设置窗口前注意要点击左下角“保存用户设置”，否则重启后丢失修改的设置。</p>\n<p>滚动鼠标中键：视图缩放。<br>按住鼠标中键：视图旋转。<br>SHIFT+鼠标中键：视图平移。<br>鼠标右键：选中目标。</p>\n<p>多窗口分割：拖动窗口边缘的三角形。<br>多窗口关闭：拖动窗口边缘的三角形到反方向。<br>每个分割窗口左下角或者右上角按钮可以切换不同视图。<br>“T键”：切换工具栏显示。<br>“N键”：切换属性栏显示。<br>小键盘区：<br>“5”：透视/正交视图切换。<br>其他键懒得写了，各种视图切换。</p>\n<p>无小键盘（比如笔记本）：启用自带插件“3D View:3D Navigation，然后在工具栏的“显示”页里点击按钮代替小键盘。</p>\n<p>选择物体后：<br>“G键”：（grab)移动物体。然后按X,Y,Z可以根据轴移动。按SHIFT+X/Y/Z可以锁定X/Y/Z，然后根据其他轴移动（此功能还不如直接在正交视图中移动）。<br>“S键”：（scale)缩放物体。然后按X,Y,Z可以根据轴缩放。<br>“R键”：（rotate)旋转物体。然后按X,Y,Z可以根据轴旋转。双击“R”实现360度立体旋转。<br>GSR操作时按住“SHIFT”键可以精细操作。<br>切换GSR操作的参照坐标系：切换窗口下面的菜单栏里的“全局”和“自身”。</p>\n<p>“SHIFT+C”：3D游标恢复到视图中心。<br>“SHIFT+A”：（add）（在3D游标处）添加物体。<br>“X键”：删除物体。</p>\n<hr>\n<h4 id=\"03-主题安装及其他补充\"><a href=\"#03-主题安装及其他补充\" class=\"headerlink\" title=\"03. 主题安装及其他补充\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D3\" target=\"_blank\" rel=\"noopener\">03. 主题安装及其他补充</a></h4><p>energy(能量)主题：<br>原作者：<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fstudiollb.wordpress.com%2Fdownload%2F\" target=\"_blank\" rel=\"noopener\">https://studiollb.wordpress.com/download/</a></p>\n<hr>\n<h4 id=\"04-保存和备份\"><a href=\"#04-保存和备份\" class=\"headerlink\" title=\"04. 保存和备份\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D4\" target=\"_blank\" rel=\"noopener\">04. 保存和备份</a></h4><p>保存时会自动产生一个备份文件。<br>保存窗口里的“+”、“-”按钮可以自动递增递减文件名。</p>\n<hr>\n<h4 id=\"05-编辑模式基本操作\"><a href=\"#05-编辑模式基本操作\" class=\"headerlink\" title=\"05. 编辑模式基本操作\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D5\" target=\"_blank\" rel=\"noopener\">05. 编辑模式基本操作</a></h4><p>“TAB键”：切换编辑模式/物体模式。<br>编辑模式：<br>“CTRL+TAB键”：切换顶点/边/面。<br>“A键”：全选或者取消全选。<br>“SHIFT+鼠标右键”：多选点线面。</p>\n<hr>\n<h4 id=\"06-编辑模式下的多选\"><a href=\"#06-编辑模式下的多选\" class=\"headerlink\" title=\"06. 编辑模式下的多选\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D6\" target=\"_blank\" rel=\"noopener\">06. 编辑模式下的多选</a></h4><p>编辑模式：<br>“CTRL+鼠标左键”：自动选择邻近点线面。<br>“ALT+鼠标左键”：选中整行或者整列点线面。<br>“C键”：自由刷选。可以滚动鼠标中键来控制刷选区大小。左键选中，中键按下取消选择。<br>“B键”：（box)框选。<br>“CTRL+鼠标左键拖动”：在按下后可以自由拖选。<br>“L键”：全选鼠标所在点线面的物体。<br>“CTRL+小键盘加号”：扩展选区。<br>“CTRL+小键盘减号”：缩减选区。</p>\n<hr>\n<h4 id=\"07-环切\"><a href=\"#07-环切\" class=\"headerlink\" title=\"07. 环切\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D7\" target=\"_blank\" rel=\"noopener\">07. 环切</a></h4><p>编辑模式：<br>“CTRL+R”：环切。环切时滚动滚轮可以切多刀。</p>\n<hr>\n<h4 id=\"08-细分\"><a href=\"#08-细分\" class=\"headerlink\" title=\"08. 细分\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D8\" target=\"_blank\" rel=\"noopener\">08. 细分</a></h4><p>编辑模式：<br>细分：选中物体后按“W键”弹出菜单，选择“细分”。细分时工具栏的细分选项页可以控制切割次数。<br>“SHIFT+R”：(repeat)重做上一次操作。</p>\n<p>细分主要对面操作，对边也可以细分但是细分为点。顶点无法细分。</p>\n<p>“CTRL+E”：反细分。（不在课程内，自己查的）。</p>\n<hr>\n<h4 id=\"09-挤出\"><a href=\"#09-挤出\" class=\"headerlink\" title=\"09. 挤出\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D9\" target=\"_blank\" rel=\"noopener\">09. 挤出</a></h4><p>编辑模式：<br>“E键”：选中点线面都可以挤出，但一般主要对面操作。</p>\n<p>挤出时右键取消实际上还是挤出了，只不过重叠在原有位置。</p>\n<p>环切左键确定后可以按“S键”然后移动坐标轴进行缩放环切线。缩放时可以直接输入缩放倍数，在左下角有显示缩放当前倍数。</p>\n<hr>\n<h4 id=\"10-倒角\"><a href=\"#10-倒角\" class=\"headerlink\" title=\"10. 倒角\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D10\" target=\"_blank\" rel=\"noopener\">10. 倒角</a></h4><p>编辑模式：<br>选中边，按“CTRL+B”进行倒角，此时可以滚动滚轮增加倒角边。</p>\n<p>环切确认后也可以按“CTRL+B”和滚轮增加环切边。</p>\n<hr>\n<h4 id=\"11-合并与分离\"><a href=\"#11-合并与分离\" class=\"headerlink\" title=\"11. 合并与分离\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D11\" target=\"_blank\" rel=\"noopener\">11. 合并与分离</a></h4><p><strong>物体的合并与分离：</strong><br>物体模式：<br>“CTRL+J”：“join”。合并选中的多个物体。合并后的轴心在最后选中物体的轴心。<br>编辑模式：<br>“P键”：选中物体后按P键弹跳出菜单可以进行多种分离模式。没选中任何物体时也可以按P键进行按松散块分离。</p>\n<p><strong>顶点的合并与分离：</strong><br>“V键”：选中顶点后进行按键拖动分离。此模式比较坑的一点是就算按鼠标右键取消分离，其实也还是分离了，如果不想分离只能按CTRL+Z撤消操作。<br>“ALT+M键”：选中两个点按键后弹出菜单合并。</p>\n<hr>\n<h4 id=\"12-创建边与面\"><a href=\"#12-创建边与面\" class=\"headerlink\" title=\"12. 创建边与面\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D12\" target=\"_blank\" rel=\"noopener\">12. 创建边与面</a></h4><p>编辑模式：<br>“F键”：(fill)选中点或者边，然后按F键进行填充边或者面。</p>\n<hr>\n<h4 id=\"13-衰减编辑\"><a href=\"#13-衰减编辑\" class=\"headerlink\" title=\"13. 衰减编辑\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D13\" target=\"_blank\" rel=\"noopener\">13. 衰减编辑</a></h4><p>编辑模式：<br>“O键”：启用衰减编辑。底下菜单栏也可以选择，还可以切换衰减模式。<br>衰减编辑模式：<br>“G键”：此时滚动鼠标滚轮控制衰减范围。<br>“ALT+O键”：“衰减编辑模式-相连项”：开启后不会影响不相连的其他物体。</p>\n<hr>\n<h4 id=\"14-轴心点\"><a href=\"#14-轴心点\" class=\"headerlink\" title=\"14. 轴心点\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D14\" target=\"_blank\" rel=\"noopener\">14. 轴心点</a></h4><p>选中多个物体可以通过下面的菜单栏切换轴心点，默认轴心点为质心点。缩放旋转都是根据轴心点进行的。</p>\n<p>合并多个物体后，轴心点会被设置到最后一个选中的物体的轴心点上。分离物体后各个物体的轴心点不会恢复的原有的位置。</p>\n<p>“CTRL+ALT+SHIFT+C键”：弹出设置原点菜单，可以修改原点。原点即轴心点。</p>\n<p>编辑模式：<br>“SHIFT+S键”：（snap）吸附菜单。可以修改游标位置等。</p>\n<hr>\n<h4 id=\"15-内插面-amp-应用缩放比例\"><a href=\"#15-内插面-amp-应用缩放比例\" class=\"headerlink\" title=\"15. 内插面&amp;应用缩放比例\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D15\" target=\"_blank\" rel=\"noopener\">15. 内插面&amp;应用缩放比例</a></h4><p>实体显示状态：属性栏-&gt;着色方式-&gt;Mapcap修改编辑时的着色方式，不影响渲染。</p>\n<p>编辑模式：<br>内插面方式一：选择面按E挤出时右键取消实际上还是挤出了，只不过重叠在原有位置。然后按S修改面大小，然后再按E挤出。</p>\n<p>内插面方式二：<br>“I键”：（insert）插入面。然后再按E挤出。</p>\n<p>物体模式：<br>“CTRL+A键”：（apply）应用菜单。缩放物体后比例变化，可以应用比例把比例值变为1，其实意思就是应用保存修改。</p>\n<hr>\n<h4 id=\"16-表面细分\"><a href=\"#16-表面细分\" class=\"headerlink\" title=\"16. 表面细分\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D16\" target=\"_blank\" rel=\"noopener\">16. 表面细分</a></h4><p>选中物体添加修改器，添加表面细分修改器。<br>表面细分可以配合工具栏-&gt;工具中的着色方式（光滑、平直）使用。</p>\n<p>快捷键：选中物体按“CTRL+数字键”直接添加表面细分器，数字代表了细分的次数。</p>\n<hr>\n<h4 id=\"17-镜射\"><a href=\"#17-镜射\" class=\"headerlink\" title=\"17. 镜射\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D17\" target=\"_blank\" rel=\"noopener\">17. 镜射</a></h4><p>编辑模式：<br>切分后线框模式下按B框选可以选择背后的边。按X删除顶点。添加镜射修改器，根据XYZ轴选择镜射。</p>\n<p>勾选镜射修改器的范围限制可以防止交界处分离或者越界。</p>\n<hr>\n<h4 id=\"18-布尔\"><a href=\"#18-布尔\" class=\"headerlink\" title=\"18. 布尔\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D18\" target=\"_blank\" rel=\"noopener\">18. 布尔</a></h4><p>添加布尔修改器，指定参照物体。</p>\n<p>布尔插件：Bool Tool。添加插件后，在工具栏-&gt;工具下有Bool Tool，选中两个物体可以进行布尔操作。</p>\n<p>有时按中键移动视图很慢，按小键盘小数点键恢复一下视图即可。</p>\n<hr>\n<h4 id=\"19-修改器顺序\"><a href=\"#19-修改器顺序\" class=\"headerlink\" title=\"19. 修改器顺序\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D19\" target=\"_blank\" rel=\"noopener\">19. 修改器顺序</a></h4><p>修改器不同的顺序产生不同的效果。</p>\n<p>实体修改器增加厚度，比如平面、衣服等厚度。</p>\n<hr>\n<h4 id=\"20-相机设置及渲染\"><a href=\"#20-相机设置及渲染\" class=\"headerlink\" title=\"20. 相机设置及渲染\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D20\" target=\"_blank\" rel=\"noopener\">20. 相机设置及渲染</a></h4><p>“SHIFT+Z键”：切换渲染模式（预览）。</p>\n<p>开启快捷切换插件：Pie Menu 3D -&gt;View Numpad Pie: Q。 可以快速切换视图。<br>前视图移动物体时按住CTRL可以按网格移动。<br>“F12键”：开始渲染。<br>“M键”：移动选中物体到不同图层。<br>“小键盘0键”：显示相机视图。</p>\n<p>选中相机按N打开属性面板-&gt;锁定到视图，可以锁定相机视图，此时移动视图然后渲染所见即所得。</p>\n<p>渲染窗口：切换底部“槽”可以保存每次的渲染结果。可以使用大键盘数字键来切换槽。</p>\n<p>编辑窗口的大键盘数字键可以切换图层（自己试出来的）。</p>\n<p>最右属性栏-&gt;世界环境-&gt;背景-&gt;颜色旁的小点弹出菜单可以选择天空纹理。</p>\n<hr>\n<h4 id=\"21-灯光设置\"><a href=\"#21-灯光设置\" class=\"headerlink\" title=\"21. 灯光设置\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D21\" target=\"_blank\" rel=\"noopener\">21. 灯光设置</a></h4><p>灯光没啥好说的，自己试验修改各种参数看效果。日光只有旋转才会有不同效果，移动位置不影响。</p>\n<p>使用给平面增加材质来模拟光源：创建平面，增加纹理，修改漫射BSDF为自发光。<br>选中这个发光的面，设置物体属性-&gt;Cycles 设定-&gt;Ray Visibilty-&gt;关闭摄像机可以隐藏这个面，但发出的光还是有效。<br>可以对这个发光的面进行各种编辑（缩放旋转修改形状等）来产生不同的效果。</p>\n<p>基本打光技巧，3个光源（3点光）:<br>主光源放在摄像机位置附近、辅助光源小一点放在摄像机侧面使主光源阴影更少一点，再增加一个光源放在摄像机所对物体后面。两个辅助光源都去掉投射阴影（只有灯光才有投射阴影，如果使用材质模拟光则没有。）。</p>\n<p>“ALT+S键”：还原缩放。<br>“ALT+R键”：还原旋转。</p>\n<hr>\n<h4 id=\"22-提高Cycles渲染速度\"><a href=\"#22-提高Cycles渲染速度\" class=\"headerlink\" title=\"22. 提高Cycles渲染速度\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D22\" target=\"_blank\" rel=\"noopener\">22. 提高Cycles渲染速度</a></h4><p>最右属性栏-&gt;渲染-&gt;采样：影响渲染效果和速度。<br>最右属性栏-&gt;渲染层-&gt;Denoising：降噪功能。此功能在我的烂显卡上不支持GPU渲染，只能CPU渲染。<br>最右属性栏-&gt;渲染-&gt;分块大小：影响渲染速度。插件：Auto Tile Size，自动根据机器配置设置分块大小。</p>\n<p>最右属性栏-&gt;渲染-&gt;光程：适当调节减小值可以提高速度，我不想调就用默认的。</p>\n<hr>\n<h4 id=\"23-材质\"><a href=\"#23-材质\" class=\"headerlink\" title=\"23. 材质\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D23\" target=\"_blank\" rel=\"noopener\">23. 材质</a></h4><p>各种材质没啥好说的，自己试效果就可以了。</p>\n<p>节点编辑器：各种快捷键跟3D视图编辑器差不多。可以新增着色器进行连线等操作。</p>\n<hr>\n<h4 id=\"24-Principled着色器\"><a href=\"#24-Principled着色器\" class=\"headerlink\" title=\"24. Principled着色器\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D24\" target=\"_blank\" rel=\"noopener\">24. Principled着色器</a></h4><p>世界环境-&gt;使用节点-&gt;背景-&gt;颜色（点按钮）-&gt;环境纹理-&gt;添加下载好的HDR文件。</p>\n<p>Principled着色器可以调出金属、塑料、透明等效果。</p>\n<hr>\n<h4 id=\"25-blender渲染\"><a href=\"#25-blender渲染\" class=\"headerlink\" title=\"25. blender渲染\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D25\" target=\"_blank\" rel=\"noopener\">25. blender渲染</a></h4><p>主要是材质和灯光跟Cycle的不同。<br>优势是速度快，但已经不再更新。</p>\n<hr>\n<h4 id=\"26-blender卡通渲染\"><a href=\"#26-blender卡通渲染\" class=\"headerlink\" title=\"26. blender卡通渲染\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D26\" target=\"_blank\" rel=\"noopener\">26. blender卡通渲染</a></h4><p>主要讲了Blender渲染模式下的卡通效果，具体的操作还是得参考视频。<br>freestyle描边。</p>\n<hr>\n<h4 id=\"27-principled着色器补充\"><a href=\"#27-principled着色器补充\" class=\"headerlink\" title=\"27. principled着色器补充\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D27\" target=\"_blank\" rel=\"noopener\">27. principled着色器补充</a></h4><p>表面细分：光穿透物体的程度。<br>Subsurface Radius：表面细分范围（RGB三色）。</p>\n<p>各向异性过滤：配合Metalic(金属）实现类似拉丝金属。<br>Anisotropic Rotation：各向异性过滤的旋转角度。</p>\n<blockquote>\n<p>我自己网上找的，更详细的Principled 知识参考下面链接：<br><a href=\"https://links.jianshu.com/go?to=http%3A%2F%2Fwww.blendercn.org%2F1771.html%2Fcomment-page-1%23comment-634\" target=\"_blank\" rel=\"noopener\">2.79新材质节点 Principled 图解</a></p>\n</blockquote>\n<hr>\n<h4 id=\"28-表皮修改器制做小青蛙\"><a href=\"#28-表皮修改器制做小青蛙\" class=\"headerlink\" title=\"28. 表皮修改器制做小青蛙\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D28\" target=\"_blank\" rel=\"noopener\">28. 表皮修改器制做小青蛙</a></h4><p>创建平面，选中四点，ALT+M合并到中心，添加镜射修改器，挤出顶点，添加表皮修改器，添加表面细分修改器。</p>\n<p>表皮修改器标记根结点。<br>对顶点不能直接使用S键缩放，缩放顶点周边使用CTRL+A。</p>\n<p>做出大概形状后应用表皮修改器，再进一步进行细化。<br>需要先应用镜射修改器再应用表皮修改器。<br>表皮修改器可以直接创建简单的骨架。</p>\n<hr>\n<h4 id=\"29-UV展开与纹理\"><a href=\"#29-UV展开与纹理\" class=\"headerlink\" title=\"29. UV展开与纹理\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D29\" target=\"_blank\" rel=\"noopener\">29. UV展开与纹理</a></h4><p>“U键”：UV映射菜单。<br>“CTRL+E键”：(edge)选中边以后，按快捷键弹出边菜单，选择标记缝合边。<br>标记缝合边以后再按U-&gt;展开UV，然后在底部图像菜单新建图像。<br>底部UV菜单导出UV布局图。<br>在外部修改UV图像以后，使用新建材质-&gt;颜色-&gt;图像纹理-&gt;载入图像然后即可在材质视图看到效果。</p>\n<p>进入底部菜单的“纹理绘制”模式可以直接进行绘制。</p>\n<hr>\n<h4 id=\"30-相机跟踪\"><a href=\"#30-相机跟踪\" class=\"headerlink\" title=\"30. 相机跟踪\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D30\" target=\"_blank\" rel=\"noopener\">30. 相机跟踪</a></h4><p>创建空物体。<br>选中摄像机添加标准跟随约束，设置目标为空物体。修改约束中的-Z和向上为Y。<br>添加曲线-&gt;圆环，放大后CTRL+A应用缩放。<br>选中摄像机添加跟随路径约束，设置目标为圆环。<br>移动跟随路径约束到标准跟随约束上面。<br>点击跟随路径约束的动画路径。<br>播放即可实现动画。<br>可以对圆环进行各种编辑。</p>\n<hr>\n<h4 id=\"31-父级\"><a href=\"#31-父级\" class=\"headerlink\" title=\"31. 父级\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D31\" target=\"_blank\" rel=\"noopener\">31. 父级</a></h4><p>物体模式：<br>“CTRL+P键”：设定父级。<br>“ATL+P键”：清空父级。</p>\n<hr>\n<h4 id=\"32-1-骨骼之骨骼建立\"><a href=\"#32-1-骨骼之骨骼建立\" class=\"headerlink\" title=\"32.1 骨骼之骨骼建立\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D32\" target=\"_blank\" rel=\"noopener\">32.1 骨骼之骨骼建立</a></h4><p>这节课里的lowpoly死侍模型挺好看，可以学着做一个。</p>\n<p>骨架的镜像：<br>选中骨架-&gt;编辑模式-&gt;工具栏-&gt;选项-&gt;X轴镜像<br>然后按“SHIFT+E键”挤出骨骼即可左右自动对称挤出。<br>对于手臂和腿的挤出使用“ATL+P键”：断开骨骼连接。这样还保持着父级。</p>\n<p>头和臂从身体上段挤出，腿从身体下段挤出。</p>\n<hr>\n<h4 id=\"32-2-骨骼之权重绘制\"><a href=\"#32-2-骨骼之权重绘制\" class=\"headerlink\" title=\"32.2 骨骼之权重绘制\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D33\" target=\"_blank\" rel=\"noopener\">32.2 骨骼之权重绘制</a></h4><p>把骨架做为物体的父级（“CTRL+P键”），附带自动权重。<br>“CTRL+TAB键”：骨架姿态模式或者物体权重绘制模式。</p>\n<p>权重绘制只对顶点绘制，一般使用工具栏-&gt;工具里的F Mix笔刷，权重0表示不受骨骼影响，1表示完全受骨骼影响，其他中间值为部分受骨骼影响。按“F键”可以对笔刷大小缩放。</p>\n<p>使用选中物体模块在最右工具栏中数据页指定骨骼的方式可以直接设置权重值。</p>\n<hr>\n<h4 id=\"32-3-骨骼之IK骨\"><a href=\"#32-3-骨骼之IK骨\" class=\"headerlink\" title=\"32.3 骨骼之IK骨\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D34\" target=\"_blank\" rel=\"noopener\">32.3 骨骼之IK骨</a></h4><p>“SHIFT+I键”：添加IK骨。<br>默认IK骨的链长为0会影响所有骨骼，要修改为想要的链长。<br>关节处也要增加IK骨。<br>精细的多顶点模型有益于Blender创建自动权重的计算。</p>\n<hr>\n<h4 id=\"33-动画\"><a href=\"#33-动画\" class=\"headerlink\" title=\"33. 动画\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D35\" target=\"_blank\" rel=\"noopener\">33. 动画</a></h4><p>“I键”：添加关键帧。<br>曲线编辑器：“T键”：修改关键帧插值模式。</p>\n<p>N键属性栏可以直接修改关键帧变换数值。</p>\n<p>材质的颜色也可以增加关键帧。</p>\n<hr>\n<h4 id=\"34-作业\"><a href=\"#34-作业\" class=\"headerlink\" title=\"34. 作业\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D36\" target=\"_blank\" rel=\"noopener\">34. 作业</a></h4><p>没啥可说的，开始做作业吧。</p>\n<hr>\n<h3 id=\"三、自己的学习补充\"><a href=\"#三、自己的学习补充\" class=\"headerlink\" title=\"三、自己的学习补充\"></a>三、自己的学习补充</h3><ol>\n<li>摄像机视角控制<br>小键盘快捷键“0”进入摄像机视图，按“SHIFT+F”，此时可以使用WASD和QE来移动视角（不过有一次我突然发现在此模式下居然无法使用WASDQE移动，然后重启软件后又可以了。)</li>\n</ol>\n<hr>\n<h3 id=\"四、贴吧看到的Rigify骨架插件使用技巧\"><a href=\"#四、贴吧看到的Rigify骨架插件使用技巧\" class=\"headerlink\" title=\"四、贴吧看到的Rigify骨架插件使用技巧\"></a>四、贴吧看到的Rigify骨架插件使用技巧</h3><p>还未实践。</p>\n<blockquote>\n<p>1.检查模型是否在世界中心，移动/旋转/缩放 模型，并Ctrl+A应用。<br>2.灯光、摄像机移至其他图层，并将模型贴图设置为Shadeless（个人建议）。<br>3.分离模型部件（如有需要的话）——分离的目的是为了待会儿更好地分类绑定与权重绘制。<br>4.开启Rigify插件，Shift+A添加。<br>5.大致匹配Rigify骨架于模型，并Ctrl+A应用骨架。<br>6.Tab进入骨架编辑模式，注意开启左侧竖栏Options选项里面的X-Axis Mirror，X轴镜像编辑。<br>7.对应骨点位置。<br>8.Check Unity Doc. 删除手指根骨节。<br>9.Normal Trans Orientation 去查看每个骨节的朝向。<br>10.Save As，存盘。<br>11.Generate生成带有控制器的骨架，并将原有基础骨架移至其他层。<br>12.Check Unity Doc. 选择相应骨架层，重置某些骨节的父子关系。<br>13.添加附加骨架（如果有需要的话），并为其设置对应的父子关系——需要配合项目骨节数要求。<br>注意：有些L.R对应的镜像骨节，可以在Normal Trans Orientation（Edit Mode）下查看其轴向,<br>以确保其在Pose Mode下可以被统一旋转。<br>14.绑定（为模型与骨架建立父子关系）——建议：Ctrl+P → Automatic Weight<br>15.选中模型，打开修改器面板下的Armature，勾选【Preserve Volume】如果有需要的话。<br>16.权重绘制（巧用笔刷工具与顶点遮罩工具）<br>17.眼球：Modifier, [Track to]<br>18.表情：Shape Key<br>19.武器（props）：利用[Child of]修改器与角色骨架建立关系。<br>20.Remove WGT-Bones in The Hierarchy. Using This Way will Affect Smoothly into Unity.<br>21.用极限POSE去检查绑定。</p>\n</blockquote>\n<p>暂时到这吧～</p>\n<p><img src=\"/2019/07/10/blender-xue-xi-zhang/end.jpg\" alt></p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<p><img src=\"/2019/07/10/blender-xue-xi-zhang/start.jpg\" alt></p>\n<p>由于自己是做独立游戏开发的，缄默是少不了的。<br>开源免费的Blender近年来大热，做一般游戏建模肯定是没问题的，B站这个教程很不错：</p>\n<h4 id=\"【跟顺子老师学3D】blender零基础入门教程【全】\"><a href=\"#【跟顺子老师学3D】blender零基础入门教程【全】\" class=\"headerlink\" title=\"【跟顺子老师学3D】blender零基础入门教程【全】\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D1\" target=\"_blank\" rel=\"noopener\">【跟顺子老师学3D】blender零基础入门教程【全】</a></h4><p>一晚上一口气就看了十几课，速度快一点的话两三天就可以学完，Blender的快捷键非常多而且使用频繁，对于一个初学者来说很容易就忘光了，然后回头在视频里查找又是比较没效率的事情，所以必须写点笔记。</p>\n<h3 id=\"一、结合Unity\"><a href=\"#一、结合Unity\" class=\"headerlink\" title=\"一、结合Unity\"></a>一、结合Unity</h3><p>Unity游戏开发用了5年多了，一开始使用blender时很困惑，因为坐标系跟Unity完全不一样， Z轴居然向上，在以前的Unity老版本里好像还要自己进行手动转换坐标，而在当前Unity 2018版本可以直接拖动blender的文件到项目里，会自动转换坐标，转换后的视角相当于blender里的后视图的视角。</p>\n<blockquote>\n<p><strong>2018.7.3：今天特意试了一下把blender工程文件直接保存到unity目录下，然后加入到场景中，发现Cycles渲染模式下创建的材质全部都不能正常显示，又试了一下Blender渲染模式可以正常显示，而且在Blender中所作的修改可以在Unity中自动刷新载入显示。其实想想也正常，毕竟Cycles渲染是离线渲染而Unity是实时渲染，无法直接使用是很正常的。</strong><br><strong>因为我主要应用于Unity，所以平常还是多学习Blender渲染模式，除非一些高质量场景使用烘焙的情况才使用Cycles。</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>2018.7.6：尝试导出包含骨骼动画的fbx文件然后在Unity中载入。出现了很多奇怪的问题，比如人物部分位置偏移（好像是使用了IK骨的原因）。最终还是使用blender源文件直接载入到Unity中，然后一点问题都没有了，WTF！真是折腾死我了。</strong></p>\n</blockquote>\n<h3 id=\"二、视频学习笔记\"><a href=\"#二、视频学习笔记\" class=\"headerlink\" title=\"二、视频学习笔记\"></a>二、视频学习笔记</h3><p>目前Blender 2.8版本还没正式推出，视频里使用的是2.79版，我使用2.79b版本好像没什么区别。</p>\n<hr>\n<h4 id=\"01-简介\"><a href=\"#01-简介\" class=\"headerlink\" title=\"01. 简介\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D1\" target=\"_blank\" rel=\"noopener\">01. 简介</a></h4><p>下载安装软件，没啥可说的。</p>\n<hr>\n<h4 id=\"02-界面及基本操作\"><a href=\"#02-界面及基本操作\" class=\"headerlink\" title=\"02. 界面及基本操作\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D2\" target=\"_blank\" rel=\"noopener\">02. 界面及基本操作</a></h4><p>中文界面设置：”File” -&gt; “User Preference”-&gt;“System”，将滚动条拉到下面，勾选“International Fonts”在下面，选择Language 为“simplified Chinese(简体中文)”。<br>勾选下面的“Interface”和“Tooltips”，不要选择“New Data”（因为可能一些插件不支持中文路径。）</p>\n<p>同页面的Cycles Compute Device选择CUDA，再选中下面的显卡，这样在主窗口可以选择Cycles渲染。</p>\n<p>勾选“界面”页中的“自动透视模式”。</p>\n<p>关闭设置窗口前注意要点击左下角“保存用户设置”，否则重启后丢失修改的设置。</p>\n<p>滚动鼠标中键：视图缩放。<br>按住鼠标中键：视图旋转。<br>SHIFT+鼠标中键：视图平移。<br>鼠标右键：选中目标。</p>\n<p>多窗口分割：拖动窗口边缘的三角形。<br>多窗口关闭：拖动窗口边缘的三角形到反方向。<br>每个分割窗口左下角或者右上角按钮可以切换不同视图。<br>“T键”：切换工具栏显示。<br>“N键”：切换属性栏显示。<br>小键盘区：<br>“5”：透视/正交视图切换。<br>其他键懒得写了，各种视图切换。</p>\n<p>无小键盘（比如笔记本）：启用自带插件“3D View:3D Navigation，然后在工具栏的“显示”页里点击按钮代替小键盘。</p>\n<p>选择物体后：<br>“G键”：（grab)移动物体。然后按X,Y,Z可以根据轴移动。按SHIFT+X/Y/Z可以锁定X/Y/Z，然后根据其他轴移动（此功能还不如直接在正交视图中移动）。<br>“S键”：（scale)缩放物体。然后按X,Y,Z可以根据轴缩放。<br>“R键”：（rotate)旋转物体。然后按X,Y,Z可以根据轴旋转。双击“R”实现360度立体旋转。<br>GSR操作时按住“SHIFT”键可以精细操作。<br>切换GSR操作的参照坐标系：切换窗口下面的菜单栏里的“全局”和“自身”。</p>\n<p>“SHIFT+C”：3D游标恢复到视图中心。<br>“SHIFT+A”：（add）（在3D游标处）添加物体。<br>“X键”：删除物体。</p>\n<hr>\n<h4 id=\"03-主题安装及其他补充\"><a href=\"#03-主题安装及其他补充\" class=\"headerlink\" title=\"03. 主题安装及其他补充\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D3\" target=\"_blank\" rel=\"noopener\">03. 主题安装及其他补充</a></h4><p>energy(能量)主题：<br>原作者：<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fstudiollb.wordpress.com%2Fdownload%2F\" target=\"_blank\" rel=\"noopener\">https://studiollb.wordpress.com/download/</a></p>\n<hr>\n<h4 id=\"04-保存和备份\"><a href=\"#04-保存和备份\" class=\"headerlink\" title=\"04. 保存和备份\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D4\" target=\"_blank\" rel=\"noopener\">04. 保存和备份</a></h4><p>保存时会自动产生一个备份文件。<br>保存窗口里的“+”、“-”按钮可以自动递增递减文件名。</p>\n<hr>\n<h4 id=\"05-编辑模式基本操作\"><a href=\"#05-编辑模式基本操作\" class=\"headerlink\" title=\"05. 编辑模式基本操作\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D5\" target=\"_blank\" rel=\"noopener\">05. 编辑模式基本操作</a></h4><p>“TAB键”：切换编辑模式/物体模式。<br>编辑模式：<br>“CTRL+TAB键”：切换顶点/边/面。<br>“A键”：全选或者取消全选。<br>“SHIFT+鼠标右键”：多选点线面。</p>\n<hr>\n<h4 id=\"06-编辑模式下的多选\"><a href=\"#06-编辑模式下的多选\" class=\"headerlink\" title=\"06. 编辑模式下的多选\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D6\" target=\"_blank\" rel=\"noopener\">06. 编辑模式下的多选</a></h4><p>编辑模式：<br>“CTRL+鼠标左键”：自动选择邻近点线面。<br>“ALT+鼠标左键”：选中整行或者整列点线面。<br>“C键”：自由刷选。可以滚动鼠标中键来控制刷选区大小。左键选中，中键按下取消选择。<br>“B键”：（box)框选。<br>“CTRL+鼠标左键拖动”：在按下后可以自由拖选。<br>“L键”：全选鼠标所在点线面的物体。<br>“CTRL+小键盘加号”：扩展选区。<br>“CTRL+小键盘减号”：缩减选区。</p>\n<hr>\n<h4 id=\"07-环切\"><a href=\"#07-环切\" class=\"headerlink\" title=\"07. 环切\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D7\" target=\"_blank\" rel=\"noopener\">07. 环切</a></h4><p>编辑模式：<br>“CTRL+R”：环切。环切时滚动滚轮可以切多刀。</p>\n<hr>\n<h4 id=\"08-细分\"><a href=\"#08-细分\" class=\"headerlink\" title=\"08. 细分\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D8\" target=\"_blank\" rel=\"noopener\">08. 细分</a></h4><p>编辑模式：<br>细分：选中物体后按“W键”弹出菜单，选择“细分”。细分时工具栏的细分选项页可以控制切割次数。<br>“SHIFT+R”：(repeat)重做上一次操作。</p>\n<p>细分主要对面操作，对边也可以细分但是细分为点。顶点无法细分。</p>\n<p>“CTRL+E”：反细分。（不在课程内，自己查的）。</p>\n<hr>\n<h4 id=\"09-挤出\"><a href=\"#09-挤出\" class=\"headerlink\" title=\"09. 挤出\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D9\" target=\"_blank\" rel=\"noopener\">09. 挤出</a></h4><p>编辑模式：<br>“E键”：选中点线面都可以挤出，但一般主要对面操作。</p>\n<p>挤出时右键取消实际上还是挤出了，只不过重叠在原有位置。</p>\n<p>环切左键确定后可以按“S键”然后移动坐标轴进行缩放环切线。缩放时可以直接输入缩放倍数，在左下角有显示缩放当前倍数。</p>\n<hr>\n<h4 id=\"10-倒角\"><a href=\"#10-倒角\" class=\"headerlink\" title=\"10. 倒角\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D10\" target=\"_blank\" rel=\"noopener\">10. 倒角</a></h4><p>编辑模式：<br>选中边，按“CTRL+B”进行倒角，此时可以滚动滚轮增加倒角边。</p>\n<p>环切确认后也可以按“CTRL+B”和滚轮增加环切边。</p>\n<hr>\n<h4 id=\"11-合并与分离\"><a href=\"#11-合并与分离\" class=\"headerlink\" title=\"11. 合并与分离\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D11\" target=\"_blank\" rel=\"noopener\">11. 合并与分离</a></h4><p><strong>物体的合并与分离：</strong><br>物体模式：<br>“CTRL+J”：“join”。合并选中的多个物体。合并后的轴心在最后选中物体的轴心。<br>编辑模式：<br>“P键”：选中物体后按P键弹跳出菜单可以进行多种分离模式。没选中任何物体时也可以按P键进行按松散块分离。</p>\n<p><strong>顶点的合并与分离：</strong><br>“V键”：选中顶点后进行按键拖动分离。此模式比较坑的一点是就算按鼠标右键取消分离，其实也还是分离了，如果不想分离只能按CTRL+Z撤消操作。<br>“ALT+M键”：选中两个点按键后弹出菜单合并。</p>\n<hr>\n<h4 id=\"12-创建边与面\"><a href=\"#12-创建边与面\" class=\"headerlink\" title=\"12. 创建边与面\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D12\" target=\"_blank\" rel=\"noopener\">12. 创建边与面</a></h4><p>编辑模式：<br>“F键”：(fill)选中点或者边，然后按F键进行填充边或者面。</p>\n<hr>\n<h4 id=\"13-衰减编辑\"><a href=\"#13-衰减编辑\" class=\"headerlink\" title=\"13. 衰减编辑\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D13\" target=\"_blank\" rel=\"noopener\">13. 衰减编辑</a></h4><p>编辑模式：<br>“O键”：启用衰减编辑。底下菜单栏也可以选择，还可以切换衰减模式。<br>衰减编辑模式：<br>“G键”：此时滚动鼠标滚轮控制衰减范围。<br>“ALT+O键”：“衰减编辑模式-相连项”：开启后不会影响不相连的其他物体。</p>\n<hr>\n<h4 id=\"14-轴心点\"><a href=\"#14-轴心点\" class=\"headerlink\" title=\"14. 轴心点\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D14\" target=\"_blank\" rel=\"noopener\">14. 轴心点</a></h4><p>选中多个物体可以通过下面的菜单栏切换轴心点，默认轴心点为质心点。缩放旋转都是根据轴心点进行的。</p>\n<p>合并多个物体后，轴心点会被设置到最后一个选中的物体的轴心点上。分离物体后各个物体的轴心点不会恢复的原有的位置。</p>\n<p>“CTRL+ALT+SHIFT+C键”：弹出设置原点菜单，可以修改原点。原点即轴心点。</p>\n<p>编辑模式：<br>“SHIFT+S键”：（snap）吸附菜单。可以修改游标位置等。</p>\n<hr>\n<h4 id=\"15-内插面-amp-应用缩放比例\"><a href=\"#15-内插面-amp-应用缩放比例\" class=\"headerlink\" title=\"15. 内插面&amp;应用缩放比例\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D15\" target=\"_blank\" rel=\"noopener\">15. 内插面&amp;应用缩放比例</a></h4><p>实体显示状态：属性栏-&gt;着色方式-&gt;Mapcap修改编辑时的着色方式，不影响渲染。</p>\n<p>编辑模式：<br>内插面方式一：选择面按E挤出时右键取消实际上还是挤出了，只不过重叠在原有位置。然后按S修改面大小，然后再按E挤出。</p>\n<p>内插面方式二：<br>“I键”：（insert）插入面。然后再按E挤出。</p>\n<p>物体模式：<br>“CTRL+A键”：（apply）应用菜单。缩放物体后比例变化，可以应用比例把比例值变为1，其实意思就是应用保存修改。</p>\n<hr>\n<h4 id=\"16-表面细分\"><a href=\"#16-表面细分\" class=\"headerlink\" title=\"16. 表面细分\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D16\" target=\"_blank\" rel=\"noopener\">16. 表面细分</a></h4><p>选中物体添加修改器，添加表面细分修改器。<br>表面细分可以配合工具栏-&gt;工具中的着色方式（光滑、平直）使用。</p>\n<p>快捷键：选中物体按“CTRL+数字键”直接添加表面细分器，数字代表了细分的次数。</p>\n<hr>\n<h4 id=\"17-镜射\"><a href=\"#17-镜射\" class=\"headerlink\" title=\"17. 镜射\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D17\" target=\"_blank\" rel=\"noopener\">17. 镜射</a></h4><p>编辑模式：<br>切分后线框模式下按B框选可以选择背后的边。按X删除顶点。添加镜射修改器，根据XYZ轴选择镜射。</p>\n<p>勾选镜射修改器的范围限制可以防止交界处分离或者越界。</p>\n<hr>\n<h4 id=\"18-布尔\"><a href=\"#18-布尔\" class=\"headerlink\" title=\"18. 布尔\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D18\" target=\"_blank\" rel=\"noopener\">18. 布尔</a></h4><p>添加布尔修改器，指定参照物体。</p>\n<p>布尔插件：Bool Tool。添加插件后，在工具栏-&gt;工具下有Bool Tool，选中两个物体可以进行布尔操作。</p>\n<p>有时按中键移动视图很慢，按小键盘小数点键恢复一下视图即可。</p>\n<hr>\n<h4 id=\"19-修改器顺序\"><a href=\"#19-修改器顺序\" class=\"headerlink\" title=\"19. 修改器顺序\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D19\" target=\"_blank\" rel=\"noopener\">19. 修改器顺序</a></h4><p>修改器不同的顺序产生不同的效果。</p>\n<p>实体修改器增加厚度，比如平面、衣服等厚度。</p>\n<hr>\n<h4 id=\"20-相机设置及渲染\"><a href=\"#20-相机设置及渲染\" class=\"headerlink\" title=\"20. 相机设置及渲染\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D20\" target=\"_blank\" rel=\"noopener\">20. 相机设置及渲染</a></h4><p>“SHIFT+Z键”：切换渲染模式（预览）。</p>\n<p>开启快捷切换插件：Pie Menu 3D -&gt;View Numpad Pie: Q。 可以快速切换视图。<br>前视图移动物体时按住CTRL可以按网格移动。<br>“F12键”：开始渲染。<br>“M键”：移动选中物体到不同图层。<br>“小键盘0键”：显示相机视图。</p>\n<p>选中相机按N打开属性面板-&gt;锁定到视图，可以锁定相机视图，此时移动视图然后渲染所见即所得。</p>\n<p>渲染窗口：切换底部“槽”可以保存每次的渲染结果。可以使用大键盘数字键来切换槽。</p>\n<p>编辑窗口的大键盘数字键可以切换图层（自己试出来的）。</p>\n<p>最右属性栏-&gt;世界环境-&gt;背景-&gt;颜色旁的小点弹出菜单可以选择天空纹理。</p>\n<hr>\n<h4 id=\"21-灯光设置\"><a href=\"#21-灯光设置\" class=\"headerlink\" title=\"21. 灯光设置\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D21\" target=\"_blank\" rel=\"noopener\">21. 灯光设置</a></h4><p>灯光没啥好说的，自己试验修改各种参数看效果。日光只有旋转才会有不同效果，移动位置不影响。</p>\n<p>使用给平面增加材质来模拟光源：创建平面，增加纹理，修改漫射BSDF为自发光。<br>选中这个发光的面，设置物体属性-&gt;Cycles 设定-&gt;Ray Visibilty-&gt;关闭摄像机可以隐藏这个面，但发出的光还是有效。<br>可以对这个发光的面进行各种编辑（缩放旋转修改形状等）来产生不同的效果。</p>\n<p>基本打光技巧，3个光源（3点光）:<br>主光源放在摄像机位置附近、辅助光源小一点放在摄像机侧面使主光源阴影更少一点，再增加一个光源放在摄像机所对物体后面。两个辅助光源都去掉投射阴影（只有灯光才有投射阴影，如果使用材质模拟光则没有。）。</p>\n<p>“ALT+S键”：还原缩放。<br>“ALT+R键”：还原旋转。</p>\n<hr>\n<h4 id=\"22-提高Cycles渲染速度\"><a href=\"#22-提高Cycles渲染速度\" class=\"headerlink\" title=\"22. 提高Cycles渲染速度\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D22\" target=\"_blank\" rel=\"noopener\">22. 提高Cycles渲染速度</a></h4><p>最右属性栏-&gt;渲染-&gt;采样：影响渲染效果和速度。<br>最右属性栏-&gt;渲染层-&gt;Denoising：降噪功能。此功能在我的烂显卡上不支持GPU渲染，只能CPU渲染。<br>最右属性栏-&gt;渲染-&gt;分块大小：影响渲染速度。插件：Auto Tile Size，自动根据机器配置设置分块大小。</p>\n<p>最右属性栏-&gt;渲染-&gt;光程：适当调节减小值可以提高速度，我不想调就用默认的。</p>\n<hr>\n<h4 id=\"23-材质\"><a href=\"#23-材质\" class=\"headerlink\" title=\"23. 材质\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D23\" target=\"_blank\" rel=\"noopener\">23. 材质</a></h4><p>各种材质没啥好说的，自己试效果就可以了。</p>\n<p>节点编辑器：各种快捷键跟3D视图编辑器差不多。可以新增着色器进行连线等操作。</p>\n<hr>\n<h4 id=\"24-Principled着色器\"><a href=\"#24-Principled着色器\" class=\"headerlink\" title=\"24. Principled着色器\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D24\" target=\"_blank\" rel=\"noopener\">24. Principled着色器</a></h4><p>世界环境-&gt;使用节点-&gt;背景-&gt;颜色（点按钮）-&gt;环境纹理-&gt;添加下载好的HDR文件。</p>\n<p>Principled着色器可以调出金属、塑料、透明等效果。</p>\n<hr>\n<h4 id=\"25-blender渲染\"><a href=\"#25-blender渲染\" class=\"headerlink\" title=\"25. blender渲染\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D25\" target=\"_blank\" rel=\"noopener\">25. blender渲染</a></h4><p>主要是材质和灯光跟Cycle的不同。<br>优势是速度快，但已经不再更新。</p>\n<hr>\n<h4 id=\"26-blender卡通渲染\"><a href=\"#26-blender卡通渲染\" class=\"headerlink\" title=\"26. blender卡通渲染\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D26\" target=\"_blank\" rel=\"noopener\">26. blender卡通渲染</a></h4><p>主要讲了Blender渲染模式下的卡通效果，具体的操作还是得参考视频。<br>freestyle描边。</p>\n<hr>\n<h4 id=\"27-principled着色器补充\"><a href=\"#27-principled着色器补充\" class=\"headerlink\" title=\"27. principled着色器补充\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D27\" target=\"_blank\" rel=\"noopener\">27. principled着色器补充</a></h4><p>表面细分：光穿透物体的程度。<br>Subsurface Radius：表面细分范围（RGB三色）。</p>\n<p>各向异性过滤：配合Metalic(金属）实现类似拉丝金属。<br>Anisotropic Rotation：各向异性过滤的旋转角度。</p>\n<blockquote>\n<p>我自己网上找的，更详细的Principled 知识参考下面链接：<br><a href=\"https://links.jianshu.com/go?to=http%3A%2F%2Fwww.blendercn.org%2F1771.html%2Fcomment-page-1%23comment-634\" target=\"_blank\" rel=\"noopener\">2.79新材质节点 Principled 图解</a></p>\n</blockquote>\n<hr>\n<h4 id=\"28-表皮修改器制做小青蛙\"><a href=\"#28-表皮修改器制做小青蛙\" class=\"headerlink\" title=\"28. 表皮修改器制做小青蛙\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D28\" target=\"_blank\" rel=\"noopener\">28. 表皮修改器制做小青蛙</a></h4><p>创建平面，选中四点，ALT+M合并到中心，添加镜射修改器，挤出顶点，添加表皮修改器，添加表面细分修改器。</p>\n<p>表皮修改器标记根结点。<br>对顶点不能直接使用S键缩放，缩放顶点周边使用CTRL+A。</p>\n<p>做出大概形状后应用表皮修改器，再进一步进行细化。<br>需要先应用镜射修改器再应用表皮修改器。<br>表皮修改器可以直接创建简单的骨架。</p>\n<hr>\n<h4 id=\"29-UV展开与纹理\"><a href=\"#29-UV展开与纹理\" class=\"headerlink\" title=\"29. UV展开与纹理\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D29\" target=\"_blank\" rel=\"noopener\">29. UV展开与纹理</a></h4><p>“U键”：UV映射菜单。<br>“CTRL+E键”：(edge)选中边以后，按快捷键弹出边菜单，选择标记缝合边。<br>标记缝合边以后再按U-&gt;展开UV，然后在底部图像菜单新建图像。<br>底部UV菜单导出UV布局图。<br>在外部修改UV图像以后，使用新建材质-&gt;颜色-&gt;图像纹理-&gt;载入图像然后即可在材质视图看到效果。</p>\n<p>进入底部菜单的“纹理绘制”模式可以直接进行绘制。</p>\n<hr>\n<h4 id=\"30-相机跟踪\"><a href=\"#30-相机跟踪\" class=\"headerlink\" title=\"30. 相机跟踪\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D30\" target=\"_blank\" rel=\"noopener\">30. 相机跟踪</a></h4><p>创建空物体。<br>选中摄像机添加标准跟随约束，设置目标为空物体。修改约束中的-Z和向上为Y。<br>添加曲线-&gt;圆环，放大后CTRL+A应用缩放。<br>选中摄像机添加跟随路径约束，设置目标为圆环。<br>移动跟随路径约束到标准跟随约束上面。<br>点击跟随路径约束的动画路径。<br>播放即可实现动画。<br>可以对圆环进行各种编辑。</p>\n<hr>\n<h4 id=\"31-父级\"><a href=\"#31-父级\" class=\"headerlink\" title=\"31. 父级\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D31\" target=\"_blank\" rel=\"noopener\">31. 父级</a></h4><p>物体模式：<br>“CTRL+P键”：设定父级。<br>“ATL+P键”：清空父级。</p>\n<hr>\n<h4 id=\"32-1-骨骼之骨骼建立\"><a href=\"#32-1-骨骼之骨骼建立\" class=\"headerlink\" title=\"32.1 骨骼之骨骼建立\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D32\" target=\"_blank\" rel=\"noopener\">32.1 骨骼之骨骼建立</a></h4><p>这节课里的lowpoly死侍模型挺好看，可以学着做一个。</p>\n<p>骨架的镜像：<br>选中骨架-&gt;编辑模式-&gt;工具栏-&gt;选项-&gt;X轴镜像<br>然后按“SHIFT+E键”挤出骨骼即可左右自动对称挤出。<br>对于手臂和腿的挤出使用“ATL+P键”：断开骨骼连接。这样还保持着父级。</p>\n<p>头和臂从身体上段挤出，腿从身体下段挤出。</p>\n<hr>\n<h4 id=\"32-2-骨骼之权重绘制\"><a href=\"#32-2-骨骼之权重绘制\" class=\"headerlink\" title=\"32.2 骨骼之权重绘制\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D33\" target=\"_blank\" rel=\"noopener\">32.2 骨骼之权重绘制</a></h4><p>把骨架做为物体的父级（“CTRL+P键”），附带自动权重。<br>“CTRL+TAB键”：骨架姿态模式或者物体权重绘制模式。</p>\n<p>权重绘制只对顶点绘制，一般使用工具栏-&gt;工具里的F Mix笔刷，权重0表示不受骨骼影响，1表示完全受骨骼影响，其他中间值为部分受骨骼影响。按“F键”可以对笔刷大小缩放。</p>\n<p>使用选中物体模块在最右工具栏中数据页指定骨骼的方式可以直接设置权重值。</p>\n<hr>\n<h4 id=\"32-3-骨骼之IK骨\"><a href=\"#32-3-骨骼之IK骨\" class=\"headerlink\" title=\"32.3 骨骼之IK骨\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D34\" target=\"_blank\" rel=\"noopener\">32.3 骨骼之IK骨</a></h4><p>“SHIFT+I键”：添加IK骨。<br>默认IK骨的链长为0会影响所有骨骼，要修改为想要的链长。<br>关节处也要增加IK骨。<br>精细的多顶点模型有益于Blender创建自动权重的计算。</p>\n<hr>\n<h4 id=\"33-动画\"><a href=\"#33-动画\" class=\"headerlink\" title=\"33. 动画\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D35\" target=\"_blank\" rel=\"noopener\">33. 动画</a></h4><p>“I键”：添加关键帧。<br>曲线编辑器：“T键”：修改关键帧插值模式。</p>\n<p>N键属性栏可以直接修改关键帧变换数值。</p>\n<p>材质的颜色也可以增加关键帧。</p>\n<hr>\n<h4 id=\"34-作业\"><a href=\"#34-作业\" class=\"headerlink\" title=\"34. 作业\"></a><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2Fav24292767%2F%3Fp%3D36\" target=\"_blank\" rel=\"noopener\">34. 作业</a></h4><p>没啥可说的，开始做作业吧。</p>\n<hr>\n<h3 id=\"三、自己的学习补充\"><a href=\"#三、自己的学习补充\" class=\"headerlink\" title=\"三、自己的学习补充\"></a>三、自己的学习补充</h3><ol>\n<li>摄像机视角控制<br>小键盘快捷键“0”进入摄像机视图，按“SHIFT+F”，此时可以使用WASD和QE来移动视角（不过有一次我突然发现在此模式下居然无法使用WASDQE移动，然后重启软件后又可以了。)</li>\n</ol>\n<hr>\n<h3 id=\"四、贴吧看到的Rigify骨架插件使用技巧\"><a href=\"#四、贴吧看到的Rigify骨架插件使用技巧\" class=\"headerlink\" title=\"四、贴吧看到的Rigify骨架插件使用技巧\"></a>四、贴吧看到的Rigify骨架插件使用技巧</h3><p>还未实践。</p>\n<blockquote>\n<p>1.检查模型是否在世界中心，移动/旋转/缩放 模型，并Ctrl+A应用。<br>2.灯光、摄像机移至其他图层，并将模型贴图设置为Shadeless（个人建议）。<br>3.分离模型部件（如有需要的话）——分离的目的是为了待会儿更好地分类绑定与权重绘制。<br>4.开启Rigify插件，Shift+A添加。<br>5.大致匹配Rigify骨架于模型，并Ctrl+A应用骨架。<br>6.Tab进入骨架编辑模式，注意开启左侧竖栏Options选项里面的X-Axis Mirror，X轴镜像编辑。<br>7.对应骨点位置。<br>8.Check Unity Doc. 删除手指根骨节。<br>9.Normal Trans Orientation 去查看每个骨节的朝向。<br>10.Save As，存盘。<br>11.Generate生成带有控制器的骨架，并将原有基础骨架移至其他层。<br>12.Check Unity Doc. 选择相应骨架层，重置某些骨节的父子关系。<br>13.添加附加骨架（如果有需要的话），并为其设置对应的父子关系——需要配合项目骨节数要求。<br>注意：有些L.R对应的镜像骨节，可以在Normal Trans Orientation（Edit Mode）下查看其轴向,<br>以确保其在Pose Mode下可以被统一旋转。<br>14.绑定（为模型与骨架建立父子关系）——建议：Ctrl+P → Automatic Weight<br>15.选中模型，打开修改器面板下的Armature，勾选【Preserve Volume】如果有需要的话。<br>16.权重绘制（巧用笔刷工具与顶点遮罩工具）<br>17.眼球：Modifier, [Track to]<br>18.表情：Shape Key<br>19.武器（props）：利用[Child of]修改器与角色骨架建立关系。<br>20.Remove WGT-Bones in The Hierarchy. Using This Way will Affect Smoothly into Unity.<br>21.用极限POSE去检查绑定。</p>\n</blockquote>\n<p>暂时到这吧～</p>\n<p><img src=\"/2019/07/10/blender-xue-xi-zhang/end.jpg\" alt></p>\n"},{"title":"大话TCP/IP协议栈 三 IP协议","date":"2020-02-29T05:22:52.000Z","_content":"\n## 网络层中的 IP 协议\n\nIP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层。网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点通信”。\n\n网络的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。\n\n**IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。**\n\n### **IP 地址**\n\n#### **IP 地址概述**\n\n- 在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。\n- 作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。\n- 不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。\n- IP 地址（IPv4 地址）由32位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：\n\n![](/14.jpg)\n\n#### **IP 地址由网络和主机两部分标识组成**\n\n- 如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 IP 地址具有了唯一性。\n\n![ip地址主机标识](/15.jpg)\n\n- 如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。\n\n![IP地址的网络标识](/16.jpg)\n\n#### **IP 地址的分类**\n\n- **IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。**\n- **A 类 IP 地址是首位以 “0” 开头的地址。**从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16,777,214个。\n- **B 类 IP 地址是前两位 “10” 的地址。**从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为65,534个。\n- **C 类 IP 地址是前三位为 “110” 的地址。**从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个。\n- **D 类 IP 地址是前四位为 “1110” 的地址。**从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。\n- 在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。\n\n#### **广播地址**\n\n- 广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。\n- 广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。\n\n#### **IP 多播**\n\n- 多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。\n- 相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：\n\n![](/17.jpg)\n\n- IP 多播\n- 多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。\n- 此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。\n\n#### **子网掩码**\n\n- 现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。\n- 子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。\n- 对于子网掩码，目前有两种表示方式。将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：\n\n![](/19.jpg)\n\n- 第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下：\n\n![](/20.jpg)\n\n#### 路由\n\n- 发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。\n- 该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。\n- IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。\n\n#### **IP 地址与路由控制**\n\n- IP 地址的网络地址部分用于进行路由控制。\n- 路由控制表中记录着网络地址与下一步应该发送至路由器的地址。\n- 在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。\n\n![路由控制表与 IP 包发送](/21.jpg)\n\n **IP 分包与组包**\n\n- 每种数据链路的路径传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。\n- 任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。\n- 经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。\n\n#### **路径 MTU 发现**\n\n- 分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。\n- 为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是路径MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。\n- 进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。\n\n#### **IPv6**\n\n- IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。\n\n#### **IPv6 的特点**\n\n- IP 得知的扩大与路由控制表的聚合。\n- 性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。\n- 支持即插即用功能。即使没有DHCP服务器也可以实现自动分配 IP 地址。\n- 采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。\n- 多播、Mobile IP 成为扩展功能。\n\n#### **IPv6 中 IP 地址的标记方法**\n\n- 一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。\n- 而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。\n\n#### **IPv6 地址的结构**\n\n- IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。\n- 在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。\n\n![全局单播地址](/22.jpg)\n\n#### **全局单播地址**\n\n- 全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。\n- 格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。\n\n![链路本地单播地址](/23.jpg)\n\n#### **唯一本地地址**\n\n- 唯一本地地址是不进行互联网通信时所用的地址。\n- 唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。\n- L 通常被置为 1\n- 全局 ID 的值随机决定\n- 子网 ID 是指该域子网地址\n- 接口 ID 即为接口的 ID\n\n![唯一本地地址](/24.jpg)\n\n **IPv6 分段处理**\n\n- IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。\n- IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU 发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。\n\n#### **IP 协议相关技术**\n\n- IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。\n\n#### **DNS**\n\n- 我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。\n- 这种 DNS 不仅适用于 IPv4，还适用于 IPv6。\n\n#### **ARP**\n\n- 只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。\n- ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。\n- RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。\n\n#### **ICMP**\n\n- ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。\n- IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。\n\n#### **DHCP**\n\n- 如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。\n- 于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。\n- DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。\n\n#### **NAT**\n\n- NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。\n- 除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。\n- NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。\n\n#### **IP 隧道**\n\n![夹着 IPv4 网络的两个 IPv6 网络](/25.jpg)\n\n- 如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。\n- IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。\n- 一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中“ IP 首部的后面还是 IP 首部”或者“ IP 首部的后面是 IPv6 的首部”等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做“ IP 隧道”。","source":"_posts/大话TCP-IP协议-三-IP协议.md","raw":"---\ntitle: 大话TCP/IP协议栈 三 IP协议\ndate: 2020-02-29 13:22:52\ntags: [tcp/ip协议,网络协议]\ncategory: tcp/ip协议\n---\n\n## 网络层中的 IP 协议\n\nIP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层。网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点通信”。\n\n网络的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。\n\n**IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。**\n\n### **IP 地址**\n\n#### **IP 地址概述**\n\n- 在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。\n- 作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。\n- 不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。\n- IP 地址（IPv4 地址）由32位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：\n\n![](/14.jpg)\n\n#### **IP 地址由网络和主机两部分标识组成**\n\n- 如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 IP 地址具有了唯一性。\n\n![ip地址主机标识](/15.jpg)\n\n- 如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。\n\n![IP地址的网络标识](/16.jpg)\n\n#### **IP 地址的分类**\n\n- **IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。**\n- **A 类 IP 地址是首位以 “0” 开头的地址。**从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16,777,214个。\n- **B 类 IP 地址是前两位 “10” 的地址。**从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为65,534个。\n- **C 类 IP 地址是前三位为 “110” 的地址。**从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个。\n- **D 类 IP 地址是前四位为 “1110” 的地址。**从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。\n- 在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。\n\n#### **广播地址**\n\n- 广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。\n- 广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。\n\n#### **IP 多播**\n\n- 多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。\n- 相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：\n\n![](/17.jpg)\n\n- IP 多播\n- 多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。\n- 此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。\n\n#### **子网掩码**\n\n- 现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。\n- 子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。\n- 对于子网掩码，目前有两种表示方式。将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：\n\n![](/19.jpg)\n\n- 第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下：\n\n![](/20.jpg)\n\n#### 路由\n\n- 发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。\n- 该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。\n- IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。\n\n#### **IP 地址与路由控制**\n\n- IP 地址的网络地址部分用于进行路由控制。\n- 路由控制表中记录着网络地址与下一步应该发送至路由器的地址。\n- 在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。\n\n![路由控制表与 IP 包发送](/21.jpg)\n\n **IP 分包与组包**\n\n- 每种数据链路的路径传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。\n- 任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。\n- 经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。\n\n#### **路径 MTU 发现**\n\n- 分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。\n- 为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是路径MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。\n- 进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。\n\n#### **IPv6**\n\n- IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。\n\n#### **IPv6 的特点**\n\n- IP 得知的扩大与路由控制表的聚合。\n- 性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。\n- 支持即插即用功能。即使没有DHCP服务器也可以实现自动分配 IP 地址。\n- 采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。\n- 多播、Mobile IP 成为扩展功能。\n\n#### **IPv6 中 IP 地址的标记方法**\n\n- 一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。\n- 而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。\n\n#### **IPv6 地址的结构**\n\n- IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。\n- 在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。\n\n![全局单播地址](/22.jpg)\n\n#### **全局单播地址**\n\n- 全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。\n- 格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。\n\n![链路本地单播地址](/23.jpg)\n\n#### **唯一本地地址**\n\n- 唯一本地地址是不进行互联网通信时所用的地址。\n- 唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。\n- L 通常被置为 1\n- 全局 ID 的值随机决定\n- 子网 ID 是指该域子网地址\n- 接口 ID 即为接口的 ID\n\n![唯一本地地址](/24.jpg)\n\n **IPv6 分段处理**\n\n- IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。\n- IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU 发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。\n\n#### **IP 协议相关技术**\n\n- IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。\n\n#### **DNS**\n\n- 我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。\n- 这种 DNS 不仅适用于 IPv4，还适用于 IPv6。\n\n#### **ARP**\n\n- 只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。\n- ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。\n- RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。\n\n#### **ICMP**\n\n- ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。\n- IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。\n\n#### **DHCP**\n\n- 如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。\n- 于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。\n- DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。\n\n#### **NAT**\n\n- NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。\n- 除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。\n- NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。\n\n#### **IP 隧道**\n\n![夹着 IPv4 网络的两个 IPv6 网络](/25.jpg)\n\n- 如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。\n- IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。\n- 一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中“ IP 首部的后面还是 IP 首部”或者“ IP 首部的后面是 IPv6 的首部”等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做“ IP 隧道”。","slug":"大话TCP-IP协议-三-IP协议","published":1,"updated":"2020-02-29T05:25:14.889Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rjl0017zd5b34ujhbdi","content":"<h2 id=\"网络层中的-IP-协议\"><a href=\"#网络层中的-IP-协议\" class=\"headerlink\" title=\"网络层中的 IP 协议\"></a>网络层中的 IP 协议</h2><p>IP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层。网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点通信”。</p>\n<p>网络的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p>\n<p><strong>IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。</strong></p>\n<h3 id=\"IP-地址\"><a href=\"#IP-地址\" class=\"headerlink\" title=\"IP 地址\"></a><strong>IP 地址</strong></h3><h4 id=\"IP-地址概述\"><a href=\"#IP-地址概述\" class=\"headerlink\" title=\"IP 地址概述\"></a><strong>IP 地址概述</strong></h4><ul>\n<li>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。</li>\n<li>作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。</li>\n<li>不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。</li>\n<li>IP 地址（IPv4 地址）由32位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/14.jpg\" alt></p>\n<h4 id=\"IP-地址由网络和主机两部分标识组成\"><a href=\"#IP-地址由网络和主机两部分标识组成\" class=\"headerlink\" title=\"IP 地址由网络和主机两部分标识组成\"></a><strong>IP 地址由网络和主机两部分标识组成</strong></h4><ul>\n<li>如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 IP 地址具有了唯一性。</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/15.jpg\" alt=\"ip地址主机标识\"></p>\n<ul>\n<li>如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/16.jpg\" alt=\"IP地址的网络标识\"></p>\n<h4 id=\"IP-地址的分类\"><a href=\"#IP-地址的分类\" class=\"headerlink\" title=\"IP 地址的分类\"></a><strong>IP 地址的分类</strong></h4><ul>\n<li><strong>IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。</strong></li>\n<li><strong>A 类 IP 地址是首位以 “0” 开头的地址。</strong>从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16,777,214个。</li>\n<li><strong>B 类 IP 地址是前两位 “10” 的地址。</strong>从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为65,534个。</li>\n<li><strong>C 类 IP 地址是前三位为 “110” 的地址。</strong>从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个。</li>\n<li><strong>D 类 IP 地址是前四位为 “1110” 的地址。</strong>从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。</li>\n<li>在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。</li>\n</ul>\n<h4 id=\"广播地址\"><a href=\"#广播地址\" class=\"headerlink\" title=\"广播地址\"></a><strong>广播地址</strong></h4><ul>\n<li>广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。</li>\n<li>广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。</li>\n</ul>\n<h4 id=\"IP-多播\"><a href=\"#IP-多播\" class=\"headerlink\" title=\"IP 多播\"></a><strong>IP 多播</strong></h4><ul>\n<li>多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。</li>\n<li>相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/17.jpg\" alt></p>\n<ul>\n<li>IP 多播</li>\n<li>多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。</li>\n<li>此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。</li>\n</ul>\n<h4 id=\"子网掩码\"><a href=\"#子网掩码\" class=\"headerlink\" title=\"子网掩码\"></a><strong>子网掩码</strong></h4><ul>\n<li>现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。</li>\n<li>子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。</li>\n<li>对于子网掩码，目前有两种表示方式。将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/19.jpg\" alt></p>\n<ul>\n<li>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下：</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/20.jpg\" alt></p>\n<h4 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h4><ul>\n<li>发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。</li>\n<li>该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。</li>\n<li>IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。</li>\n</ul>\n<h4 id=\"IP-地址与路由控制\"><a href=\"#IP-地址与路由控制\" class=\"headerlink\" title=\"IP 地址与路由控制\"></a><strong>IP 地址与路由控制</strong></h4><ul>\n<li>IP 地址的网络地址部分用于进行路由控制。</li>\n<li>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。</li>\n<li>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/21.jpg\" alt=\"路由控制表与 IP 包发送\"></p>\n<p> <strong>IP 分包与组包</strong></p>\n<ul>\n<li>每种数据链路的路径传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。</li>\n<li>任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。</li>\n<li>经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</li>\n</ul>\n<h4 id=\"路径-MTU-发现\"><a href=\"#路径-MTU-发现\" class=\"headerlink\" title=\"路径 MTU 发现\"></a><strong>路径 MTU 发现</strong></h4><ul>\n<li>分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。</li>\n<li>为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是路径MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。</li>\n<li>进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。</li>\n</ul>\n<h4 id=\"IPv6\"><a href=\"#IPv6\" class=\"headerlink\" title=\"IPv6\"></a><strong>IPv6</strong></h4><ul>\n<li>IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。</li>\n</ul>\n<h4 id=\"IPv6-的特点\"><a href=\"#IPv6-的特点\" class=\"headerlink\" title=\"IPv6 的特点\"></a><strong>IPv6 的特点</strong></h4><ul>\n<li>IP 得知的扩大与路由控制表的聚合。</li>\n<li>性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。</li>\n<li>支持即插即用功能。即使没有DHCP服务器也可以实现自动分配 IP 地址。</li>\n<li>采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。</li>\n<li>多播、Mobile IP 成为扩展功能。</li>\n</ul>\n<h4 id=\"IPv6-中-IP-地址的标记方法\"><a href=\"#IPv6-中-IP-地址的标记方法\" class=\"headerlink\" title=\"IPv6 中 IP 地址的标记方法\"></a><strong>IPv6 中 IP 地址的标记方法</strong></h4><ul>\n<li>一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。</li>\n<li>而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</li>\n</ul>\n<h4 id=\"IPv6-地址的结构\"><a href=\"#IPv6-地址的结构\" class=\"headerlink\" title=\"IPv6 地址的结构\"></a><strong>IPv6 地址的结构</strong></h4><ul>\n<li>IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。</li>\n<li>在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/22.jpg\" alt=\"全局单播地址\"></p>\n<h4 id=\"全局单播地址\"><a href=\"#全局单播地址\" class=\"headerlink\" title=\"全局单播地址\"></a><strong>全局单播地址</strong></h4><ul>\n<li>全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。</li>\n<li>格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/23.jpg\" alt=\"链路本地单播地址\"></p>\n<h4 id=\"唯一本地地址\"><a href=\"#唯一本地地址\" class=\"headerlink\" title=\"唯一本地地址\"></a><strong>唯一本地地址</strong></h4><ul>\n<li>唯一本地地址是不进行互联网通信时所用的地址。</li>\n<li>唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。</li>\n<li>L 通常被置为 1</li>\n<li>全局 ID 的值随机决定</li>\n<li>子网 ID 是指该域子网地址</li>\n<li>接口 ID 即为接口的 ID</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/24.jpg\" alt=\"唯一本地地址\"></p>\n<p> <strong>IPv6 分段处理</strong></p>\n<ul>\n<li>IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。</li>\n<li>IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU 发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。</li>\n</ul>\n<h4 id=\"IP-协议相关技术\"><a href=\"#IP-协议相关技术\" class=\"headerlink\" title=\"IP 协议相关技术\"></a><strong>IP 协议相关技术</strong></h4><ul>\n<li>IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。</li>\n</ul>\n<h4 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a><strong>DNS</strong></h4><ul>\n<li>我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。</li>\n<li>这种 DNS 不仅适用于 IPv4，还适用于 IPv6。</li>\n</ul>\n<h4 id=\"ARP\"><a href=\"#ARP\" class=\"headerlink\" title=\"ARP\"></a><strong>ARP</strong></h4><ul>\n<li>只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。</li>\n<li>ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。</li>\n<li>RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。</li>\n</ul>\n<h4 id=\"ICMP\"><a href=\"#ICMP\" class=\"headerlink\" title=\"ICMP\"></a><strong>ICMP</strong></h4><ul>\n<li>ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。</li>\n<li>IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。</li>\n</ul>\n<h4 id=\"DHCP\"><a href=\"#DHCP\" class=\"headerlink\" title=\"DHCP\"></a><strong>DHCP</strong></h4><ul>\n<li>如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。</li>\n<li>于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。</li>\n<li>DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。</li>\n</ul>\n<h4 id=\"NAT\"><a href=\"#NAT\" class=\"headerlink\" title=\"NAT\"></a><strong>NAT</strong></h4><ul>\n<li>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。</li>\n<li>除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。</li>\n<li>NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。</li>\n</ul>\n<h4 id=\"IP-隧道\"><a href=\"#IP-隧道\" class=\"headerlink\" title=\"IP 隧道\"></a><strong>IP 隧道</strong></h4><p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/25.jpg\" alt=\"夹着 IPv4 网络的两个 IPv6 网络\"></p>\n<ul>\n<li>如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。</li>\n<li>IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。</li>\n<li>一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中“ IP 首部的后面还是 IP 首部”或者“ IP 首部的后面是 IPv6 的首部”等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做“ IP 隧道”。</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<h2 id=\"网络层中的-IP-协议\"><a href=\"#网络层中的-IP-协议\" class=\"headerlink\" title=\"网络层中的 IP 协议\"></a>网络层中的 IP 协议</h2><p>IP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层。网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点通信”。</p>\n<p>网络的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p>\n<p><strong>IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。</strong></p>\n<h3 id=\"IP-地址\"><a href=\"#IP-地址\" class=\"headerlink\" title=\"IP 地址\"></a><strong>IP 地址</strong></h3><h4 id=\"IP-地址概述\"><a href=\"#IP-地址概述\" class=\"headerlink\" title=\"IP 地址概述\"></a><strong>IP 地址概述</strong></h4><ul>\n<li>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。</li>\n<li>作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。</li>\n<li>不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。</li>\n<li>IP 地址（IPv4 地址）由32位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/14.jpg\" alt></p>\n<h4 id=\"IP-地址由网络和主机两部分标识组成\"><a href=\"#IP-地址由网络和主机两部分标识组成\" class=\"headerlink\" title=\"IP 地址由网络和主机两部分标识组成\"></a><strong>IP 地址由网络和主机两部分标识组成</strong></h4><ul>\n<li>如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 IP 地址具有了唯一性。</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/15.jpg\" alt=\"ip地址主机标识\"></p>\n<ul>\n<li>如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/16.jpg\" alt=\"IP地址的网络标识\"></p>\n<h4 id=\"IP-地址的分类\"><a href=\"#IP-地址的分类\" class=\"headerlink\" title=\"IP 地址的分类\"></a><strong>IP 地址的分类</strong></h4><ul>\n<li><strong>IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。</strong></li>\n<li><strong>A 类 IP 地址是首位以 “0” 开头的地址。</strong>从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16,777,214个。</li>\n<li><strong>B 类 IP 地址是前两位 “10” 的地址。</strong>从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为65,534个。</li>\n<li><strong>C 类 IP 地址是前三位为 “110” 的地址。</strong>从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个。</li>\n<li><strong>D 类 IP 地址是前四位为 “1110” 的地址。</strong>从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。</li>\n<li>在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。</li>\n</ul>\n<h4 id=\"广播地址\"><a href=\"#广播地址\" class=\"headerlink\" title=\"广播地址\"></a><strong>广播地址</strong></h4><ul>\n<li>广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。</li>\n<li>广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。</li>\n</ul>\n<h4 id=\"IP-多播\"><a href=\"#IP-多播\" class=\"headerlink\" title=\"IP 多播\"></a><strong>IP 多播</strong></h4><ul>\n<li>多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。</li>\n<li>相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/17.jpg\" alt></p>\n<ul>\n<li>IP 多播</li>\n<li>多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。</li>\n<li>此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。</li>\n</ul>\n<h4 id=\"子网掩码\"><a href=\"#子网掩码\" class=\"headerlink\" title=\"子网掩码\"></a><strong>子网掩码</strong></h4><ul>\n<li>现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。</li>\n<li>子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。</li>\n<li>对于子网掩码，目前有两种表示方式。将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/19.jpg\" alt></p>\n<ul>\n<li>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下：</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/20.jpg\" alt></p>\n<h4 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h4><ul>\n<li>发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。</li>\n<li>该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。</li>\n<li>IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。</li>\n</ul>\n<h4 id=\"IP-地址与路由控制\"><a href=\"#IP-地址与路由控制\" class=\"headerlink\" title=\"IP 地址与路由控制\"></a><strong>IP 地址与路由控制</strong></h4><ul>\n<li>IP 地址的网络地址部分用于进行路由控制。</li>\n<li>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。</li>\n<li>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/21.jpg\" alt=\"路由控制表与 IP 包发送\"></p>\n<p> <strong>IP 分包与组包</strong></p>\n<ul>\n<li>每种数据链路的路径传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。</li>\n<li>任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。</li>\n<li>经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</li>\n</ul>\n<h4 id=\"路径-MTU-发现\"><a href=\"#路径-MTU-发现\" class=\"headerlink\" title=\"路径 MTU 发现\"></a><strong>路径 MTU 发现</strong></h4><ul>\n<li>分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。</li>\n<li>为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是路径MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。</li>\n<li>进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。</li>\n</ul>\n<h4 id=\"IPv6\"><a href=\"#IPv6\" class=\"headerlink\" title=\"IPv6\"></a><strong>IPv6</strong></h4><ul>\n<li>IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。</li>\n</ul>\n<h4 id=\"IPv6-的特点\"><a href=\"#IPv6-的特点\" class=\"headerlink\" title=\"IPv6 的特点\"></a><strong>IPv6 的特点</strong></h4><ul>\n<li>IP 得知的扩大与路由控制表的聚合。</li>\n<li>性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。</li>\n<li>支持即插即用功能。即使没有DHCP服务器也可以实现自动分配 IP 地址。</li>\n<li>采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。</li>\n<li>多播、Mobile IP 成为扩展功能。</li>\n</ul>\n<h4 id=\"IPv6-中-IP-地址的标记方法\"><a href=\"#IPv6-中-IP-地址的标记方法\" class=\"headerlink\" title=\"IPv6 中 IP 地址的标记方法\"></a><strong>IPv6 中 IP 地址的标记方法</strong></h4><ul>\n<li>一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。</li>\n<li>而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</li>\n</ul>\n<h4 id=\"IPv6-地址的结构\"><a href=\"#IPv6-地址的结构\" class=\"headerlink\" title=\"IPv6 地址的结构\"></a><strong>IPv6 地址的结构</strong></h4><ul>\n<li>IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。</li>\n<li>在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/22.jpg\" alt=\"全局单播地址\"></p>\n<h4 id=\"全局单播地址\"><a href=\"#全局单播地址\" class=\"headerlink\" title=\"全局单播地址\"></a><strong>全局单播地址</strong></h4><ul>\n<li>全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。</li>\n<li>格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/23.jpg\" alt=\"链路本地单播地址\"></p>\n<h4 id=\"唯一本地地址\"><a href=\"#唯一本地地址\" class=\"headerlink\" title=\"唯一本地地址\"></a><strong>唯一本地地址</strong></h4><ul>\n<li>唯一本地地址是不进行互联网通信时所用的地址。</li>\n<li>唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。</li>\n<li>L 通常被置为 1</li>\n<li>全局 ID 的值随机决定</li>\n<li>子网 ID 是指该域子网地址</li>\n<li>接口 ID 即为接口的 ID</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/24.jpg\" alt=\"唯一本地地址\"></p>\n<p> <strong>IPv6 分段处理</strong></p>\n<ul>\n<li>IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。</li>\n<li>IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU 发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。</li>\n</ul>\n<h4 id=\"IP-协议相关技术\"><a href=\"#IP-协议相关技术\" class=\"headerlink\" title=\"IP 协议相关技术\"></a><strong>IP 协议相关技术</strong></h4><ul>\n<li>IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。</li>\n</ul>\n<h4 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a><strong>DNS</strong></h4><ul>\n<li>我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。</li>\n<li>这种 DNS 不仅适用于 IPv4，还适用于 IPv6。</li>\n</ul>\n<h4 id=\"ARP\"><a href=\"#ARP\" class=\"headerlink\" title=\"ARP\"></a><strong>ARP</strong></h4><ul>\n<li>只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。</li>\n<li>ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。</li>\n<li>RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。</li>\n</ul>\n<h4 id=\"ICMP\"><a href=\"#ICMP\" class=\"headerlink\" title=\"ICMP\"></a><strong>ICMP</strong></h4><ul>\n<li>ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。</li>\n<li>IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。</li>\n</ul>\n<h4 id=\"DHCP\"><a href=\"#DHCP\" class=\"headerlink\" title=\"DHCP\"></a><strong>DHCP</strong></h4><ul>\n<li>如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。</li>\n<li>于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。</li>\n<li>DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。</li>\n</ul>\n<h4 id=\"NAT\"><a href=\"#NAT\" class=\"headerlink\" title=\"NAT\"></a><strong>NAT</strong></h4><ul>\n<li>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。</li>\n<li>除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。</li>\n<li>NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。</li>\n</ul>\n<h4 id=\"IP-隧道\"><a href=\"#IP-隧道\" class=\"headerlink\" title=\"IP 隧道\"></a><strong>IP 隧道</strong></h4><p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-san-ip-xie-yi/25.jpg\" alt=\"夹着 IPv4 网络的两个 IPv6 网络\"></p>\n<ul>\n<li>如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。</li>\n<li>IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。</li>\n<li>一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中“ IP 首部的后面还是 IP 首部”或者“ IP 首部的后面是 IPv6 的首部”等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做“ IP 隧道”。</li>\n</ul>\n"},{"title":"大话TCP/IP协议栈 二 TCP和UDP协议详解","date":"2020-02-29T05:26:43.000Z","_content":"\n## 传输层中的TCP和UDP\n\nTCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。\n\n- TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。\n- UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。\n- TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。\n\n### **端口号**\n\n数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。\n\n#### **根据端口号识别应用**\n\n一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。\n\n![通过端口号识别应用](/3.jpg)\n\n#### 通过 IP 地址、端口号、协议号进行通信识别\n\n仅凭目标端口号识别某一个通信是远远不够的。\n\n![通过端口号、IP地址、协议号进行通信识别](/4.jpg)\n\n![通过端口号、IP地址、协议号进行通信识别](/5.jpg)\n\n① 和② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。\n\n③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。\n\n此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。\n\n#### 端口号的确定\n\n- 标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0~1023 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024~49151 之间，不过这些端口号可用于任何通信用途。\n- 时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 49152~65535 之间。\n\n#### 端口号与协议\n\n- 端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。\n- 此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。\n\n### UDP\n\n- UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。\n- 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。\n- 此外，传输途中出现丢包，UDP 也不负责重发。\n- 甚至当包的到达顺序出现乱序时也没有纠正的功能。\n- 如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。\n- UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。\n\n### TCP\n\n- TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。\n- 此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。\n- 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。\n\n#### **三次握手（重点）**\n\n- TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。\n- 所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。\n\n下面来看看三次握手的流程图：\n\n![三次握手](/6.jpg)\n\n- 第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。\n- 第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。\n- 第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。\n\n#### **四次挥手（重点）**\n\n- 四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。\n- 由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。\n\n下面来看看四次挥手的流程图：\n\n![四次挥手](/7.jpg)\n\n​\t中断连接端可以是客户端，也可以是服务器端。\n\n- 第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说\"我客户端没有数据要发给你了\"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。\n- 第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。\n- 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。\n- 第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。\n\n**上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况。**\n\n具体流程如下图：\n\n![同时挥手](/8.jpg)\n\n#### 通过序列号与确认应答提高可靠性\n\n- 在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。**反之，则数据丢失的可能性很大**。\n\n- 在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。\n\n- 未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。\n\n- 此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。\n\n- 对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。\n\n- **序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。**\n\n  ![序列号和确认问答](/9.jpg)\n\n#### **重发超时的确定**\n\n- **重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。**如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。\n- TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。\n- 在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。\n- 数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。\n- 此外，**数据也不会被反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。**\n\n#### 以段为单位发送数据\n\n- 在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“**消息长度”（MSS）。最理想的情况是，消息长度正好是 IP 中不会被分片处理的数据长度**。\n- TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。\n- MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。\n\n#### 利用窗口控制提高速度\n\n- TCP 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。\n- 为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：\n\n![窗口控制](/10.jpg)\n\n- 窗口控制\n- 窗口大小就是指无需等待确认应答而可以继续发送数据的数据值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。\n\n####  **滑动窗口控制**\n\n![滑动窗口](/11.jpg)\n\n- 上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。\n- 在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。\n- 收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。\n\n#### 窗口控制中的重发控制\n\n在使用窗口控制中， 出现丢包一般分为两种情况：\n\n① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：\n\n![部分确认应答丢失](/12.jpg)\n\n② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。\n\n![高速重发控制](/13.jpg)","source":"_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解.md","raw":"---\ntitle: 大话TCP/IP协议栈 二 TCP和UDP协议详解\ndate: 2020-02-29 13:26:43\ntags: [tcp/ip协议,网络协议]\ncategory: tcp/ip协议\n---\n\n## 传输层中的TCP和UDP\n\nTCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。\n\n- TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。\n- UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。\n- TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。\n\n### **端口号**\n\n数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。\n\n#### **根据端口号识别应用**\n\n一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。\n\n![通过端口号识别应用](/3.jpg)\n\n#### 通过 IP 地址、端口号、协议号进行通信识别\n\n仅凭目标端口号识别某一个通信是远远不够的。\n\n![通过端口号、IP地址、协议号进行通信识别](/4.jpg)\n\n![通过端口号、IP地址、协议号进行通信识别](/5.jpg)\n\n① 和② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。\n\n③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。\n\n此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。\n\n#### 端口号的确定\n\n- 标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0~1023 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024~49151 之间，不过这些端口号可用于任何通信用途。\n- 时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 49152~65535 之间。\n\n#### 端口号与协议\n\n- 端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。\n- 此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。\n\n### UDP\n\n- UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。\n- 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。\n- 此外，传输途中出现丢包，UDP 也不负责重发。\n- 甚至当包的到达顺序出现乱序时也没有纠正的功能。\n- 如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。\n- UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。\n\n### TCP\n\n- TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。\n- 此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。\n- 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。\n\n#### **三次握手（重点）**\n\n- TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。\n- 所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。\n\n下面来看看三次握手的流程图：\n\n![三次握手](/6.jpg)\n\n- 第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。\n- 第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。\n- 第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。\n\n#### **四次挥手（重点）**\n\n- 四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。\n- 由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。\n\n下面来看看四次挥手的流程图：\n\n![四次挥手](/7.jpg)\n\n​\t中断连接端可以是客户端，也可以是服务器端。\n\n- 第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说\"我客户端没有数据要发给你了\"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。\n- 第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。\n- 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。\n- 第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。\n\n**上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况。**\n\n具体流程如下图：\n\n![同时挥手](/8.jpg)\n\n#### 通过序列号与确认应答提高可靠性\n\n- 在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。**反之，则数据丢失的可能性很大**。\n\n- 在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。\n\n- 未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。\n\n- 此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。\n\n- 对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。\n\n- **序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。**\n\n  ![序列号和确认问答](/9.jpg)\n\n#### **重发超时的确定**\n\n- **重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。**如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。\n- TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。\n- 在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。\n- 数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。\n- 此外，**数据也不会被反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。**\n\n#### 以段为单位发送数据\n\n- 在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“**消息长度”（MSS）。最理想的情况是，消息长度正好是 IP 中不会被分片处理的数据长度**。\n- TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。\n- MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。\n\n#### 利用窗口控制提高速度\n\n- TCP 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。\n- 为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：\n\n![窗口控制](/10.jpg)\n\n- 窗口控制\n- 窗口大小就是指无需等待确认应答而可以继续发送数据的数据值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。\n\n####  **滑动窗口控制**\n\n![滑动窗口](/11.jpg)\n\n- 上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。\n- 在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。\n- 收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。\n\n#### 窗口控制中的重发控制\n\n在使用窗口控制中， 出现丢包一般分为两种情况：\n\n① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：\n\n![部分确认应答丢失](/12.jpg)\n\n② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。\n\n![高速重发控制](/13.jpg)","slug":"大话TCP-IP协议栈-二-TCP和UDP协议详解","published":1,"updated":"2020-02-29T05:28:04.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rjm001bzd5b03hc5j03","content":"<h2 id=\"传输层中的TCP和UDP\"><a href=\"#传输层中的TCP和UDP\" class=\"headerlink\" title=\"传输层中的TCP和UDP\"></a>传输层中的TCP和UDP</h2><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p>\n<ul>\n<li>TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</li>\n<li>UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</li>\n<li>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</li>\n</ul>\n<h3 id=\"端口号\"><a href=\"#端口号\" class=\"headerlink\" title=\"端口号\"></a><strong>端口号</strong></h3><p>数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p>\n<h4 id=\"根据端口号识别应用\"><a href=\"#根据端口号识别应用\" class=\"headerlink\" title=\"根据端口号识别应用\"></a><strong>根据端口号识别应用</strong></h4><p>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/3.jpg\" alt=\"通过端口号识别应用\"></p>\n<h4 id=\"通过-IP-地址、端口号、协议号进行通信识别\"><a href=\"#通过-IP-地址、端口号、协议号进行通信识别\" class=\"headerlink\" title=\"通过 IP 地址、端口号、协议号进行通信识别\"></a>通过 IP 地址、端口号、协议号进行通信识别</h4><p>仅凭目标端口号识别某一个通信是远远不够的。</p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/4.jpg\" alt=\"通过端口号、IP地址、协议号进行通信识别\"></p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/5.jpg\" alt=\"通过端口号、IP地址、协议号进行通信识别\"></p>\n<p>① 和② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。</p>\n<p>③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。</p>\n<p>此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。</p>\n<h4 id=\"端口号的确定\"><a href=\"#端口号的确定\" class=\"headerlink\" title=\"端口号的确定\"></a>端口号的确定</h4><ul>\n<li>标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0<del>1023 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024</del>49151 之间，不过这些端口号可用于任何通信用途。</li>\n<li>时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 49152~65535 之间。</li>\n</ul>\n<h4 id=\"端口号与协议\"><a href=\"#端口号与协议\" class=\"headerlink\" title=\"端口号与协议\"></a>端口号与协议</h4><ul>\n<li>端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。</li>\n<li>此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。</li>\n</ul>\n<h3 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h3><ul>\n<li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。</li>\n<li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</li>\n<li>此外，传输途中出现丢包，UDP 也不负责重发。</li>\n<li>甚至当包的到达顺序出现乱序时也没有纠正的功能。</li>\n<li>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</li>\n<li>UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。</li>\n</ul>\n<h3 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h3><ul>\n<li>TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li>\n<li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li>\n<li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。</li>\n</ul>\n<h4 id=\"三次握手（重点）\"><a href=\"#三次握手（重点）\" class=\"headerlink\" title=\"三次握手（重点）\"></a><strong>三次握手（重点）</strong></h4><ul>\n<li>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。</li>\n<li>所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</li>\n</ul>\n<p>下面来看看三次握手的流程图：</p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/6.jpg\" alt=\"三次握手\"></p>\n<ul>\n<li>第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</li>\n<li>第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</li>\n<li>第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</li>\n</ul>\n<h4 id=\"四次挥手（重点）\"><a href=\"#四次挥手（重点）\" class=\"headerlink\" title=\"四次挥手（重点）\"></a><strong>四次挥手（重点）</strong></h4><ul>\n<li>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</li>\n<li>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</li>\n</ul>\n<p>下面来看看四次挥手的流程图：</p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/7.jpg\" alt=\"四次挥手\"></p>\n<p>​    中断连接端可以是客户端，也可以是服务器端。</p>\n<ul>\n<li>第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li>\n<li>第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。</li>\n<li>第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。</li>\n<li>第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li>\n</ul>\n<p><strong>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况。</strong></p>\n<p>具体流程如下图：</p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/8.jpg\" alt=\"同时挥手\"></p>\n<h4 id=\"通过序列号与确认应答提高可靠性\"><a href=\"#通过序列号与确认应答提高可靠性\" class=\"headerlink\" title=\"通过序列号与确认应答提高可靠性\"></a>通过序列号与确认应答提高可靠性</h4><ul>\n<li><p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。<strong>反之，则数据丢失的可能性很大</strong>。</p>\n</li>\n<li><p>在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。</p>\n</li>\n<li><p>未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。</p>\n</li>\n<li><p>此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。</p>\n</li>\n<li><p>对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。</p>\n</li>\n<li><p><strong>序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</strong></p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/9.jpg\" alt=\"序列号和确认问答\"></p>\n</li>\n</ul>\n<h4 id=\"重发超时的确定\"><a href=\"#重发超时的确定\" class=\"headerlink\" title=\"重发超时的确定\"></a><strong>重发超时的确定</strong></h4><ul>\n<li><strong>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。</strong>如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。</li>\n<li>TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。</li>\n<li>在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。</li>\n<li>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</li>\n<li>此外，<strong>数据也不会被反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</strong></li>\n</ul>\n<h4 id=\"以段为单位发送数据\"><a href=\"#以段为单位发送数据\" class=\"headerlink\" title=\"以段为单位发送数据\"></a>以段为单位发送数据</h4><ul>\n<li>在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“<strong>消息长度”（MSS）。最理想的情况是，消息长度正好是 IP 中不会被分片处理的数据长度</strong>。</li>\n<li>TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。</li>\n<li>MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。</li>\n</ul>\n<h4 id=\"利用窗口控制提高速度\"><a href=\"#利用窗口控制提高速度\" class=\"headerlink\" title=\"利用窗口控制提高速度\"></a>利用窗口控制提高速度</h4><ul>\n<li>TCP 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。</li>\n<li>为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/10.jpg\" alt=\"窗口控制\"></p>\n<ul>\n<li>窗口控制</li>\n<li>窗口大小就是指无需等待确认应答而可以继续发送数据的数据值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。</li>\n</ul>\n<h4 id=\"滑动窗口控制\"><a href=\"#滑动窗口控制\" class=\"headerlink\" title=\"滑动窗口控制\"></a><strong>滑动窗口控制</strong></h4><p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/11.jpg\" alt=\"滑动窗口\"></p>\n<ul>\n<li>上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。</li>\n<li>在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</li>\n<li>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。</li>\n</ul>\n<h4 id=\"窗口控制中的重发控制\"><a href=\"#窗口控制中的重发控制\" class=\"headerlink\" title=\"窗口控制中的重发控制\"></a>窗口控制中的重发控制</h4><p>在使用窗口控制中， 出现丢包一般分为两种情况：</p>\n<p>① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：</p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/12.jpg\" alt=\"部分确认应答丢失\"></p>\n<p>② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。</p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/13.jpg\" alt=\"高速重发控制\"></p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<h2 id=\"传输层中的TCP和UDP\"><a href=\"#传输层中的TCP和UDP\" class=\"headerlink\" title=\"传输层中的TCP和UDP\"></a>传输层中的TCP和UDP</h2><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p>\n<ul>\n<li>TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</li>\n<li>UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</li>\n<li>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</li>\n</ul>\n<h3 id=\"端口号\"><a href=\"#端口号\" class=\"headerlink\" title=\"端口号\"></a><strong>端口号</strong></h3><p>数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p>\n<h4 id=\"根据端口号识别应用\"><a href=\"#根据端口号识别应用\" class=\"headerlink\" title=\"根据端口号识别应用\"></a><strong>根据端口号识别应用</strong></h4><p>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/3.jpg\" alt=\"通过端口号识别应用\"></p>\n<h4 id=\"通过-IP-地址、端口号、协议号进行通信识别\"><a href=\"#通过-IP-地址、端口号、协议号进行通信识别\" class=\"headerlink\" title=\"通过 IP 地址、端口号、协议号进行通信识别\"></a>通过 IP 地址、端口号、协议号进行通信识别</h4><p>仅凭目标端口号识别某一个通信是远远不够的。</p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/4.jpg\" alt=\"通过端口号、IP地址、协议号进行通信识别\"></p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/5.jpg\" alt=\"通过端口号、IP地址、协议号进行通信识别\"></p>\n<p>① 和② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。</p>\n<p>③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。</p>\n<p>此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。</p>\n<h4 id=\"端口号的确定\"><a href=\"#端口号的确定\" class=\"headerlink\" title=\"端口号的确定\"></a>端口号的确定</h4><ul>\n<li>标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0<del>1023 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024</del>49151 之间，不过这些端口号可用于任何通信用途。</li>\n<li>时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 49152~65535 之间。</li>\n</ul>\n<h4 id=\"端口号与协议\"><a href=\"#端口号与协议\" class=\"headerlink\" title=\"端口号与协议\"></a>端口号与协议</h4><ul>\n<li>端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。</li>\n<li>此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。</li>\n</ul>\n<h3 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h3><ul>\n<li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。</li>\n<li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</li>\n<li>此外，传输途中出现丢包，UDP 也不负责重发。</li>\n<li>甚至当包的到达顺序出现乱序时也没有纠正的功能。</li>\n<li>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</li>\n<li>UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。</li>\n</ul>\n<h3 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h3><ul>\n<li>TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li>\n<li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li>\n<li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。</li>\n</ul>\n<h4 id=\"三次握手（重点）\"><a href=\"#三次握手（重点）\" class=\"headerlink\" title=\"三次握手（重点）\"></a><strong>三次握手（重点）</strong></h4><ul>\n<li>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。</li>\n<li>所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</li>\n</ul>\n<p>下面来看看三次握手的流程图：</p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/6.jpg\" alt=\"三次握手\"></p>\n<ul>\n<li>第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</li>\n<li>第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</li>\n<li>第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</li>\n</ul>\n<h4 id=\"四次挥手（重点）\"><a href=\"#四次挥手（重点）\" class=\"headerlink\" title=\"四次挥手（重点）\"></a><strong>四次挥手（重点）</strong></h4><ul>\n<li>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</li>\n<li>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</li>\n</ul>\n<p>下面来看看四次挥手的流程图：</p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/7.jpg\" alt=\"四次挥手\"></p>\n<p>​    中断连接端可以是客户端，也可以是服务器端。</p>\n<ul>\n<li>第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li>\n<li>第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。</li>\n<li>第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。</li>\n<li>第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li>\n</ul>\n<p><strong>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况。</strong></p>\n<p>具体流程如下图：</p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/8.jpg\" alt=\"同时挥手\"></p>\n<h4 id=\"通过序列号与确认应答提高可靠性\"><a href=\"#通过序列号与确认应答提高可靠性\" class=\"headerlink\" title=\"通过序列号与确认应答提高可靠性\"></a>通过序列号与确认应答提高可靠性</h4><ul>\n<li><p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。<strong>反之，则数据丢失的可能性很大</strong>。</p>\n</li>\n<li><p>在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。</p>\n</li>\n<li><p>未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。</p>\n</li>\n<li><p>此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。</p>\n</li>\n<li><p>对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。</p>\n</li>\n<li><p><strong>序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</strong></p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/9.jpg\" alt=\"序列号和确认问答\"></p>\n</li>\n</ul>\n<h4 id=\"重发超时的确定\"><a href=\"#重发超时的确定\" class=\"headerlink\" title=\"重发超时的确定\"></a><strong>重发超时的确定</strong></h4><ul>\n<li><strong>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。</strong>如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。</li>\n<li>TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。</li>\n<li>在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。</li>\n<li>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</li>\n<li>此外，<strong>数据也不会被反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</strong></li>\n</ul>\n<h4 id=\"以段为单位发送数据\"><a href=\"#以段为单位发送数据\" class=\"headerlink\" title=\"以段为单位发送数据\"></a>以段为单位发送数据</h4><ul>\n<li>在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“<strong>消息长度”（MSS）。最理想的情况是，消息长度正好是 IP 中不会被分片处理的数据长度</strong>。</li>\n<li>TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。</li>\n<li>MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。</li>\n</ul>\n<h4 id=\"利用窗口控制提高速度\"><a href=\"#利用窗口控制提高速度\" class=\"headerlink\" title=\"利用窗口控制提高速度\"></a>利用窗口控制提高速度</h4><ul>\n<li>TCP 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。</li>\n<li>为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：</li>\n</ul>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/10.jpg\" alt=\"窗口控制\"></p>\n<ul>\n<li>窗口控制</li>\n<li>窗口大小就是指无需等待确认应答而可以继续发送数据的数据值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。</li>\n</ul>\n<h4 id=\"滑动窗口控制\"><a href=\"#滑动窗口控制\" class=\"headerlink\" title=\"滑动窗口控制\"></a><strong>滑动窗口控制</strong></h4><p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/11.jpg\" alt=\"滑动窗口\"></p>\n<ul>\n<li>上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。</li>\n<li>在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</li>\n<li>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。</li>\n</ul>\n<h4 id=\"窗口控制中的重发控制\"><a href=\"#窗口控制中的重发控制\" class=\"headerlink\" title=\"窗口控制中的重发控制\"></a>窗口控制中的重发控制</h4><p>在使用窗口控制中， 出现丢包一般分为两种情况：</p>\n<p>① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：</p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/12.jpg\" alt=\"部分确认应答丢失\"></p>\n<p>② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。</p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan-er-tcp-he-udp-xie-yi-xiang-jie/13.jpg\" alt=\"高速重发控制\"></p>\n"},{"title":"大话TCP/IP协议栈 一 网络模型","date":"2020-02-29T05:26:43.000Z","_content":"\n## TCP/IP协议和TCP/IP协议族\n\n​\t通常我们说的tcp/ip协议就像大家口中所说的`tcp/ip`协议，也就是`tcp协议`和`ip协议`两个协议。当然狭义上确实是这两个协议，但通常tcp/ip协议指的是利用IP进行通信时所必须用到的`协议群的统称`。具体来说，`IP` 或 `ICMP`、`TCP` 或 `UDP`、`TELNET` 或 `FTP`、以及 `HTTP` 等都属于 `TCP/IP 协议族群`。\n\n### TCP/IP协议\n\n| 协议名称                      | 中文名称     | 协议功能                                                     |\n| :---------------------------- | ------------ | ------------------------------------------------------------ |\n| Transmission Control Protocol | 传输控制协议 | 一种面向连接的、可靠的、基于字节流的传输层通信协议           |\n| Internet Protocol             | 网际协议     | 负责Internet上网络之间的通信，并规定了将数据从一个网络传输到另一个网络应遵循的规则 |\n\n\n\n### TCP/IP协议族\n\n| 协议名称                              | 中文名称         | 协议功能                                                     |\n| :------------------------------------ | ---------------- | ------------------------------------------------------------ |\n| **Transmission Control Protocol**     | 传输控制协议     | 一种面向连接的、可靠的、基于字节流的传输层通信协议           |\n| **Internet Protocol**                 | 网际协议         | 负责Internet上网络之间的通信，并规定了将数据从一个网络传输到另一个网络应遵循的规则 |\n| **User Datagram Protocol**            | 用户报文协议     | 无连接的传输协议，该协议称为用户数据报协议                   |\n| **Internet Control Message Protocol** | 控制报文协议     | 用于在ip主机和路由器之间传递消息                             |\n| **Telnet**                            | 远程登陆服务协议 | 为用户提供了在本地计算机上完成远程主机工作的能力             |\n| **File Transfer Protocol**            | 文件传输协议     | 用于文件传输的协议                                           |\n| **HyperText Transfer Protocol**       | 超文本传输协议   | 是一种用于分布式、协作式和超媒体信息系统的应用层协议         |\n\n​\t所以说tcp/ip协议不是简单的两个协议，而是代表着网络通讯的协议族。\n\n## 网络分层模型\n\n​\t在网络通讯的时候，由硬件支持到数据传输，必须通过一层一层的数据包装才可以安全有效的进行工作。ISO提出的OSI（Open System Interconnection）模型将网络分为七层，而因特网协议栈共有五层：应用层、传输层、网络层、链路层和物理层。\n\n### **应用层**\n\n​\t支持网络应用，应用协议仅仅是网络应用的一个组成部分，运行在不同主机上的进程则使用应用层协议进行通信。主要的协议有：http、ftp、telnet、smtp、pop3等。\n\n### **传输层**\n\n​\t负责为信源和信宿提供应用程序进程间的数据传输服务，这一层上主要定义了两个传输协议，传输控制协议即TCP和用户数据报协议UDP。\n\n### **网络层**\n\n​\t负责将数据报独立地从信源发送到信宿，主要解决路由选择、拥塞控制和网络互联等问题。\n\n### **数据链路层**\n\n​\t负责将IP数据报`封装`成合适在物理网络上传输的`帧`格式并传输，或将从物理网络接收到的帧解封，取出IP数据报交给网络层。\n\n### **物理层**\n\n​\t负责将比特流在结点间传输，即负责物理传输。该层的协议既与链路有关也与传输介质有关。\n\n### 模型表格图示\n\n| OSI七层模型 | TCP/IP概念模型 | 功能                                   | TCP/IP协议族                       |\n| ----------- | -------------- | -------------------------------------- | ---------------------------------- |\n| 应用层      | 应用层         | 文件传输、电子邮件、文件服务、虚拟终端 | TFTP、HTTP、FTP、SMTP、DNS、Telnet |\n| 表示层      | 应用层         | 数据格式化、代码转换、数据加密         | 无协议                             |\n| 会话层      | 应用层         | 解除或建立和别的连接点的联系           | 无协议                             |\n| 传输层      | 传输层         | 提供端对端的接口                       | TCP、UDP                           |\n| 网络层      | 网络层         | 为数据包选择路由                       | IP、ICMP、RIP、OSPF、BCP、ICMP     |\n| 数据链路层  | 链路层         | 传输有地址的帧以及错误检测功能         | SLIP、CSLIP、PPP、ARP、PARP        |\n| 物理层      | 链路层         | 以二进制的形式在物理媒介上传输数据     | ISO2110、IEEE802、IEEE802.2        |\n\n​\t事实上ISO旨在指定协议规则，传输过程中每层的功能，而tcp/ip协议面对的是程序传输功能的实现。所以今儿简化了传输过程的分层结构。\n\n## TCP/IP基础\n\n​\t互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。\n\n### **数据包**\n\n**包、帧、数据包、段、消息**\n\n以上五个术语都用来表述数据的单位，大致区分如下：\n\n- `包`可以说是全能性术语；\n- `帧`用于表示`数据链路层`中`包`的单位；\n- 数据包是 `IP` 和 `UDP` 等网络层以上的分层中`包`的单位；\n- 段则表示 TCP 数据流中的`信息`；\n- 消息是指应用协议中数据的`单位`。\n\n每个分层中，都会对所发送的数据附加一个`首部`，在这个首部中包含了该层必要的信息，如发送的`目标地址`以及协议相关信息。通常，为协议提供的信息为`包首部`，所要发送的内容为`数据`。在下一层的角度看，从上一层收到的包全部都被认为是`本层的数据`。\n\n![数据包](/1.jpg)\n\n​\t网络中传输的数据包由两部分组成：一部分是协议所要用到的`首部`，另一部分是上一层传过来的`数据`。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。**包首部就像协议的脸**\n\n### **数据处理流程**\n\n​\t在数据处理的过程中，以A给B发送邮件为例子：\n\n​\t![数据处理流程](/2.jpg)\n\n① 应用程序处理\n\n首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；\n\n编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。\n\n② TCP 模块的处理\n\nTCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。\n\n③ IP 模块的处理\n\nIP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。\n\n④ 网络接口（以太网驱动）的处理\n\n从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。\n\n⑤ 网络接口（以太网驱动）的处理\n\n主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。\n\n如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。\n\n⑥ IP 模块的处理\n\nIP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。\n\n另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。\n\n⑦ TCP 模块的处理\n\n在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。\n\n⑧ 应用程序的处理\n\n接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。","source":"_posts/大话Tcp-Ip协议栈.md","raw":"---\ntitle: 大话TCP/IP协议栈 一 网络模型\ndate: 2020-02-29 13:26:43\ntags: [tcp/ip协议,网络协议]\ncategory: tcp/ip协议\n\n---\n\n## TCP/IP协议和TCP/IP协议族\n\n​\t通常我们说的tcp/ip协议就像大家口中所说的`tcp/ip`协议，也就是`tcp协议`和`ip协议`两个协议。当然狭义上确实是这两个协议，但通常tcp/ip协议指的是利用IP进行通信时所必须用到的`协议群的统称`。具体来说，`IP` 或 `ICMP`、`TCP` 或 `UDP`、`TELNET` 或 `FTP`、以及 `HTTP` 等都属于 `TCP/IP 协议族群`。\n\n### TCP/IP协议\n\n| 协议名称                      | 中文名称     | 协议功能                                                     |\n| :---------------------------- | ------------ | ------------------------------------------------------------ |\n| Transmission Control Protocol | 传输控制协议 | 一种面向连接的、可靠的、基于字节流的传输层通信协议           |\n| Internet Protocol             | 网际协议     | 负责Internet上网络之间的通信，并规定了将数据从一个网络传输到另一个网络应遵循的规则 |\n\n\n\n### TCP/IP协议族\n\n| 协议名称                              | 中文名称         | 协议功能                                                     |\n| :------------------------------------ | ---------------- | ------------------------------------------------------------ |\n| **Transmission Control Protocol**     | 传输控制协议     | 一种面向连接的、可靠的、基于字节流的传输层通信协议           |\n| **Internet Protocol**                 | 网际协议         | 负责Internet上网络之间的通信，并规定了将数据从一个网络传输到另一个网络应遵循的规则 |\n| **User Datagram Protocol**            | 用户报文协议     | 无连接的传输协议，该协议称为用户数据报协议                   |\n| **Internet Control Message Protocol** | 控制报文协议     | 用于在ip主机和路由器之间传递消息                             |\n| **Telnet**                            | 远程登陆服务协议 | 为用户提供了在本地计算机上完成远程主机工作的能力             |\n| **File Transfer Protocol**            | 文件传输协议     | 用于文件传输的协议                                           |\n| **HyperText Transfer Protocol**       | 超文本传输协议   | 是一种用于分布式、协作式和超媒体信息系统的应用层协议         |\n\n​\t所以说tcp/ip协议不是简单的两个协议，而是代表着网络通讯的协议族。\n\n## 网络分层模型\n\n​\t在网络通讯的时候，由硬件支持到数据传输，必须通过一层一层的数据包装才可以安全有效的进行工作。ISO提出的OSI（Open System Interconnection）模型将网络分为七层，而因特网协议栈共有五层：应用层、传输层、网络层、链路层和物理层。\n\n### **应用层**\n\n​\t支持网络应用，应用协议仅仅是网络应用的一个组成部分，运行在不同主机上的进程则使用应用层协议进行通信。主要的协议有：http、ftp、telnet、smtp、pop3等。\n\n### **传输层**\n\n​\t负责为信源和信宿提供应用程序进程间的数据传输服务，这一层上主要定义了两个传输协议，传输控制协议即TCP和用户数据报协议UDP。\n\n### **网络层**\n\n​\t负责将数据报独立地从信源发送到信宿，主要解决路由选择、拥塞控制和网络互联等问题。\n\n### **数据链路层**\n\n​\t负责将IP数据报`封装`成合适在物理网络上传输的`帧`格式并传输，或将从物理网络接收到的帧解封，取出IP数据报交给网络层。\n\n### **物理层**\n\n​\t负责将比特流在结点间传输，即负责物理传输。该层的协议既与链路有关也与传输介质有关。\n\n### 模型表格图示\n\n| OSI七层模型 | TCP/IP概念模型 | 功能                                   | TCP/IP协议族                       |\n| ----------- | -------------- | -------------------------------------- | ---------------------------------- |\n| 应用层      | 应用层         | 文件传输、电子邮件、文件服务、虚拟终端 | TFTP、HTTP、FTP、SMTP、DNS、Telnet |\n| 表示层      | 应用层         | 数据格式化、代码转换、数据加密         | 无协议                             |\n| 会话层      | 应用层         | 解除或建立和别的连接点的联系           | 无协议                             |\n| 传输层      | 传输层         | 提供端对端的接口                       | TCP、UDP                           |\n| 网络层      | 网络层         | 为数据包选择路由                       | IP、ICMP、RIP、OSPF、BCP、ICMP     |\n| 数据链路层  | 链路层         | 传输有地址的帧以及错误检测功能         | SLIP、CSLIP、PPP、ARP、PARP        |\n| 物理层      | 链路层         | 以二进制的形式在物理媒介上传输数据     | ISO2110、IEEE802、IEEE802.2        |\n\n​\t事实上ISO旨在指定协议规则，传输过程中每层的功能，而tcp/ip协议面对的是程序传输功能的实现。所以今儿简化了传输过程的分层结构。\n\n## TCP/IP基础\n\n​\t互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。\n\n### **数据包**\n\n**包、帧、数据包、段、消息**\n\n以上五个术语都用来表述数据的单位，大致区分如下：\n\n- `包`可以说是全能性术语；\n- `帧`用于表示`数据链路层`中`包`的单位；\n- 数据包是 `IP` 和 `UDP` 等网络层以上的分层中`包`的单位；\n- 段则表示 TCP 数据流中的`信息`；\n- 消息是指应用协议中数据的`单位`。\n\n每个分层中，都会对所发送的数据附加一个`首部`，在这个首部中包含了该层必要的信息，如发送的`目标地址`以及协议相关信息。通常，为协议提供的信息为`包首部`，所要发送的内容为`数据`。在下一层的角度看，从上一层收到的包全部都被认为是`本层的数据`。\n\n![数据包](/1.jpg)\n\n​\t网络中传输的数据包由两部分组成：一部分是协议所要用到的`首部`，另一部分是上一层传过来的`数据`。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。**包首部就像协议的脸**\n\n### **数据处理流程**\n\n​\t在数据处理的过程中，以A给B发送邮件为例子：\n\n​\t![数据处理流程](/2.jpg)\n\n① 应用程序处理\n\n首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；\n\n编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。\n\n② TCP 模块的处理\n\nTCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。\n\n③ IP 模块的处理\n\nIP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。\n\n④ 网络接口（以太网驱动）的处理\n\n从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。\n\n⑤ 网络接口（以太网驱动）的处理\n\n主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。\n\n如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。\n\n⑥ IP 模块的处理\n\nIP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。\n\n另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。\n\n⑦ TCP 模块的处理\n\n在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。\n\n⑧ 应用程序的处理\n\n接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。","slug":"大话Tcp-Ip协议栈","published":1,"updated":"2020-02-29T05:33:17.815Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rjn001fzd5b2owr62or","content":"<h2 id=\"TCP-IP协议和TCP-IP协议族\"><a href=\"#TCP-IP协议和TCP-IP协议族\" class=\"headerlink\" title=\"TCP/IP协议和TCP/IP协议族\"></a>TCP/IP协议和TCP/IP协议族</h2><p>​    通常我们说的tcp/ip协议就像大家口中所说的<code>tcp/ip</code>协议，也就是<code>tcp协议</code>和<code>ip协议</code>两个协议。当然狭义上确实是这两个协议，但通常tcp/ip协议指的是利用IP进行通信时所必须用到的<code>协议群的统称</code>。具体来说，<code>IP</code> 或 <code>ICMP</code>、<code>TCP</code> 或 <code>UDP</code>、<code>TELNET</code> 或 <code>FTP</code>、以及 <code>HTTP</code> 等都属于 <code>TCP/IP 协议族群</code>。</p>\n<h3 id=\"TCP-IP协议\"><a href=\"#TCP-IP协议\" class=\"headerlink\" title=\"TCP/IP协议\"></a>TCP/IP协议</h3><table>\n<thead>\n<tr>\n<th align=\"left\">协议名称</th>\n<th>中文名称</th>\n<th>协议功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Transmission Control Protocol</td>\n<td>传输控制协议</td>\n<td>一种面向连接的、可靠的、基于字节流的传输层通信协议</td>\n</tr>\n<tr>\n<td align=\"left\">Internet Protocol</td>\n<td>网际协议</td>\n<td>负责Internet上网络之间的通信，并规定了将数据从一个网络传输到另一个网络应遵循的规则</td>\n</tr>\n</tbody></table>\n<h3 id=\"TCP-IP协议族\"><a href=\"#TCP-IP协议族\" class=\"headerlink\" title=\"TCP/IP协议族\"></a>TCP/IP协议族</h3><table>\n<thead>\n<tr>\n<th align=\"left\">协议名称</th>\n<th>中文名称</th>\n<th>协议功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Transmission Control Protocol</strong></td>\n<td>传输控制协议</td>\n<td>一种面向连接的、可靠的、基于字节流的传输层通信协议</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Internet Protocol</strong></td>\n<td>网际协议</td>\n<td>负责Internet上网络之间的通信，并规定了将数据从一个网络传输到另一个网络应遵循的规则</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>User Datagram Protocol</strong></td>\n<td>用户报文协议</td>\n<td>无连接的传输协议，该协议称为用户数据报协议</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Internet Control Message Protocol</strong></td>\n<td>控制报文协议</td>\n<td>用于在ip主机和路由器之间传递消息</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Telnet</strong></td>\n<td>远程登陆服务协议</td>\n<td>为用户提供了在本地计算机上完成远程主机工作的能力</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>File Transfer Protocol</strong></td>\n<td>文件传输协议</td>\n<td>用于文件传输的协议</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>HyperText Transfer Protocol</strong></td>\n<td>超文本传输协议</td>\n<td>是一种用于分布式、协作式和超媒体信息系统的应用层协议</td>\n</tr>\n</tbody></table>\n<p>​    所以说tcp/ip协议不是简单的两个协议，而是代表着网络通讯的协议族。</p>\n<h2 id=\"网络分层模型\"><a href=\"#网络分层模型\" class=\"headerlink\" title=\"网络分层模型\"></a>网络分层模型</h2><p>​    在网络通讯的时候，由硬件支持到数据传输，必须通过一层一层的数据包装才可以安全有效的进行工作。ISO提出的OSI（Open System Interconnection）模型将网络分为七层，而因特网协议栈共有五层：应用层、传输层、网络层、链路层和物理层。</p>\n<h3 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a><strong>应用层</strong></h3><p>​    支持网络应用，应用协议仅仅是网络应用的一个组成部分，运行在不同主机上的进程则使用应用层协议进行通信。主要的协议有：http、ftp、telnet、smtp、pop3等。</p>\n<h3 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a><strong>传输层</strong></h3><p>​    负责为信源和信宿提供应用程序进程间的数据传输服务，这一层上主要定义了两个传输协议，传输控制协议即TCP和用户数据报协议UDP。</p>\n<h3 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a><strong>网络层</strong></h3><p>​    负责将数据报独立地从信源发送到信宿，主要解决路由选择、拥塞控制和网络互联等问题。</p>\n<h3 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a><strong>数据链路层</strong></h3><p>​    负责将IP数据报<code>封装</code>成合适在物理网络上传输的<code>帧</code>格式并传输，或将从物理网络接收到的帧解封，取出IP数据报交给网络层。</p>\n<h3 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a><strong>物理层</strong></h3><p>​    负责将比特流在结点间传输，即负责物理传输。该层的协议既与链路有关也与传输介质有关。</p>\n<h3 id=\"模型表格图示\"><a href=\"#模型表格图示\" class=\"headerlink\" title=\"模型表格图示\"></a>模型表格图示</h3><table>\n<thead>\n<tr>\n<th>OSI七层模型</th>\n<th>TCP/IP概念模型</th>\n<th>功能</th>\n<th>TCP/IP协议族</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>应用层</td>\n<td>应用层</td>\n<td>文件传输、电子邮件、文件服务、虚拟终端</td>\n<td>TFTP、HTTP、FTP、SMTP、DNS、Telnet</td>\n</tr>\n<tr>\n<td>表示层</td>\n<td>应用层</td>\n<td>数据格式化、代码转换、数据加密</td>\n<td>无协议</td>\n</tr>\n<tr>\n<td>会话层</td>\n<td>应用层</td>\n<td>解除或建立和别的连接点的联系</td>\n<td>无协议</td>\n</tr>\n<tr>\n<td>传输层</td>\n<td>传输层</td>\n<td>提供端对端的接口</td>\n<td>TCP、UDP</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td>网络层</td>\n<td>为数据包选择路由</td>\n<td>IP、ICMP、RIP、OSPF、BCP、ICMP</td>\n</tr>\n<tr>\n<td>数据链路层</td>\n<td>链路层</td>\n<td>传输有地址的帧以及错误检测功能</td>\n<td>SLIP、CSLIP、PPP、ARP、PARP</td>\n</tr>\n<tr>\n<td>物理层</td>\n<td>链路层</td>\n<td>以二进制的形式在物理媒介上传输数据</td>\n<td>ISO2110、IEEE802、IEEE802.2</td>\n</tr>\n</tbody></table>\n<p>​    事实上ISO旨在指定协议规则，传输过程中每层的功能，而tcp/ip协议面对的是程序传输功能的实现。所以今儿简化了传输过程的分层结构。</p>\n<h2 id=\"TCP-IP基础\"><a href=\"#TCP-IP基础\" class=\"headerlink\" title=\"TCP/IP基础\"></a>TCP/IP基础</h2><p>​    互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p>\n<h3 id=\"数据包\"><a href=\"#数据包\" class=\"headerlink\" title=\"数据包\"></a><strong>数据包</strong></h3><p><strong>包、帧、数据包、段、消息</strong></p>\n<p>以上五个术语都用来表述数据的单位，大致区分如下：</p>\n<ul>\n<li><code>包</code>可以说是全能性术语；</li>\n<li><code>帧</code>用于表示<code>数据链路层</code>中<code>包</code>的单位；</li>\n<li>数据包是 <code>IP</code> 和 <code>UDP</code> 等网络层以上的分层中<code>包</code>的单位；</li>\n<li>段则表示 TCP 数据流中的<code>信息</code>；</li>\n<li>消息是指应用协议中数据的<code>单位</code>。</li>\n</ul>\n<p>每个分层中，都会对所发送的数据附加一个<code>首部</code>，在这个首部中包含了该层必要的信息，如发送的<code>目标地址</code>以及协议相关信息。通常，为协议提供的信息为<code>包首部</code>，所要发送的内容为<code>数据</code>。在下一层的角度看，从上一层收到的包全部都被认为是<code>本层的数据</code>。</p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan/1.jpg\" alt=\"数据包\"></p>\n<p>​    网络中传输的数据包由两部分组成：一部分是协议所要用到的<code>首部</code>，另一部分是上一层传过来的<code>数据</code>。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。<strong>包首部就像协议的脸</strong></p>\n<h3 id=\"数据处理流程\"><a href=\"#数据处理流程\" class=\"headerlink\" title=\"数据处理流程\"></a><strong>数据处理流程</strong></h3><p>​    在数据处理的过程中，以A给B发送邮件为例子：</p>\n<p>​    <img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan/2.jpg\" alt=\"数据处理流程\"></p>\n<p>① 应用程序处理</p>\n<p>首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；</p>\n<p>编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</p>\n<p>② TCP 模块的处理</p>\n<p>TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</p>\n<p>③ IP 模块的处理</p>\n<p>IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</p>\n<p>④ 网络接口（以太网驱动）的处理</p>\n<p>从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</p>\n<p>⑤ 网络接口（以太网驱动）的处理</p>\n<p>主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。</p>\n<p>如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</p>\n<p>⑥ IP 模块的处理</p>\n<p>IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。</p>\n<p>另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</p>\n<p>⑦ TCP 模块的处理</p>\n<p>在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</p>\n<p>⑧ 应用程序的处理</p>\n<p>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<h2 id=\"TCP-IP协议和TCP-IP协议族\"><a href=\"#TCP-IP协议和TCP-IP协议族\" class=\"headerlink\" title=\"TCP/IP协议和TCP/IP协议族\"></a>TCP/IP协议和TCP/IP协议族</h2><p>​    通常我们说的tcp/ip协议就像大家口中所说的<code>tcp/ip</code>协议，也就是<code>tcp协议</code>和<code>ip协议</code>两个协议。当然狭义上确实是这两个协议，但通常tcp/ip协议指的是利用IP进行通信时所必须用到的<code>协议群的统称</code>。具体来说，<code>IP</code> 或 <code>ICMP</code>、<code>TCP</code> 或 <code>UDP</code>、<code>TELNET</code> 或 <code>FTP</code>、以及 <code>HTTP</code> 等都属于 <code>TCP/IP 协议族群</code>。</p>\n<h3 id=\"TCP-IP协议\"><a href=\"#TCP-IP协议\" class=\"headerlink\" title=\"TCP/IP协议\"></a>TCP/IP协议</h3><table>\n<thead>\n<tr>\n<th align=\"left\">协议名称</th>\n<th>中文名称</th>\n<th>协议功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Transmission Control Protocol</td>\n<td>传输控制协议</td>\n<td>一种面向连接的、可靠的、基于字节流的传输层通信协议</td>\n</tr>\n<tr>\n<td align=\"left\">Internet Protocol</td>\n<td>网际协议</td>\n<td>负责Internet上网络之间的通信，并规定了将数据从一个网络传输到另一个网络应遵循的规则</td>\n</tr>\n</tbody></table>\n<h3 id=\"TCP-IP协议族\"><a href=\"#TCP-IP协议族\" class=\"headerlink\" title=\"TCP/IP协议族\"></a>TCP/IP协议族</h3><table>\n<thead>\n<tr>\n<th align=\"left\">协议名称</th>\n<th>中文名称</th>\n<th>协议功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Transmission Control Protocol</strong></td>\n<td>传输控制协议</td>\n<td>一种面向连接的、可靠的、基于字节流的传输层通信协议</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Internet Protocol</strong></td>\n<td>网际协议</td>\n<td>负责Internet上网络之间的通信，并规定了将数据从一个网络传输到另一个网络应遵循的规则</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>User Datagram Protocol</strong></td>\n<td>用户报文协议</td>\n<td>无连接的传输协议，该协议称为用户数据报协议</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Internet Control Message Protocol</strong></td>\n<td>控制报文协议</td>\n<td>用于在ip主机和路由器之间传递消息</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Telnet</strong></td>\n<td>远程登陆服务协议</td>\n<td>为用户提供了在本地计算机上完成远程主机工作的能力</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>File Transfer Protocol</strong></td>\n<td>文件传输协议</td>\n<td>用于文件传输的协议</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>HyperText Transfer Protocol</strong></td>\n<td>超文本传输协议</td>\n<td>是一种用于分布式、协作式和超媒体信息系统的应用层协议</td>\n</tr>\n</tbody></table>\n<p>​    所以说tcp/ip协议不是简单的两个协议，而是代表着网络通讯的协议族。</p>\n<h2 id=\"网络分层模型\"><a href=\"#网络分层模型\" class=\"headerlink\" title=\"网络分层模型\"></a>网络分层模型</h2><p>​    在网络通讯的时候，由硬件支持到数据传输，必须通过一层一层的数据包装才可以安全有效的进行工作。ISO提出的OSI（Open System Interconnection）模型将网络分为七层，而因特网协议栈共有五层：应用层、传输层、网络层、链路层和物理层。</p>\n<h3 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a><strong>应用层</strong></h3><p>​    支持网络应用，应用协议仅仅是网络应用的一个组成部分，运行在不同主机上的进程则使用应用层协议进行通信。主要的协议有：http、ftp、telnet、smtp、pop3等。</p>\n<h3 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a><strong>传输层</strong></h3><p>​    负责为信源和信宿提供应用程序进程间的数据传输服务，这一层上主要定义了两个传输协议，传输控制协议即TCP和用户数据报协议UDP。</p>\n<h3 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a><strong>网络层</strong></h3><p>​    负责将数据报独立地从信源发送到信宿，主要解决路由选择、拥塞控制和网络互联等问题。</p>\n<h3 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a><strong>数据链路层</strong></h3><p>​    负责将IP数据报<code>封装</code>成合适在物理网络上传输的<code>帧</code>格式并传输，或将从物理网络接收到的帧解封，取出IP数据报交给网络层。</p>\n<h3 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a><strong>物理层</strong></h3><p>​    负责将比特流在结点间传输，即负责物理传输。该层的协议既与链路有关也与传输介质有关。</p>\n<h3 id=\"模型表格图示\"><a href=\"#模型表格图示\" class=\"headerlink\" title=\"模型表格图示\"></a>模型表格图示</h3><table>\n<thead>\n<tr>\n<th>OSI七层模型</th>\n<th>TCP/IP概念模型</th>\n<th>功能</th>\n<th>TCP/IP协议族</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>应用层</td>\n<td>应用层</td>\n<td>文件传输、电子邮件、文件服务、虚拟终端</td>\n<td>TFTP、HTTP、FTP、SMTP、DNS、Telnet</td>\n</tr>\n<tr>\n<td>表示层</td>\n<td>应用层</td>\n<td>数据格式化、代码转换、数据加密</td>\n<td>无协议</td>\n</tr>\n<tr>\n<td>会话层</td>\n<td>应用层</td>\n<td>解除或建立和别的连接点的联系</td>\n<td>无协议</td>\n</tr>\n<tr>\n<td>传输层</td>\n<td>传输层</td>\n<td>提供端对端的接口</td>\n<td>TCP、UDP</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td>网络层</td>\n<td>为数据包选择路由</td>\n<td>IP、ICMP、RIP、OSPF、BCP、ICMP</td>\n</tr>\n<tr>\n<td>数据链路层</td>\n<td>链路层</td>\n<td>传输有地址的帧以及错误检测功能</td>\n<td>SLIP、CSLIP、PPP、ARP、PARP</td>\n</tr>\n<tr>\n<td>物理层</td>\n<td>链路层</td>\n<td>以二进制的形式在物理媒介上传输数据</td>\n<td>ISO2110、IEEE802、IEEE802.2</td>\n</tr>\n</tbody></table>\n<p>​    事实上ISO旨在指定协议规则，传输过程中每层的功能，而tcp/ip协议面对的是程序传输功能的实现。所以今儿简化了传输过程的分层结构。</p>\n<h2 id=\"TCP-IP基础\"><a href=\"#TCP-IP基础\" class=\"headerlink\" title=\"TCP/IP基础\"></a>TCP/IP基础</h2><p>​    互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p>\n<h3 id=\"数据包\"><a href=\"#数据包\" class=\"headerlink\" title=\"数据包\"></a><strong>数据包</strong></h3><p><strong>包、帧、数据包、段、消息</strong></p>\n<p>以上五个术语都用来表述数据的单位，大致区分如下：</p>\n<ul>\n<li><code>包</code>可以说是全能性术语；</li>\n<li><code>帧</code>用于表示<code>数据链路层</code>中<code>包</code>的单位；</li>\n<li>数据包是 <code>IP</code> 和 <code>UDP</code> 等网络层以上的分层中<code>包</code>的单位；</li>\n<li>段则表示 TCP 数据流中的<code>信息</code>；</li>\n<li>消息是指应用协议中数据的<code>单位</code>。</li>\n</ul>\n<p>每个分层中，都会对所发送的数据附加一个<code>首部</code>，在这个首部中包含了该层必要的信息，如发送的<code>目标地址</code>以及协议相关信息。通常，为协议提供的信息为<code>包首部</code>，所要发送的内容为<code>数据</code>。在下一层的角度看，从上一层收到的包全部都被认为是<code>本层的数据</code>。</p>\n<p><img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan/1.jpg\" alt=\"数据包\"></p>\n<p>​    网络中传输的数据包由两部分组成：一部分是协议所要用到的<code>首部</code>，另一部分是上一层传过来的<code>数据</code>。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。<strong>包首部就像协议的脸</strong></p>\n<h3 id=\"数据处理流程\"><a href=\"#数据处理流程\" class=\"headerlink\" title=\"数据处理流程\"></a><strong>数据处理流程</strong></h3><p>​    在数据处理的过程中，以A给B发送邮件为例子：</p>\n<p>​    <img src=\"/2020/02/29/da-hua-tcp-ip-xie-yi-zhan/2.jpg\" alt=\"数据处理流程\"></p>\n<p>① 应用程序处理</p>\n<p>首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；</p>\n<p>编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</p>\n<p>② TCP 模块的处理</p>\n<p>TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</p>\n<p>③ IP 模块的处理</p>\n<p>IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</p>\n<p>④ 网络接口（以太网驱动）的处理</p>\n<p>从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</p>\n<p>⑤ 网络接口（以太网驱动）的处理</p>\n<p>主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。</p>\n<p>如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</p>\n<p>⑥ IP 模块的处理</p>\n<p>IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。</p>\n<p>另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</p>\n<p>⑦ TCP 模块的处理</p>\n<p>在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</p>\n<p>⑧ 应用程序的处理</p>\n<p>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</p>\n"},{"title":"微服务架构 [一] 微服务框架","date":"2020-02-06T04:41:14.000Z","_content":"\n![](/start.png)\n\n## 微服务\n\n要理解微服务，首先要先理解不是微服务的那些。通常跟微服务相对的是单体应用，即将所有功能都打包成在一个独立单元的应用程序。从单体应用到微服务并不是一蹴而就的，这是一个逐渐演变的过程。\n\n### 微服务和单体应用\n\n**单体应用**设计是在微服务之前普遍的软件设计思路，他所有的逻辑、业务、操作、数据管理、传输等都是在一个程序提里面完成。最典型的是操作系统。操作系统作为一个非常庞杂的单体应用，它本身只是一个非常大的代码库，拥有非常强的耦合性，即使在操作系统内核业务分层的情况下，即使各个部件的功能再单一，操作系统相对微服务应用也是强耦合的。\n\n![](/4.jpg)\n\n就Windows操作系统而言，Windows已经将近1000万行代码，想要一个人去把整个系统每行读懂是不太可能的，而且对于系统的维护和开发而是相当困难，迭代速度也会变得比较慢，最难的是很多时候单体应用会牵一发而动全身。\n\n**微服务**   为了避免单体应用非常强的耦合性，微服务应用把程序中最小的逻辑分局变成一个微服务，每个服务都像是Linux下面 ls 工具那么简单，每个服务的职责也很单一，这样维护起来也很简单。\n\n微服务架构还有一个技术外的好处，它使整个系统的分工更加明确，责任更加清晰，每个人专心负责为其他人提供更好的服务。在单体应用的时代，公共的业务功能经常没有明确的归属。最后要么各做各的，每个人都重新实现了一遍；要么是随机一个人（一般是能力比较强或者比较热心的人）做到他负责的应用里面。在后者的情况下，这个人在负责自己应用之外，还要额外负责给别人提供这些公共的功能——而这个功能本来是无人负责的，仅仅因为他能力较强/比较热心，就莫名地背锅（这种情况还被美其名曰能者多劳）。结果最后大家都不愿意提供公共的功能。长此以往，团队里的人渐渐变得各自为政，不再关心全局的架构设计。\n\n从这个角度上看，使用微服务架构同时也需要组织结构做相应的调整。所以说做微服务改造需要管理者的支持。\n\n微服务的主要优势有：\n\n- 迭代周期短，极大提升开发效率\n- 独立部署，独立开发\n- 弹性伸缩，可对应服务伸缩\n- 鼓掌隔离，互不影响\n\n但是微服务也不是处处是优点，他的缺点只要在：\n\n- 设计架构的复杂度增加，一个请求往往会经过很多个服务，请求链路比较长\n- 监控和定位问题困难\n- 服务管理比较复杂\n\n## 微服务架构\n\n微服务落地需要相关的关键服务因素的支持：\n\n### **配套设施**\n\n​\t对于微服务应用必须有必要的配套设施落地才能支持微服务应用\n\n- 微服务框架研发与维护\n- 打包，版本管理，上线平台支持\n- 硬件层支持，容器和容器调度\n- 服务治理平台支持，比如分笔试链路追踪和监控\n- 测试自动化支持，比如上线前自动化case\n\n### **组织架构**\n\n​\t相对单体应用的架构，微服务的组织如下\n\n- 微服务框架研发团队\n- 私有云研发团队\n- 测试平台研发团队\n\n### 微服务生态\n\n![](/1.png)\n\n微服务生态主要的分层包括：**硬件层，通信层，应用平台层，微服务层**。\n\n#### 硬件层\n\n硬件层只要负责 **物理服务器的管理、操作系统管理、配置管理、资源隔离和抽象、主机监控和日志**等。\n\n架构：\n\n![](/2.png)\n\n- 在基础设施层里面我们会选择**EC2、虚拟机、云服务器等机器资源作为基础设施**\n- 上面**使用ubuntu、redhat、centerOS、coreOS等操作系统作为资源调度管理**\n- 但是**不同的机器和操作系统**我需要用到**Docker做容器虚拟化**调度，让上层的**软件系统调用无平台差异**\n- 但是容器间的通信映射等通过**kubernetes**进行管理和分配\n- 最上层是**图形化的弹性分配**，可以**分配微服务资源**\n\n#### 通信层\n\n通信层是对服务之间的的交流做支持，包括各种服务的注册、发现、消息传递等。\n\n- 网络传输\n- RPC (包括 RPC Clinet 和 RPC Server)\n- 服务发现\n- 服务注册\n- 负载均衡\n- 消息传递\n\n#### 网络传输层\n\n网络传输层是用对应的协议支持，来保证传输。\n\n- HTTP+RESTFUL\n  - GET、POST、PUT、DELETE\n- TCP RPC调用\n  - Thrift协议\n  - Dubbox\n  - Grpc\n- 消息传递\n  - json\n  - thrift\n  - protobuf\n\n#### 另外一个角度的微服务 [ 程序架构 ]\n\n![](/3.jpg)\n\n在不同的客户端 [ web、app、pc端等 ]通过Internet访问API网关，然后API网关在访问相对应的微服务，其中每个服务都是通过接口来进行调用，而不是数据，这点非常重要。\n\n#### 微服务的组成\n\nCore部分：单体应用部分\n\n微服务部分： 每个服务都有自己的服务和数据，数据和数据之间都是完全隔离的。每个微服务的网络交互都是通过 **api** **网关**来进行传输控制，包括**限流和熔断**等机制。\n\n其实初期的微服务最好是每个机器单独部署服务，这样是最清爽的，但是很多时候，资源都被浪费了。所以新的Docker，K8s技术等出现就弥补了这个缺口。\n\n好啦，这次先到这啦～\n\n","source":"_posts/微服务架构-一.md","raw":"---\ntitle: 微服务架构 [一] 微服务框架\ndate: 2020-02-06 12:41:14\ntags: [Go,微服务,Micro Service]\ncategories: Go栈\n---\n\n![](/start.png)\n\n## 微服务\n\n要理解微服务，首先要先理解不是微服务的那些。通常跟微服务相对的是单体应用，即将所有功能都打包成在一个独立单元的应用程序。从单体应用到微服务并不是一蹴而就的，这是一个逐渐演变的过程。\n\n### 微服务和单体应用\n\n**单体应用**设计是在微服务之前普遍的软件设计思路，他所有的逻辑、业务、操作、数据管理、传输等都是在一个程序提里面完成。最典型的是操作系统。操作系统作为一个非常庞杂的单体应用，它本身只是一个非常大的代码库，拥有非常强的耦合性，即使在操作系统内核业务分层的情况下，即使各个部件的功能再单一，操作系统相对微服务应用也是强耦合的。\n\n![](/4.jpg)\n\n就Windows操作系统而言，Windows已经将近1000万行代码，想要一个人去把整个系统每行读懂是不太可能的，而且对于系统的维护和开发而是相当困难，迭代速度也会变得比较慢，最难的是很多时候单体应用会牵一发而动全身。\n\n**微服务**   为了避免单体应用非常强的耦合性，微服务应用把程序中最小的逻辑分局变成一个微服务，每个服务都像是Linux下面 ls 工具那么简单，每个服务的职责也很单一，这样维护起来也很简单。\n\n微服务架构还有一个技术外的好处，它使整个系统的分工更加明确，责任更加清晰，每个人专心负责为其他人提供更好的服务。在单体应用的时代，公共的业务功能经常没有明确的归属。最后要么各做各的，每个人都重新实现了一遍；要么是随机一个人（一般是能力比较强或者比较热心的人）做到他负责的应用里面。在后者的情况下，这个人在负责自己应用之外，还要额外负责给别人提供这些公共的功能——而这个功能本来是无人负责的，仅仅因为他能力较强/比较热心，就莫名地背锅（这种情况还被美其名曰能者多劳）。结果最后大家都不愿意提供公共的功能。长此以往，团队里的人渐渐变得各自为政，不再关心全局的架构设计。\n\n从这个角度上看，使用微服务架构同时也需要组织结构做相应的调整。所以说做微服务改造需要管理者的支持。\n\n微服务的主要优势有：\n\n- 迭代周期短，极大提升开发效率\n- 独立部署，独立开发\n- 弹性伸缩，可对应服务伸缩\n- 鼓掌隔离，互不影响\n\n但是微服务也不是处处是优点，他的缺点只要在：\n\n- 设计架构的复杂度增加，一个请求往往会经过很多个服务，请求链路比较长\n- 监控和定位问题困难\n- 服务管理比较复杂\n\n## 微服务架构\n\n微服务落地需要相关的关键服务因素的支持：\n\n### **配套设施**\n\n​\t对于微服务应用必须有必要的配套设施落地才能支持微服务应用\n\n- 微服务框架研发与维护\n- 打包，版本管理，上线平台支持\n- 硬件层支持，容器和容器调度\n- 服务治理平台支持，比如分笔试链路追踪和监控\n- 测试自动化支持，比如上线前自动化case\n\n### **组织架构**\n\n​\t相对单体应用的架构，微服务的组织如下\n\n- 微服务框架研发团队\n- 私有云研发团队\n- 测试平台研发团队\n\n### 微服务生态\n\n![](/1.png)\n\n微服务生态主要的分层包括：**硬件层，通信层，应用平台层，微服务层**。\n\n#### 硬件层\n\n硬件层只要负责 **物理服务器的管理、操作系统管理、配置管理、资源隔离和抽象、主机监控和日志**等。\n\n架构：\n\n![](/2.png)\n\n- 在基础设施层里面我们会选择**EC2、虚拟机、云服务器等机器资源作为基础设施**\n- 上面**使用ubuntu、redhat、centerOS、coreOS等操作系统作为资源调度管理**\n- 但是**不同的机器和操作系统**我需要用到**Docker做容器虚拟化**调度，让上层的**软件系统调用无平台差异**\n- 但是容器间的通信映射等通过**kubernetes**进行管理和分配\n- 最上层是**图形化的弹性分配**，可以**分配微服务资源**\n\n#### 通信层\n\n通信层是对服务之间的的交流做支持，包括各种服务的注册、发现、消息传递等。\n\n- 网络传输\n- RPC (包括 RPC Clinet 和 RPC Server)\n- 服务发现\n- 服务注册\n- 负载均衡\n- 消息传递\n\n#### 网络传输层\n\n网络传输层是用对应的协议支持，来保证传输。\n\n- HTTP+RESTFUL\n  - GET、POST、PUT、DELETE\n- TCP RPC调用\n  - Thrift协议\n  - Dubbox\n  - Grpc\n- 消息传递\n  - json\n  - thrift\n  - protobuf\n\n#### 另外一个角度的微服务 [ 程序架构 ]\n\n![](/3.jpg)\n\n在不同的客户端 [ web、app、pc端等 ]通过Internet访问API网关，然后API网关在访问相对应的微服务，其中每个服务都是通过接口来进行调用，而不是数据，这点非常重要。\n\n#### 微服务的组成\n\nCore部分：单体应用部分\n\n微服务部分： 每个服务都有自己的服务和数据，数据和数据之间都是完全隔离的。每个微服务的网络交互都是通过 **api** **网关**来进行传输控制，包括**限流和熔断**等机制。\n\n其实初期的微服务最好是每个机器单独部署服务，这样是最清爽的，但是很多时候，资源都被浪费了。所以新的Docker，K8s技术等出现就弥补了这个缺口。\n\n好啦，这次先到这啦～\n\n","slug":"微服务架构-一","published":1,"updated":"2020-02-10T02:58:57.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rjq001izd5b59u67lwu","content":"<p><img src=\"/2020/02/06/wei-fu-wu-jia-gou-yi/start.png\" alt></p>\n<h2 id=\"微服务\"><a href=\"#微服务\" class=\"headerlink\" title=\"微服务\"></a>微服务</h2><p>要理解微服务，首先要先理解不是微服务的那些。通常跟微服务相对的是单体应用，即将所有功能都打包成在一个独立单元的应用程序。从单体应用到微服务并不是一蹴而就的，这是一个逐渐演变的过程。</p>\n<h3 id=\"微服务和单体应用\"><a href=\"#微服务和单体应用\" class=\"headerlink\" title=\"微服务和单体应用\"></a>微服务和单体应用</h3><p><strong>单体应用</strong>设计是在微服务之前普遍的软件设计思路，他所有的逻辑、业务、操作、数据管理、传输等都是在一个程序提里面完成。最典型的是操作系统。操作系统作为一个非常庞杂的单体应用，它本身只是一个非常大的代码库，拥有非常强的耦合性，即使在操作系统内核业务分层的情况下，即使各个部件的功能再单一，操作系统相对微服务应用也是强耦合的。</p>\n<p><img src=\"/2020/02/06/wei-fu-wu-jia-gou-yi/4.jpg\" alt></p>\n<p>就Windows操作系统而言，Windows已经将近1000万行代码，想要一个人去把整个系统每行读懂是不太可能的，而且对于系统的维护和开发而是相当困难，迭代速度也会变得比较慢，最难的是很多时候单体应用会牵一发而动全身。</p>\n<p><strong>微服务</strong>   为了避免单体应用非常强的耦合性，微服务应用把程序中最小的逻辑分局变成一个微服务，每个服务都像是Linux下面 ls 工具那么简单，每个服务的职责也很单一，这样维护起来也很简单。</p>\n<p>微服务架构还有一个技术外的好处，它使整个系统的分工更加明确，责任更加清晰，每个人专心负责为其他人提供更好的服务。在单体应用的时代，公共的业务功能经常没有明确的归属。最后要么各做各的，每个人都重新实现了一遍；要么是随机一个人（一般是能力比较强或者比较热心的人）做到他负责的应用里面。在后者的情况下，这个人在负责自己应用之外，还要额外负责给别人提供这些公共的功能——而这个功能本来是无人负责的，仅仅因为他能力较强/比较热心，就莫名地背锅（这种情况还被美其名曰能者多劳）。结果最后大家都不愿意提供公共的功能。长此以往，团队里的人渐渐变得各自为政，不再关心全局的架构设计。</p>\n<p>从这个角度上看，使用微服务架构同时也需要组织结构做相应的调整。所以说做微服务改造需要管理者的支持。</p>\n<p>微服务的主要优势有：</p>\n<ul>\n<li>迭代周期短，极大提升开发效率</li>\n<li>独立部署，独立开发</li>\n<li>弹性伸缩，可对应服务伸缩</li>\n<li>鼓掌隔离，互不影响</li>\n</ul>\n<p>但是微服务也不是处处是优点，他的缺点只要在：</p>\n<ul>\n<li>设计架构的复杂度增加，一个请求往往会经过很多个服务，请求链路比较长</li>\n<li>监控和定位问题困难</li>\n<li>服务管理比较复杂</li>\n</ul>\n<h2 id=\"微服务架构\"><a href=\"#微服务架构\" class=\"headerlink\" title=\"微服务架构\"></a>微服务架构</h2><p>微服务落地需要相关的关键服务因素的支持：</p>\n<h3 id=\"配套设施\"><a href=\"#配套设施\" class=\"headerlink\" title=\"配套设施\"></a><strong>配套设施</strong></h3><p>​    对于微服务应用必须有必要的配套设施落地才能支持微服务应用</p>\n<ul>\n<li>微服务框架研发与维护</li>\n<li>打包，版本管理，上线平台支持</li>\n<li>硬件层支持，容器和容器调度</li>\n<li>服务治理平台支持，比如分笔试链路追踪和监控</li>\n<li>测试自动化支持，比如上线前自动化case</li>\n</ul>\n<h3 id=\"组织架构\"><a href=\"#组织架构\" class=\"headerlink\" title=\"组织架构\"></a><strong>组织架构</strong></h3><p>​    相对单体应用的架构，微服务的组织如下</p>\n<ul>\n<li>微服务框架研发团队</li>\n<li>私有云研发团队</li>\n<li>测试平台研发团队</li>\n</ul>\n<h3 id=\"微服务生态\"><a href=\"#微服务生态\" class=\"headerlink\" title=\"微服务生态\"></a>微服务生态</h3><p><img src=\"/2020/02/06/wei-fu-wu-jia-gou-yi/1.png\" alt></p>\n<p>微服务生态主要的分层包括：<strong>硬件层，通信层，应用平台层，微服务层</strong>。</p>\n<h4 id=\"硬件层\"><a href=\"#硬件层\" class=\"headerlink\" title=\"硬件层\"></a>硬件层</h4><p>硬件层只要负责 <strong>物理服务器的管理、操作系统管理、配置管理、资源隔离和抽象、主机监控和日志</strong>等。</p>\n<p>架构：</p>\n<p><img src=\"/2020/02/06/wei-fu-wu-jia-gou-yi/2.png\" alt></p>\n<ul>\n<li>在基础设施层里面我们会选择<strong>EC2、虚拟机、云服务器等机器资源作为基础设施</strong></li>\n<li>上面<strong>使用ubuntu、redhat、centerOS、coreOS等操作系统作为资源调度管理</strong></li>\n<li>但是<strong>不同的机器和操作系统</strong>我需要用到<strong>Docker做容器虚拟化</strong>调度，让上层的<strong>软件系统调用无平台差异</strong></li>\n<li>但是容器间的通信映射等通过<strong>kubernetes</strong>进行管理和分配</li>\n<li>最上层是<strong>图形化的弹性分配</strong>，可以<strong>分配微服务资源</strong></li>\n</ul>\n<h4 id=\"通信层\"><a href=\"#通信层\" class=\"headerlink\" title=\"通信层\"></a>通信层</h4><p>通信层是对服务之间的的交流做支持，包括各种服务的注册、发现、消息传递等。</p>\n<ul>\n<li>网络传输</li>\n<li>RPC (包括 RPC Clinet 和 RPC Server)</li>\n<li>服务发现</li>\n<li>服务注册</li>\n<li>负载均衡</li>\n<li>消息传递</li>\n</ul>\n<h4 id=\"网络传输层\"><a href=\"#网络传输层\" class=\"headerlink\" title=\"网络传输层\"></a>网络传输层</h4><p>网络传输层是用对应的协议支持，来保证传输。</p>\n<ul>\n<li>HTTP+RESTFUL<ul>\n<li>GET、POST、PUT、DELETE</li>\n</ul>\n</li>\n<li>TCP RPC调用<ul>\n<li>Thrift协议</li>\n<li>Dubbox</li>\n<li>Grpc</li>\n</ul>\n</li>\n<li>消息传递<ul>\n<li>json</li>\n<li>thrift</li>\n<li>protobuf</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"另外一个角度的微服务-程序架构\"><a href=\"#另外一个角度的微服务-程序架构\" class=\"headerlink\" title=\"另外一个角度的微服务 [ 程序架构 ]\"></a>另外一个角度的微服务 [ 程序架构 ]</h4><p><img src=\"/2020/02/06/wei-fu-wu-jia-gou-yi/3.jpg\" alt></p>\n<p>在不同的客户端 [ web、app、pc端等 ]通过Internet访问API网关，然后API网关在访问相对应的微服务，其中每个服务都是通过接口来进行调用，而不是数据，这点非常重要。</p>\n<h4 id=\"微服务的组成\"><a href=\"#微服务的组成\" class=\"headerlink\" title=\"微服务的组成\"></a>微服务的组成</h4><p>Core部分：单体应用部分</p>\n<p>微服务部分： 每个服务都有自己的服务和数据，数据和数据之间都是完全隔离的。每个微服务的网络交互都是通过 <strong>api</strong> <strong>网关</strong>来进行传输控制，包括<strong>限流和熔断</strong>等机制。</p>\n<p>其实初期的微服务最好是每个机器单独部署服务，这样是最清爽的，但是很多时候，资源都被浪费了。所以新的Docker，K8s技术等出现就弥补了这个缺口。</p>\n<p>好啦，这次先到这啦～</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<p><img src=\"/2020/02/06/wei-fu-wu-jia-gou-yi/start.png\" alt></p>\n<h2 id=\"微服务\"><a href=\"#微服务\" class=\"headerlink\" title=\"微服务\"></a>微服务</h2><p>要理解微服务，首先要先理解不是微服务的那些。通常跟微服务相对的是单体应用，即将所有功能都打包成在一个独立单元的应用程序。从单体应用到微服务并不是一蹴而就的，这是一个逐渐演变的过程。</p>\n<h3 id=\"微服务和单体应用\"><a href=\"#微服务和单体应用\" class=\"headerlink\" title=\"微服务和单体应用\"></a>微服务和单体应用</h3><p><strong>单体应用</strong>设计是在微服务之前普遍的软件设计思路，他所有的逻辑、业务、操作、数据管理、传输等都是在一个程序提里面完成。最典型的是操作系统。操作系统作为一个非常庞杂的单体应用，它本身只是一个非常大的代码库，拥有非常强的耦合性，即使在操作系统内核业务分层的情况下，即使各个部件的功能再单一，操作系统相对微服务应用也是强耦合的。</p>\n<p><img src=\"/2020/02/06/wei-fu-wu-jia-gou-yi/4.jpg\" alt></p>\n<p>就Windows操作系统而言，Windows已经将近1000万行代码，想要一个人去把整个系统每行读懂是不太可能的，而且对于系统的维护和开发而是相当困难，迭代速度也会变得比较慢，最难的是很多时候单体应用会牵一发而动全身。</p>\n<p><strong>微服务</strong>   为了避免单体应用非常强的耦合性，微服务应用把程序中最小的逻辑分局变成一个微服务，每个服务都像是Linux下面 ls 工具那么简单，每个服务的职责也很单一，这样维护起来也很简单。</p>\n<p>微服务架构还有一个技术外的好处，它使整个系统的分工更加明确，责任更加清晰，每个人专心负责为其他人提供更好的服务。在单体应用的时代，公共的业务功能经常没有明确的归属。最后要么各做各的，每个人都重新实现了一遍；要么是随机一个人（一般是能力比较强或者比较热心的人）做到他负责的应用里面。在后者的情况下，这个人在负责自己应用之外，还要额外负责给别人提供这些公共的功能——而这个功能本来是无人负责的，仅仅因为他能力较强/比较热心，就莫名地背锅（这种情况还被美其名曰能者多劳）。结果最后大家都不愿意提供公共的功能。长此以往，团队里的人渐渐变得各自为政，不再关心全局的架构设计。</p>\n<p>从这个角度上看，使用微服务架构同时也需要组织结构做相应的调整。所以说做微服务改造需要管理者的支持。</p>\n<p>微服务的主要优势有：</p>\n<ul>\n<li>迭代周期短，极大提升开发效率</li>\n<li>独立部署，独立开发</li>\n<li>弹性伸缩，可对应服务伸缩</li>\n<li>鼓掌隔离，互不影响</li>\n</ul>\n<p>但是微服务也不是处处是优点，他的缺点只要在：</p>\n<ul>\n<li>设计架构的复杂度增加，一个请求往往会经过很多个服务，请求链路比较长</li>\n<li>监控和定位问题困难</li>\n<li>服务管理比较复杂</li>\n</ul>\n<h2 id=\"微服务架构\"><a href=\"#微服务架构\" class=\"headerlink\" title=\"微服务架构\"></a>微服务架构</h2><p>微服务落地需要相关的关键服务因素的支持：</p>\n<h3 id=\"配套设施\"><a href=\"#配套设施\" class=\"headerlink\" title=\"配套设施\"></a><strong>配套设施</strong></h3><p>​    对于微服务应用必须有必要的配套设施落地才能支持微服务应用</p>\n<ul>\n<li>微服务框架研发与维护</li>\n<li>打包，版本管理，上线平台支持</li>\n<li>硬件层支持，容器和容器调度</li>\n<li>服务治理平台支持，比如分笔试链路追踪和监控</li>\n<li>测试自动化支持，比如上线前自动化case</li>\n</ul>\n<h3 id=\"组织架构\"><a href=\"#组织架构\" class=\"headerlink\" title=\"组织架构\"></a><strong>组织架构</strong></h3><p>​    相对单体应用的架构，微服务的组织如下</p>\n<ul>\n<li>微服务框架研发团队</li>\n<li>私有云研发团队</li>\n<li>测试平台研发团队</li>\n</ul>\n<h3 id=\"微服务生态\"><a href=\"#微服务生态\" class=\"headerlink\" title=\"微服务生态\"></a>微服务生态</h3><p><img src=\"/2020/02/06/wei-fu-wu-jia-gou-yi/1.png\" alt></p>\n<p>微服务生态主要的分层包括：<strong>硬件层，通信层，应用平台层，微服务层</strong>。</p>\n<h4 id=\"硬件层\"><a href=\"#硬件层\" class=\"headerlink\" title=\"硬件层\"></a>硬件层</h4><p>硬件层只要负责 <strong>物理服务器的管理、操作系统管理、配置管理、资源隔离和抽象、主机监控和日志</strong>等。</p>\n<p>架构：</p>\n<p><img src=\"/2020/02/06/wei-fu-wu-jia-gou-yi/2.png\" alt></p>\n<ul>\n<li>在基础设施层里面我们会选择<strong>EC2、虚拟机、云服务器等机器资源作为基础设施</strong></li>\n<li>上面<strong>使用ubuntu、redhat、centerOS、coreOS等操作系统作为资源调度管理</strong></li>\n<li>但是<strong>不同的机器和操作系统</strong>我需要用到<strong>Docker做容器虚拟化</strong>调度，让上层的<strong>软件系统调用无平台差异</strong></li>\n<li>但是容器间的通信映射等通过<strong>kubernetes</strong>进行管理和分配</li>\n<li>最上层是<strong>图形化的弹性分配</strong>，可以<strong>分配微服务资源</strong></li>\n</ul>\n<h4 id=\"通信层\"><a href=\"#通信层\" class=\"headerlink\" title=\"通信层\"></a>通信层</h4><p>通信层是对服务之间的的交流做支持，包括各种服务的注册、发现、消息传递等。</p>\n<ul>\n<li>网络传输</li>\n<li>RPC (包括 RPC Clinet 和 RPC Server)</li>\n<li>服务发现</li>\n<li>服务注册</li>\n<li>负载均衡</li>\n<li>消息传递</li>\n</ul>\n<h4 id=\"网络传输层\"><a href=\"#网络传输层\" class=\"headerlink\" title=\"网络传输层\"></a>网络传输层</h4><p>网络传输层是用对应的协议支持，来保证传输。</p>\n<ul>\n<li>HTTP+RESTFUL<ul>\n<li>GET、POST、PUT、DELETE</li>\n</ul>\n</li>\n<li>TCP RPC调用<ul>\n<li>Thrift协议</li>\n<li>Dubbox</li>\n<li>Grpc</li>\n</ul>\n</li>\n<li>消息传递<ul>\n<li>json</li>\n<li>thrift</li>\n<li>protobuf</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"另外一个角度的微服务-程序架构\"><a href=\"#另外一个角度的微服务-程序架构\" class=\"headerlink\" title=\"另外一个角度的微服务 [ 程序架构 ]\"></a>另外一个角度的微服务 [ 程序架构 ]</h4><p><img src=\"/2020/02/06/wei-fu-wu-jia-gou-yi/3.jpg\" alt></p>\n<p>在不同的客户端 [ web、app、pc端等 ]通过Internet访问API网关，然后API网关在访问相对应的微服务，其中每个服务都是通过接口来进行调用，而不是数据，这点非常重要。</p>\n<h4 id=\"微服务的组成\"><a href=\"#微服务的组成\" class=\"headerlink\" title=\"微服务的组成\"></a>微服务的组成</h4><p>Core部分：单体应用部分</p>\n<p>微服务部分： 每个服务都有自己的服务和数据，数据和数据之间都是完全隔离的。每个微服务的网络交互都是通过 <strong>api</strong> <strong>网关</strong>来进行传输控制，包括<strong>限流和熔断</strong>等机制。</p>\n<p>其实初期的微服务最好是每个机器单独部署服务，这样是最清爽的，但是很多时候，资源都被浪费了。所以新的Docker，K8s技术等出现就弥补了这个缺口。</p>\n<p>好啦，这次先到这啦～</p>\n"},{"title":"微服务架构[三] Raft协议","date":"2020-02-10T03:08:33.000Z","_content":"\n## 微服务架构 之 Raft协议\n\n### 使用场景\n\n- ​\t解决分布式系统一致性的问题\n- ​    基于复制的方式\n\n### 工作机制\n\n- Leader选举\n- 日志复制\n- 安全性\n\n### 角色\n\n- Follower 角色\n- Leader 角色\n- Candicate 角色\n\n### 任期( Term ) 概念\n\n在raft协议中，将时间分为一个个 term（任期），每一个任期内都可正常操作。但是如果主节点挂掉则必须通过选举才可以进行Leader节点的选择。\n\n![](/5.png)\n\n![](/6.png)\n\n- Raft 把时间分割成任意长度的任期（term），如图 5 所示。任期用连续的整数标记。\n- 每一段任期从一次选举开始，一个或者多个 candidate 尝试成为 leader 。如果一个 candidate 赢得选举，然后他就在该任期剩下的时间里充当 leader 。在某些情况下，一次选举无法选出 leader 。在这种情况下，这一任期会以没有 leader 结束；一个新的任期（包含一次新的选举）会很快重新开始。\n- Raft 保证了在任意一个任期内，最多只有一个 leader\n\n个人理解：\n\n- 在raft算法中，比较谁的数据最新有2个参考指标，任期和logIndex，任期大的节点，数据一定最新，任期一样的话，就要比较该任期内谁的MaxLogIndex最大了。引入任期的概念可以简化数据比较的精度。\n\n### 任期的作用\n\n- 不同的服务器节点观察到的任期转换的次数可能不同，在某些情况下，一个服务器节点可能没有看到 leader 选举过程或者甚至整个任期全程。\n- 任期在 Raft 算法中充当逻辑时钟的作用，这使得服务器节点可以发现一些过期的信息比如过时的 leader 。\n- 每一个服务器节点存储一个当前任期号，该编号随着时间单调递增。\n- 服务器之间通信的时候会交换当前任期号；\n- 如果一个服务器的当前任期号比其他的小，该服务器会将自己的任期号更新为较大的那个值。\n- 如果一个 candidate 或者 leader 发现自己的任期号过期了，它会立即回到 follower 状态。（所以说老leader如果发生了网络分区，后来接收到新leader的心跳的时候，比拼完任期之后，会自动变成follower。\n- 如果一个节点接收到一个包含过期的任期号的请求，它会直接拒绝这个请求\n\n### 状态机复制\n\n其实很简单，通过每个节点执行一样的命令序列，则最终会得到相同的状态，Raft就是通过状态机的方式来达到一致性的效果。\n\n### 心跳和超时机制\n\nraft使用两个timeout机制来控制leader的选举，当选举完成后，leader会向所有的从节点发心跳包确认存活，再Leader挂掉的时候，操作是不可用的。\n\nRaft的Heartbeat是leader在选举成功后巩固自己地位和同步信息的一种方式，日志的复制大多数情况下适合Heartbeat是同步进行的。当一个raft节点选举成为leader后，该节点周期性执行的tick函数指向了raft.tickHeartbeat，对于leader而言主要是通知follower自己还活着，与此同时leader在收到follower对Heartbeat的响应之后，又会向日志比较落后的follower发送追加日志请求，进行log replication。\n\n```go\nfunc (r *raft) tickHeartbeat() {\n    r.heartbeatElapsed++\n    // ... \n\n    // 如果心跳计时超过了心跳包的发送间隔，就进入发送心跳包流程，并重置心跳计时\n    if r.heartbeatElapsed >= r.heartbeatTimeout {\n        r.heartbeatElapsed = 0 \n        r.Step(pb.Message{From: r.id, Type: pb.MsgBeat})\n    }   \n}\n\nfunc (r *raft) Step(m pb.Message) error {\n    // ...\n\n    // Step最终调用raft.step变量指向的函数\n    // 现阶段当前节点处于leader状态，所以step指向stepLeader \n    r.step(r, m)\n    return nil \n}\n```\n\nstepLeader中心跳发送代码相关执行流程如下：\n\n```go\nfunc stepLeader(r *raft, m pb.Message) {\n    switch m.Type {\n    case pb.MsgBeat：\n        // 把心跳包广播出去\n        r.bcastHeartbeat()\n    return\n    // ...\n}\n\n// 在bcastHeartbeat中循环的把心跳包发送出去\nfunc (r *raft) bcastHeartbeat() {\n    for id := range r.prs {\n        if id == r.id {\n            continue\n        }\n        r.sendHeartbeat(id)\n        r.prs[id].resume()\n    }\n}\nfunc (r *raft) sendHeartbeat(to uint64) {\n    // r.raftLog.committed 已经拷贝到大多数节点上的日志index\n    // r.prs[to].Match拷贝到to这个节点的日志最大下标\n    commit := min(r.prs[to].Match, r.raftLog.committed)\n    m := pb.Message{\n        To:     to,\n        Type:   pb.MsgHeartbeat,\n        Commit: commit,\n    }\n    //把心跳包发送出去\n    r.send(m)\n}\n```\n\nfollower在收到心跳包之后，最终处理心跳的包的流程会通过Step->step->stepFollower:\n\n```go\nfunc stepFollower(r *raft, m pb.Message) {\n    switch m.Type {\n    case pb.MsgHeartbeat:\n        r.electionElapsed = 0\n        r.lead = m.From\n        r.handleHeartbeat(m)\n    case //...\n    }\n}\n\n// 更新本地可以提交的日志的最大下标，然后返回响应\nfunc (r *raft) handleHeartbeat(m pb.Message) {\n    r.raftLog.commitTo(m.Commit)\n    r.send(pb.Message{To: m.From, Type: pb.MsgHeartbeatResp})\n}\n\n```\n\nleader的心跳响应收到之后处理流程依旧会通过Step->step->stepLeader:\n\n```go\nfunc stepLeader(r *raft, m pb.Message) {\n    switch m.Type {\n        // ...\n    case pb.MsgHeartbeatResp:\n        pr.RecentActive = true\n\n        // free one slot for the full inflights window to allow progress.\n        if pr.State == ProgressStateReplicate && pr.ins.full() {\n            pr.ins.freeFirstOne()\n        }\n        // 检查是否还有日志没有拷贝到当前follower，如果有待发送的日志，通过sendAppend发送过去。\n        if pr.Match < r.raftLog.lastIndex() {\n            r.sendAppend(m.From)\n        }\n        case //...\n    }\n}\n```\n\nsendAppend函数的实现如下：\n\n```go\nfunc (r *raft) sendAppend(to uint64) {\n    pr := r.prs[to]\n    if pr.isPaused() {\n        return\n    }\n    m := pb.Message{}\n    m.To = to\n    // 给该follower发送的最后一条日志的term\n    term, errt := r.raftLog.term(pr.Next - 1)\n    // 即将要发送给该follower的日志条目\n    ents, erre := r.raftLog.entries(pr.Next, r.maxMsgSize)\n\n    // 如果待发送给follower已经写到snap里面，在raftlog里面无法找到\n    if errt != nil || erre != nil { // send snapshot if we failed to get term or entries\n        if !pr.RecentActive {\n            r.logger.Debugf(\"ignore sending snapshot to %x since it is not recently active\", to)\n            return\n        }\n\n        m.Type = pb.MsgSnap\n        snapshot, err := r.raftLog.snapshot()\n        if err != nil {\n            if err == ErrSnapshotTemporarilyUnavailable {\n                r.logger.Debugf(\"%x failed to send snapshot to %x because snapshot is temporarily unavailable\", r.id, to)\n                return\n            }\n            panic(err) // TODO(bdarnell)\n        }\n        if IsEmptySnap(snapshot) {\n            panic(\"need non-empty snapshot\")\n        }\n        m.Snapshot = snapshot\n        sindex, sterm := snapshot.Metadata.Index, snapshot.Metadata.Term\n        r.logger.Debugf(\"%x [firstindex: %d, commit: %d] sent snapshot[index: %d, term: %d] to %x [%s]\",\n            r.id, r.raftLog.firstIndex(), r.raftLog.committed, sindex, sterm, to, pr)\n        pr.becomeSnapshot(sindex)\n        r.logger.Debugf(\"%x paused sending replication messages to %x [%s]\", r.id, to, pr)\n    } else {\n        m.Type = pb.MsgApp\n        m.Index = pr.Next - 1\n        m.LogTerm = term\n        m.Entries = ents\n        // leader记录的最大的已经copy到大多数节点上的日志下标\n        m.Commit = r.raftLog.committed\n        if n := len(m.Entries); n != 0 {\n            switch pr.State {\n            // optimistically increase the next when in ProgressStateReplicate\n            case ProgressStateReplicate:\n                last := m.Entries[n-1].Index\n                pr.optimisticUpdate(last)\n                pr.ins.add(last)\n            case ProgressStateProbe:\n                pr.pause()\n            default:\n                r.logger.Panicf(\"%x is sending append in unhandled state %s\", r.id, pr.State)\n            }\n        }\n    }\n    r.send(m)\n}\n```\n\nfollower在收到leader发送过来的追加日志请求时，会通过handleAppendEntries去处理消息：\n\n```go\nfunc (r *raft) handleAppendEntries(m pb.Message) {\n    // r.raftLog.committed实在当前节点已经提交的日志\n    // m.Index为leader发送给该follower的上一条日志索引\n    // m.Index < r.raftLog.committed情况多出现在刚刚选出的leader向follower拷贝日志，leader本地还未记录向该follower拷贝了多少日志\n    // 出现这种请求leader会把自己已经提交的日志的最大下标发送给leader，下次leader就会从r.raftLog.committed + 1开始发送日志\n    if m.Index < r.raftLog.committed {\n        r.send(pb.Message{To: m.From, Type: pb.MsgAppResp, Index: r.raftLog.committed})\n        return\n    }\n    // leader拷贝日志有可能在follower已经存在，所以要先找到相对与follower日志比较新的日志下标\n    if mlastIndex, ok := r.raftLog.maybeAppend(m.Index, m.LogTerm, m.Commit, m.Entries...); ok {\n        // 当leader发送过来的上次发送给该follower的最后一条日志信息与follower本地储存的无冲突时，\n        // 返回follower本地已经写入的最大日志下标，下次leader就会从该下标发送日志，并会更新leader记录的该follower的日志发送信息\n        r.send(pb.Message{To: m.From, Type: pb.MsgAppResp, Index: mlastIndex})\n    } else {\n        // 最后leader发送过来的最后一条日志的index，term等信息与follower本地记录的不一样\n        r.send(pb.Message{To: m.From, Type: pb.MsgAppResp, Index: m.Index, Reject: true, RejectHint: r.raftLog.lastIndex()})\n    }\n}\n\nfunc (l *raftLog) maybeAppend(index, logTerm, committed uint64, ents ...pb.Entry) (lastnewi uint64, ok bool) {\n    lastnewi = index + uint64(len(ents))\n    if l.matchTerm(index, logTerm) {\n        // 找到leader发送给follower的第一条新日志的位置\n        ci := l.findConflict(ents)\n        switch {\n        // 说明leader拷贝过来的日志都在follower的raftlog里面有记录\n        case ci == 0:\n        // 日志冲突的下标小于follower本地已经提交的日志，出现bug了\n        case ci <= l.committed:\n            l.logger.Panicf(\"entry %d conflict with committed entry [committed(%d)]\", ci, l.committed)\n        default:\n           // 把leader拷贝过来的新日志写入follower本地\n            offset := index + 1 \n            l.append(ents[ci-offset:]...)\n        }\n        l.commitTo(min(committed, lastnewi))\n        // 返回follower本地最新的日志记录index\n        return lastnewi, true\n    }   \n    return 0, false\n}\n```\n\nleader收到的follower对日志追加请求的响应主要有两种：follower拒绝追加日志，follower追加0-n条日志，相关响应的处理代码如下:\n\n```go\nfunc stepLeader(r *raft, m pb.Message) {\n    // ...\n    switch m.Type {\n    case pb.MsgAppResp:\n        pr.RecentActive = true\n\n        if m.Reject {\n            // 拒绝追加日志\n            // follower拒绝追加日志时都会返回一个RejectHint，RejectHint表示当前follower最后一条日志的index\n            // maybeDecrTo函数在follower为ProgressStateReplicate状态是会把pr[to].Next设置为pr[to].Match + 1，否者会设置为被设置为m.Index、m.RejectHint中较小的一个，然后继续尝试发送。\n            if pr.maybeDecrTo(m.Index, m.RejectHint) {\n                if pr.State == ProgressStateReplicate {\n                    pr.becomeProbe()\n                }\n                r.sendAppend(m.From)\n            }\n        } else {\n            oldPaused := pr.isPaused()\n            // 如果又在follower上追加日志，更新以下两个下标:\n            // （1）follower已经和leader一致的最大日志下标:pr[to].Match = m.Index\n            // （2）下一条需要拷贝给该follower的日志下标:pr[to].Next = m.Index + 1\n            if pr.maybeUpdate(m.Index) {\n                switch {\n                case pr.State == ProgressStateProbe:\n                    pr.becomeReplicate()\n                case pr.State == ProgressStateSnapshot && pr.maybeSnapshotAbort():\n                    pr.becomeProbe()\n                case pr.State == ProgressStateReplicate:\n                    pr.ins.freeTo(m.Index)\n                }\n                // 如果该follower有追加成功的日志，可能会出现新的日志条目拷贝到大多数raft节点上，\n                // 因此leader更新本地raftlog.commitid，然后通过bcastAppend把新更新的commit(如果follower日志落后于leader，可能携带日志)广播给follower，\n                // follower更新本地已经提交到大多数机器上的日志下标，本地小于commit未apply的日志就可以apply了\n                if r.maybeCommit() {\n                    r.bcastAppend()\n                } else if oldPaused {\n                    // update() reset the wait state on this node. If we had delayed sending\n                    // an update before, send it now.\n                    r.sendAppend(m.From)\n                }\n            }\n        }\n    case // ...\n}\n```\n\n### Leader选举\n\n#### 触发条件\n\n- 一般条件下，追随者接到领导者的心跳的时候，把选举定时器清零，不会触发\n- 最随着的选举定时器超时发生时（比如Leader故障了），那从节点会变成候选者，触发领导人选举\n\n#### 选举过程\n\n- 一开始，所有节点都是以Follow角色启动，同时启动选举定时器（时间随机，降低冲突概率）\n- 当定时器到期的时候，转为候选人角色【candicate】\n- 把当前任期+1并且为自己投票\n- 发起RequestVote的RPC请求，要求其他节点为自己投票\n- 如果得到办事以上的节点同意，自己称为Leader\n- 如果选举超时，还没有Leader产生，则进入下一任期，重新选举\n\n#### 限制条件\n\n假定这样一个情况，1号节点作为Leader在同步完成3号以后，在对2号同步数据的时候挂掉了，那如果2号 [未携带合法数据] 参与选举则会引起错误。所以必须规避这些问题。\n\n![](/7.png)\n\n- 每个接待你在**一个任期里面只能投一个票**，采用先到先服务的原则\n- 如果没有投过票，对比候选人节点的Log和当前节点的Log哪个更新，比较方式为**谁的lastLog的term越大谁越新**，如果term相同，**谁的lastLog的index谁越大谁越新**，如果当前节点更新，则拒绝投票。\n\n### 日志复制\n\nRaft状态机图示\n\n![](/9.png)\n\n Leader将命令并发的复制给其他节点，并等待其他节点将命令写入到日志中，如果此时有些节点失败或者比较慢，Leader节点会一直重试，所有的节点都保存到日志中，之后Leader节点就提交命令， 在接下来的心跳包所有的从节点都会提交对应的修改，并将节点返回给客户端。\n\n![](/8.png)\n\n当客户端向服务器发送修改x的请求时，主节点接收到，并且修改掉自己的日志，但并未提交 ( comit )。\n\n![](/10.png)\n\n此时Leader会告诉所有的节点修改日志，但是都未提交。\n\n![](/11.png)\n\n从节点收到以后，回复Leader收到。\n\n![](/12.png)\n\nLeader节点Comit，然后通过心跳包所有的从节点提交。\n\n![](/13.png)\n\n### 安全性\n\n一个作为候选人的节点要赢得选举，就需要喝网络中大部分节点进行通信，这就意味着已经提交的乳汁条目最少在其中一台服务器节点上出现，如果候选人的日志至少和大多数的服务器上的日志一样新，那么他一定包含全部已经提交的日志条目。\n\nRequestVote RPC 实现了这个限制： RPC包括勾选人的日志信息，如果它自己的日志比候选人的日志要新，他会拒绝给候选人投票。\n\n### 最新判断标准\n\n- 如果两个日志的任期号不同，任期号打的日志内容更新\n- 如果任期号一样大，则更具日志中最后一个命令的索引(Index)，谁大谁最新\n\n### 数据安全性\n\n在我们保证了选举时候选出的Leader必须是携带者最新的日志的同时，也需要保证数据的最新性。如下：\n\n![](/15.png)\n\n当我们的节点存在于多个路由器或者交换机下时，比如 D、E、F、节点处在交换机子网2中间，其中D为Leader节点。A、B、C是处于子网1中间。正常通信的时候通过分布式一致性协议下不会有任何问题。\n\n但是当出现网络问题的时候，比如两个交换机之间出现网络分区的时候【老列】，我们仔细想一下这个问题。\n\n- 正常通信的时候，分布式一致性协议会保证每个节点的数据一致\n\n- 当网络分区出现时，A、B、C节点给D节点发送收不到回应，则会认为Leader D挂了\n\n- 在A、B、C中间会进行Leader选举，假定A变成了Leader\n\n- 与此同时，客户端发送数据修改请求，因为旧的Leader D节点收不到来自A、B、C、的修改确认回应，他会一直重复发心跳包而停止提交修改。\n- A节点作为新的Leader接受了客户端的请求并且同步到了B、C节点。\n\n当某一时刻，网络情况恢复了以后 :\n\n- 新的Leader节点 A  携带的数据最新，D节点会发送心跳包给其他节点，D节点由于Term和数据携带不够新而被舍弃\n- A发送心跳包同步到其他节点，当然也包括D节点，D节点发现A的数据包更新，于是丢弃Leader职位成为Follower。于是A节点成为Leader，一切正常\n\n![](/16.png)\n\n最后，推荐 [Raft](http://thesecretlivesofdata.com/raft/) 动画演示。可以很清楚了解raft协议的一些过程。\n\n","source":"_posts/微服务架构-三-Raft协议.md","raw":"---\ntitle: '微服务架构[三] Raft协议'\ndate: 2020-02-10 11:08:33\ntags: [Go,微服务,Micro Service]\ncategories: Go栈\n---\n\n## 微服务架构 之 Raft协议\n\n### 使用场景\n\n- ​\t解决分布式系统一致性的问题\n- ​    基于复制的方式\n\n### 工作机制\n\n- Leader选举\n- 日志复制\n- 安全性\n\n### 角色\n\n- Follower 角色\n- Leader 角色\n- Candicate 角色\n\n### 任期( Term ) 概念\n\n在raft协议中，将时间分为一个个 term（任期），每一个任期内都可正常操作。但是如果主节点挂掉则必须通过选举才可以进行Leader节点的选择。\n\n![](/5.png)\n\n![](/6.png)\n\n- Raft 把时间分割成任意长度的任期（term），如图 5 所示。任期用连续的整数标记。\n- 每一段任期从一次选举开始，一个或者多个 candidate 尝试成为 leader 。如果一个 candidate 赢得选举，然后他就在该任期剩下的时间里充当 leader 。在某些情况下，一次选举无法选出 leader 。在这种情况下，这一任期会以没有 leader 结束；一个新的任期（包含一次新的选举）会很快重新开始。\n- Raft 保证了在任意一个任期内，最多只有一个 leader\n\n个人理解：\n\n- 在raft算法中，比较谁的数据最新有2个参考指标，任期和logIndex，任期大的节点，数据一定最新，任期一样的话，就要比较该任期内谁的MaxLogIndex最大了。引入任期的概念可以简化数据比较的精度。\n\n### 任期的作用\n\n- 不同的服务器节点观察到的任期转换的次数可能不同，在某些情况下，一个服务器节点可能没有看到 leader 选举过程或者甚至整个任期全程。\n- 任期在 Raft 算法中充当逻辑时钟的作用，这使得服务器节点可以发现一些过期的信息比如过时的 leader 。\n- 每一个服务器节点存储一个当前任期号，该编号随着时间单调递增。\n- 服务器之间通信的时候会交换当前任期号；\n- 如果一个服务器的当前任期号比其他的小，该服务器会将自己的任期号更新为较大的那个值。\n- 如果一个 candidate 或者 leader 发现自己的任期号过期了，它会立即回到 follower 状态。（所以说老leader如果发生了网络分区，后来接收到新leader的心跳的时候，比拼完任期之后，会自动变成follower。\n- 如果一个节点接收到一个包含过期的任期号的请求，它会直接拒绝这个请求\n\n### 状态机复制\n\n其实很简单，通过每个节点执行一样的命令序列，则最终会得到相同的状态，Raft就是通过状态机的方式来达到一致性的效果。\n\n### 心跳和超时机制\n\nraft使用两个timeout机制来控制leader的选举，当选举完成后，leader会向所有的从节点发心跳包确认存活，再Leader挂掉的时候，操作是不可用的。\n\nRaft的Heartbeat是leader在选举成功后巩固自己地位和同步信息的一种方式，日志的复制大多数情况下适合Heartbeat是同步进行的。当一个raft节点选举成为leader后，该节点周期性执行的tick函数指向了raft.tickHeartbeat，对于leader而言主要是通知follower自己还活着，与此同时leader在收到follower对Heartbeat的响应之后，又会向日志比较落后的follower发送追加日志请求，进行log replication。\n\n```go\nfunc (r *raft) tickHeartbeat() {\n    r.heartbeatElapsed++\n    // ... \n\n    // 如果心跳计时超过了心跳包的发送间隔，就进入发送心跳包流程，并重置心跳计时\n    if r.heartbeatElapsed >= r.heartbeatTimeout {\n        r.heartbeatElapsed = 0 \n        r.Step(pb.Message{From: r.id, Type: pb.MsgBeat})\n    }   \n}\n\nfunc (r *raft) Step(m pb.Message) error {\n    // ...\n\n    // Step最终调用raft.step变量指向的函数\n    // 现阶段当前节点处于leader状态，所以step指向stepLeader \n    r.step(r, m)\n    return nil \n}\n```\n\nstepLeader中心跳发送代码相关执行流程如下：\n\n```go\nfunc stepLeader(r *raft, m pb.Message) {\n    switch m.Type {\n    case pb.MsgBeat：\n        // 把心跳包广播出去\n        r.bcastHeartbeat()\n    return\n    // ...\n}\n\n// 在bcastHeartbeat中循环的把心跳包发送出去\nfunc (r *raft) bcastHeartbeat() {\n    for id := range r.prs {\n        if id == r.id {\n            continue\n        }\n        r.sendHeartbeat(id)\n        r.prs[id].resume()\n    }\n}\nfunc (r *raft) sendHeartbeat(to uint64) {\n    // r.raftLog.committed 已经拷贝到大多数节点上的日志index\n    // r.prs[to].Match拷贝到to这个节点的日志最大下标\n    commit := min(r.prs[to].Match, r.raftLog.committed)\n    m := pb.Message{\n        To:     to,\n        Type:   pb.MsgHeartbeat,\n        Commit: commit,\n    }\n    //把心跳包发送出去\n    r.send(m)\n}\n```\n\nfollower在收到心跳包之后，最终处理心跳的包的流程会通过Step->step->stepFollower:\n\n```go\nfunc stepFollower(r *raft, m pb.Message) {\n    switch m.Type {\n    case pb.MsgHeartbeat:\n        r.electionElapsed = 0\n        r.lead = m.From\n        r.handleHeartbeat(m)\n    case //...\n    }\n}\n\n// 更新本地可以提交的日志的最大下标，然后返回响应\nfunc (r *raft) handleHeartbeat(m pb.Message) {\n    r.raftLog.commitTo(m.Commit)\n    r.send(pb.Message{To: m.From, Type: pb.MsgHeartbeatResp})\n}\n\n```\n\nleader的心跳响应收到之后处理流程依旧会通过Step->step->stepLeader:\n\n```go\nfunc stepLeader(r *raft, m pb.Message) {\n    switch m.Type {\n        // ...\n    case pb.MsgHeartbeatResp:\n        pr.RecentActive = true\n\n        // free one slot for the full inflights window to allow progress.\n        if pr.State == ProgressStateReplicate && pr.ins.full() {\n            pr.ins.freeFirstOne()\n        }\n        // 检查是否还有日志没有拷贝到当前follower，如果有待发送的日志，通过sendAppend发送过去。\n        if pr.Match < r.raftLog.lastIndex() {\n            r.sendAppend(m.From)\n        }\n        case //...\n    }\n}\n```\n\nsendAppend函数的实现如下：\n\n```go\nfunc (r *raft) sendAppend(to uint64) {\n    pr := r.prs[to]\n    if pr.isPaused() {\n        return\n    }\n    m := pb.Message{}\n    m.To = to\n    // 给该follower发送的最后一条日志的term\n    term, errt := r.raftLog.term(pr.Next - 1)\n    // 即将要发送给该follower的日志条目\n    ents, erre := r.raftLog.entries(pr.Next, r.maxMsgSize)\n\n    // 如果待发送给follower已经写到snap里面，在raftlog里面无法找到\n    if errt != nil || erre != nil { // send snapshot if we failed to get term or entries\n        if !pr.RecentActive {\n            r.logger.Debugf(\"ignore sending snapshot to %x since it is not recently active\", to)\n            return\n        }\n\n        m.Type = pb.MsgSnap\n        snapshot, err := r.raftLog.snapshot()\n        if err != nil {\n            if err == ErrSnapshotTemporarilyUnavailable {\n                r.logger.Debugf(\"%x failed to send snapshot to %x because snapshot is temporarily unavailable\", r.id, to)\n                return\n            }\n            panic(err) // TODO(bdarnell)\n        }\n        if IsEmptySnap(snapshot) {\n            panic(\"need non-empty snapshot\")\n        }\n        m.Snapshot = snapshot\n        sindex, sterm := snapshot.Metadata.Index, snapshot.Metadata.Term\n        r.logger.Debugf(\"%x [firstindex: %d, commit: %d] sent snapshot[index: %d, term: %d] to %x [%s]\",\n            r.id, r.raftLog.firstIndex(), r.raftLog.committed, sindex, sterm, to, pr)\n        pr.becomeSnapshot(sindex)\n        r.logger.Debugf(\"%x paused sending replication messages to %x [%s]\", r.id, to, pr)\n    } else {\n        m.Type = pb.MsgApp\n        m.Index = pr.Next - 1\n        m.LogTerm = term\n        m.Entries = ents\n        // leader记录的最大的已经copy到大多数节点上的日志下标\n        m.Commit = r.raftLog.committed\n        if n := len(m.Entries); n != 0 {\n            switch pr.State {\n            // optimistically increase the next when in ProgressStateReplicate\n            case ProgressStateReplicate:\n                last := m.Entries[n-1].Index\n                pr.optimisticUpdate(last)\n                pr.ins.add(last)\n            case ProgressStateProbe:\n                pr.pause()\n            default:\n                r.logger.Panicf(\"%x is sending append in unhandled state %s\", r.id, pr.State)\n            }\n        }\n    }\n    r.send(m)\n}\n```\n\nfollower在收到leader发送过来的追加日志请求时，会通过handleAppendEntries去处理消息：\n\n```go\nfunc (r *raft) handleAppendEntries(m pb.Message) {\n    // r.raftLog.committed实在当前节点已经提交的日志\n    // m.Index为leader发送给该follower的上一条日志索引\n    // m.Index < r.raftLog.committed情况多出现在刚刚选出的leader向follower拷贝日志，leader本地还未记录向该follower拷贝了多少日志\n    // 出现这种请求leader会把自己已经提交的日志的最大下标发送给leader，下次leader就会从r.raftLog.committed + 1开始发送日志\n    if m.Index < r.raftLog.committed {\n        r.send(pb.Message{To: m.From, Type: pb.MsgAppResp, Index: r.raftLog.committed})\n        return\n    }\n    // leader拷贝日志有可能在follower已经存在，所以要先找到相对与follower日志比较新的日志下标\n    if mlastIndex, ok := r.raftLog.maybeAppend(m.Index, m.LogTerm, m.Commit, m.Entries...); ok {\n        // 当leader发送过来的上次发送给该follower的最后一条日志信息与follower本地储存的无冲突时，\n        // 返回follower本地已经写入的最大日志下标，下次leader就会从该下标发送日志，并会更新leader记录的该follower的日志发送信息\n        r.send(pb.Message{To: m.From, Type: pb.MsgAppResp, Index: mlastIndex})\n    } else {\n        // 最后leader发送过来的最后一条日志的index，term等信息与follower本地记录的不一样\n        r.send(pb.Message{To: m.From, Type: pb.MsgAppResp, Index: m.Index, Reject: true, RejectHint: r.raftLog.lastIndex()})\n    }\n}\n\nfunc (l *raftLog) maybeAppend(index, logTerm, committed uint64, ents ...pb.Entry) (lastnewi uint64, ok bool) {\n    lastnewi = index + uint64(len(ents))\n    if l.matchTerm(index, logTerm) {\n        // 找到leader发送给follower的第一条新日志的位置\n        ci := l.findConflict(ents)\n        switch {\n        // 说明leader拷贝过来的日志都在follower的raftlog里面有记录\n        case ci == 0:\n        // 日志冲突的下标小于follower本地已经提交的日志，出现bug了\n        case ci <= l.committed:\n            l.logger.Panicf(\"entry %d conflict with committed entry [committed(%d)]\", ci, l.committed)\n        default:\n           // 把leader拷贝过来的新日志写入follower本地\n            offset := index + 1 \n            l.append(ents[ci-offset:]...)\n        }\n        l.commitTo(min(committed, lastnewi))\n        // 返回follower本地最新的日志记录index\n        return lastnewi, true\n    }   \n    return 0, false\n}\n```\n\nleader收到的follower对日志追加请求的响应主要有两种：follower拒绝追加日志，follower追加0-n条日志，相关响应的处理代码如下:\n\n```go\nfunc stepLeader(r *raft, m pb.Message) {\n    // ...\n    switch m.Type {\n    case pb.MsgAppResp:\n        pr.RecentActive = true\n\n        if m.Reject {\n            // 拒绝追加日志\n            // follower拒绝追加日志时都会返回一个RejectHint，RejectHint表示当前follower最后一条日志的index\n            // maybeDecrTo函数在follower为ProgressStateReplicate状态是会把pr[to].Next设置为pr[to].Match + 1，否者会设置为被设置为m.Index、m.RejectHint中较小的一个，然后继续尝试发送。\n            if pr.maybeDecrTo(m.Index, m.RejectHint) {\n                if pr.State == ProgressStateReplicate {\n                    pr.becomeProbe()\n                }\n                r.sendAppend(m.From)\n            }\n        } else {\n            oldPaused := pr.isPaused()\n            // 如果又在follower上追加日志，更新以下两个下标:\n            // （1）follower已经和leader一致的最大日志下标:pr[to].Match = m.Index\n            // （2）下一条需要拷贝给该follower的日志下标:pr[to].Next = m.Index + 1\n            if pr.maybeUpdate(m.Index) {\n                switch {\n                case pr.State == ProgressStateProbe:\n                    pr.becomeReplicate()\n                case pr.State == ProgressStateSnapshot && pr.maybeSnapshotAbort():\n                    pr.becomeProbe()\n                case pr.State == ProgressStateReplicate:\n                    pr.ins.freeTo(m.Index)\n                }\n                // 如果该follower有追加成功的日志，可能会出现新的日志条目拷贝到大多数raft节点上，\n                // 因此leader更新本地raftlog.commitid，然后通过bcastAppend把新更新的commit(如果follower日志落后于leader，可能携带日志)广播给follower，\n                // follower更新本地已经提交到大多数机器上的日志下标，本地小于commit未apply的日志就可以apply了\n                if r.maybeCommit() {\n                    r.bcastAppend()\n                } else if oldPaused {\n                    // update() reset the wait state on this node. If we had delayed sending\n                    // an update before, send it now.\n                    r.sendAppend(m.From)\n                }\n            }\n        }\n    case // ...\n}\n```\n\n### Leader选举\n\n#### 触发条件\n\n- 一般条件下，追随者接到领导者的心跳的时候，把选举定时器清零，不会触发\n- 最随着的选举定时器超时发生时（比如Leader故障了），那从节点会变成候选者，触发领导人选举\n\n#### 选举过程\n\n- 一开始，所有节点都是以Follow角色启动，同时启动选举定时器（时间随机，降低冲突概率）\n- 当定时器到期的时候，转为候选人角色【candicate】\n- 把当前任期+1并且为自己投票\n- 发起RequestVote的RPC请求，要求其他节点为自己投票\n- 如果得到办事以上的节点同意，自己称为Leader\n- 如果选举超时，还没有Leader产生，则进入下一任期，重新选举\n\n#### 限制条件\n\n假定这样一个情况，1号节点作为Leader在同步完成3号以后，在对2号同步数据的时候挂掉了，那如果2号 [未携带合法数据] 参与选举则会引起错误。所以必须规避这些问题。\n\n![](/7.png)\n\n- 每个接待你在**一个任期里面只能投一个票**，采用先到先服务的原则\n- 如果没有投过票，对比候选人节点的Log和当前节点的Log哪个更新，比较方式为**谁的lastLog的term越大谁越新**，如果term相同，**谁的lastLog的index谁越大谁越新**，如果当前节点更新，则拒绝投票。\n\n### 日志复制\n\nRaft状态机图示\n\n![](/9.png)\n\n Leader将命令并发的复制给其他节点，并等待其他节点将命令写入到日志中，如果此时有些节点失败或者比较慢，Leader节点会一直重试，所有的节点都保存到日志中，之后Leader节点就提交命令， 在接下来的心跳包所有的从节点都会提交对应的修改，并将节点返回给客户端。\n\n![](/8.png)\n\n当客户端向服务器发送修改x的请求时，主节点接收到，并且修改掉自己的日志，但并未提交 ( comit )。\n\n![](/10.png)\n\n此时Leader会告诉所有的节点修改日志，但是都未提交。\n\n![](/11.png)\n\n从节点收到以后，回复Leader收到。\n\n![](/12.png)\n\nLeader节点Comit，然后通过心跳包所有的从节点提交。\n\n![](/13.png)\n\n### 安全性\n\n一个作为候选人的节点要赢得选举，就需要喝网络中大部分节点进行通信，这就意味着已经提交的乳汁条目最少在其中一台服务器节点上出现，如果候选人的日志至少和大多数的服务器上的日志一样新，那么他一定包含全部已经提交的日志条目。\n\nRequestVote RPC 实现了这个限制： RPC包括勾选人的日志信息，如果它自己的日志比候选人的日志要新，他会拒绝给候选人投票。\n\n### 最新判断标准\n\n- 如果两个日志的任期号不同，任期号打的日志内容更新\n- 如果任期号一样大，则更具日志中最后一个命令的索引(Index)，谁大谁最新\n\n### 数据安全性\n\n在我们保证了选举时候选出的Leader必须是携带者最新的日志的同时，也需要保证数据的最新性。如下：\n\n![](/15.png)\n\n当我们的节点存在于多个路由器或者交换机下时，比如 D、E、F、节点处在交换机子网2中间，其中D为Leader节点。A、B、C是处于子网1中间。正常通信的时候通过分布式一致性协议下不会有任何问题。\n\n但是当出现网络问题的时候，比如两个交换机之间出现网络分区的时候【老列】，我们仔细想一下这个问题。\n\n- 正常通信的时候，分布式一致性协议会保证每个节点的数据一致\n\n- 当网络分区出现时，A、B、C节点给D节点发送收不到回应，则会认为Leader D挂了\n\n- 在A、B、C中间会进行Leader选举，假定A变成了Leader\n\n- 与此同时，客户端发送数据修改请求，因为旧的Leader D节点收不到来自A、B、C、的修改确认回应，他会一直重复发心跳包而停止提交修改。\n- A节点作为新的Leader接受了客户端的请求并且同步到了B、C节点。\n\n当某一时刻，网络情况恢复了以后 :\n\n- 新的Leader节点 A  携带的数据最新，D节点会发送心跳包给其他节点，D节点由于Term和数据携带不够新而被舍弃\n- A发送心跳包同步到其他节点，当然也包括D节点，D节点发现A的数据包更新，于是丢弃Leader职位成为Follower。于是A节点成为Leader，一切正常\n\n![](/16.png)\n\n最后，推荐 [Raft](http://thesecretlivesofdata.com/raft/) 动画演示。可以很清楚了解raft协议的一些过程。\n\n","slug":"微服务架构-三-Raft协议","published":1,"updated":"2020-02-10T04:21:31.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rjq001lzd5belac2xt5","content":"<h2 id=\"微服务架构-之-Raft协议\"><a href=\"#微服务架构-之-Raft协议\" class=\"headerlink\" title=\"微服务架构 之 Raft协议\"></a>微服务架构 之 Raft协议</h2><h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><ul>\n<li>​    解决分布式系统一致性的问题</li>\n<li>​    基于复制的方式</li>\n</ul>\n<h3 id=\"工作机制\"><a href=\"#工作机制\" class=\"headerlink\" title=\"工作机制\"></a>工作机制</h3><ul>\n<li>Leader选举</li>\n<li>日志复制</li>\n<li>安全性</li>\n</ul>\n<h3 id=\"角色\"><a href=\"#角色\" class=\"headerlink\" title=\"角色\"></a>角色</h3><ul>\n<li>Follower 角色</li>\n<li>Leader 角色</li>\n<li>Candicate 角色</li>\n</ul>\n<h3 id=\"任期-Term-概念\"><a href=\"#任期-Term-概念\" class=\"headerlink\" title=\"任期( Term ) 概念\"></a>任期( Term ) 概念</h3><p>在raft协议中，将时间分为一个个 term（任期），每一个任期内都可正常操作。但是如果主节点挂掉则必须通过选举才可以进行Leader节点的选择。</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/5.png\" alt></p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/6.png\" alt></p>\n<ul>\n<li>Raft 把时间分割成任意长度的任期（term），如图 5 所示。任期用连续的整数标记。</li>\n<li>每一段任期从一次选举开始，一个或者多个 candidate 尝试成为 leader 。如果一个 candidate 赢得选举，然后他就在该任期剩下的时间里充当 leader 。在某些情况下，一次选举无法选出 leader 。在这种情况下，这一任期会以没有 leader 结束；一个新的任期（包含一次新的选举）会很快重新开始。</li>\n<li>Raft 保证了在任意一个任期内，最多只有一个 leader</li>\n</ul>\n<p>个人理解：</p>\n<ul>\n<li>在raft算法中，比较谁的数据最新有2个参考指标，任期和logIndex，任期大的节点，数据一定最新，任期一样的话，就要比较该任期内谁的MaxLogIndex最大了。引入任期的概念可以简化数据比较的精度。</li>\n</ul>\n<h3 id=\"任期的作用\"><a href=\"#任期的作用\" class=\"headerlink\" title=\"任期的作用\"></a>任期的作用</h3><ul>\n<li>不同的服务器节点观察到的任期转换的次数可能不同，在某些情况下，一个服务器节点可能没有看到 leader 选举过程或者甚至整个任期全程。</li>\n<li>任期在 Raft 算法中充当逻辑时钟的作用，这使得服务器节点可以发现一些过期的信息比如过时的 leader 。</li>\n<li>每一个服务器节点存储一个当前任期号，该编号随着时间单调递增。</li>\n<li>服务器之间通信的时候会交换当前任期号；</li>\n<li>如果一个服务器的当前任期号比其他的小，该服务器会将自己的任期号更新为较大的那个值。</li>\n<li>如果一个 candidate 或者 leader 发现自己的任期号过期了，它会立即回到 follower 状态。（所以说老leader如果发生了网络分区，后来接收到新leader的心跳的时候，比拼完任期之后，会自动变成follower。</li>\n<li>如果一个节点接收到一个包含过期的任期号的请求，它会直接拒绝这个请求</li>\n</ul>\n<h3 id=\"状态机复制\"><a href=\"#状态机复制\" class=\"headerlink\" title=\"状态机复制\"></a>状态机复制</h3><p>其实很简单，通过每个节点执行一样的命令序列，则最终会得到相同的状态，Raft就是通过状态机的方式来达到一致性的效果。</p>\n<h3 id=\"心跳和超时机制\"><a href=\"#心跳和超时机制\" class=\"headerlink\" title=\"心跳和超时机制\"></a>心跳和超时机制</h3><p>raft使用两个timeout机制来控制leader的选举，当选举完成后，leader会向所有的从节点发心跳包确认存活，再Leader挂掉的时候，操作是不可用的。</p>\n<p>Raft的Heartbeat是leader在选举成功后巩固自己地位和同步信息的一种方式，日志的复制大多数情况下适合Heartbeat是同步进行的。当一个raft节点选举成为leader后，该节点周期性执行的tick函数指向了raft.tickHeartbeat，对于leader而言主要是通知follower自己还活着，与此同时leader在收到follower对Heartbeat的响应之后，又会向日志比较落后的follower发送追加日志请求，进行log replication。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>raft<span class=\"token punctuation\">)</span> <span class=\"token function\">tickHeartbeat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    r<span class=\"token punctuation\">.</span>heartbeatElapsed<span class=\"token operator\">++</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ... </span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 如果心跳计时超过了心跳包的发送间隔，就进入发送心跳包流程，并重置心跳计时</span>\n    <span class=\"token keyword\">if</span> r<span class=\"token punctuation\">.</span>heartbeatElapsed <span class=\"token operator\">>=</span> r<span class=\"token punctuation\">.</span>heartbeatTimeout <span class=\"token punctuation\">{</span>\n        r<span class=\"token punctuation\">.</span>heartbeatElapsed <span class=\"token operator\">=</span> <span class=\"token number\">0</span> \n        r<span class=\"token punctuation\">.</span><span class=\"token function\">Step</span><span class=\"token punctuation\">(</span>pb<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">{</span>From<span class=\"token punctuation\">:</span> r<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> Type<span class=\"token punctuation\">:</span> pb<span class=\"token punctuation\">.</span>MsgBeat<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>   \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>raft<span class=\"token punctuation\">)</span> <span class=\"token function\">Step</span><span class=\"token punctuation\">(</span>m pb<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Step最终调用raft.step变量指向的函数</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 现阶段当前节点处于leader状态，所以step指向stepLeader </span>\n    r<span class=\"token punctuation\">.</span><span class=\"token function\">step</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">nil</span> \n<span class=\"token punctuation\">}</span></code></pre>\n<p>stepLeader中心跳发送代码相关执行流程如下：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">stepLeader</span><span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>raft<span class=\"token punctuation\">,</span> m pb<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">switch</span> m<span class=\"token punctuation\">.</span>Type <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> pb<span class=\"token punctuation\">.</span>MsgBeat：\n        <span class=\"token comment\" spellcheck=\"true\">// 把心跳包广播出去</span>\n        r<span class=\"token punctuation\">.</span><span class=\"token function\">bcastHeartbeat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 在bcastHeartbeat中循环的把心跳包发送出去</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>raft<span class=\"token punctuation\">)</span> <span class=\"token function\">bcastHeartbeat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> id <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> r<span class=\"token punctuation\">.</span>prs <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> id <span class=\"token operator\">==</span> r<span class=\"token punctuation\">.</span>id <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">continue</span>\n        <span class=\"token punctuation\">}</span>\n        r<span class=\"token punctuation\">.</span><span class=\"token function\">sendHeartbeat</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n        r<span class=\"token punctuation\">.</span>prs<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>raft<span class=\"token punctuation\">)</span> <span class=\"token function\">sendHeartbeat</span><span class=\"token punctuation\">(</span>to <span class=\"token builtin\">uint64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// r.raftLog.committed 已经拷贝到大多数节点上的日志index</span>\n    <span class=\"token comment\" spellcheck=\"true\">// r.prs[to].Match拷贝到to这个节点的日志最大下标</span>\n    commit <span class=\"token operator\">:=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">.</span>prs<span class=\"token punctuation\">[</span>to<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>Match<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">.</span>raftLog<span class=\"token punctuation\">.</span>committed<span class=\"token punctuation\">)</span>\n    m <span class=\"token operator\">:=</span> pb<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">{</span>\n        To<span class=\"token punctuation\">:</span>     to<span class=\"token punctuation\">,</span>\n        Type<span class=\"token punctuation\">:</span>   pb<span class=\"token punctuation\">.</span>MsgHeartbeat<span class=\"token punctuation\">,</span>\n        Commit<span class=\"token punctuation\">:</span> commit<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//把心跳包发送出去</span>\n    r<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>follower在收到心跳包之后，最终处理心跳的包的流程会通过Step-&gt;step-&gt;stepFollower:</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">stepFollower</span><span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>raft<span class=\"token punctuation\">,</span> m pb<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">switch</span> m<span class=\"token punctuation\">.</span>Type <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> pb<span class=\"token punctuation\">.</span>MsgHeartbeat<span class=\"token punctuation\">:</span>\n        r<span class=\"token punctuation\">.</span>electionElapsed <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        r<span class=\"token punctuation\">.</span>lead <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span>From\n        r<span class=\"token punctuation\">.</span><span class=\"token function\">handleHeartbeat</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">case</span> <span class=\"token comment\" spellcheck=\"true\">//...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 更新本地可以提交的日志的最大下标，然后返回响应</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>raft<span class=\"token punctuation\">)</span> <span class=\"token function\">handleHeartbeat</span><span class=\"token punctuation\">(</span>m pb<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    r<span class=\"token punctuation\">.</span>raftLog<span class=\"token punctuation\">.</span><span class=\"token function\">commitTo</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>Commit<span class=\"token punctuation\">)</span>\n    r<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>pb<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">{</span>To<span class=\"token punctuation\">:</span> m<span class=\"token punctuation\">.</span>From<span class=\"token punctuation\">,</span> Type<span class=\"token punctuation\">:</span> pb<span class=\"token punctuation\">.</span>MsgHeartbeatResp<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>leader的心跳响应收到之后处理流程依旧会通过Step-&gt;step-&gt;stepLeader:</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">stepLeader</span><span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>raft<span class=\"token punctuation\">,</span> m pb<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">switch</span> m<span class=\"token punctuation\">.</span>Type <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    <span class=\"token keyword\">case</span> pb<span class=\"token punctuation\">.</span>MsgHeartbeatResp<span class=\"token punctuation\">:</span>\n        pr<span class=\"token punctuation\">.</span>RecentActive <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// free one slot for the full inflights window to allow progress.</span>\n        <span class=\"token keyword\">if</span> pr<span class=\"token punctuation\">.</span>State <span class=\"token operator\">==</span> ProgressStateReplicate <span class=\"token operator\">&amp;&amp;</span> pr<span class=\"token punctuation\">.</span>ins<span class=\"token punctuation\">.</span><span class=\"token function\">full</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            pr<span class=\"token punctuation\">.</span>ins<span class=\"token punctuation\">.</span><span class=\"token function\">freeFirstOne</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 检查是否还有日志没有拷贝到当前follower，如果有待发送的日志，通过sendAppend发送过去。</span>\n        <span class=\"token keyword\">if</span> pr<span class=\"token punctuation\">.</span>Match <span class=\"token operator\">&lt;</span> r<span class=\"token punctuation\">.</span>raftLog<span class=\"token punctuation\">.</span><span class=\"token function\">lastIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            r<span class=\"token punctuation\">.</span><span class=\"token function\">sendAppend</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>From<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">case</span> <span class=\"token comment\" spellcheck=\"true\">//...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>sendAppend函数的实现如下：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>raft<span class=\"token punctuation\">)</span> <span class=\"token function\">sendAppend</span><span class=\"token punctuation\">(</span>to <span class=\"token builtin\">uint64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    pr <span class=\"token operator\">:=</span> r<span class=\"token punctuation\">.</span>prs<span class=\"token punctuation\">[</span>to<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> pr<span class=\"token punctuation\">.</span><span class=\"token function\">isPaused</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    m <span class=\"token operator\">:=</span> pb<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    m<span class=\"token punctuation\">.</span>To <span class=\"token operator\">=</span> to\n    <span class=\"token comment\" spellcheck=\"true\">// 给该follower发送的最后一条日志的term</span>\n    term<span class=\"token punctuation\">,</span> errt <span class=\"token operator\">:=</span> r<span class=\"token punctuation\">.</span>raftLog<span class=\"token punctuation\">.</span><span class=\"token function\">term</span><span class=\"token punctuation\">(</span>pr<span class=\"token punctuation\">.</span>Next <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 即将要发送给该follower的日志条目</span>\n    ents<span class=\"token punctuation\">,</span> erre <span class=\"token operator\">:=</span> r<span class=\"token punctuation\">.</span>raftLog<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span>pr<span class=\"token punctuation\">.</span>Next<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">.</span>maxMsgSize<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 如果待发送给follower已经写到snap里面，在raftlog里面无法找到</span>\n    <span class=\"token keyword\">if</span> errt <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token operator\">||</span> erre <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// send snapshot if we failed to get term or entries</span>\n        <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>pr<span class=\"token punctuation\">.</span>RecentActive <span class=\"token punctuation\">{</span>\n            r<span class=\"token punctuation\">.</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">Debugf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ignore sending snapshot to %x since it is not recently active\"</span><span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span>\n        <span class=\"token punctuation\">}</span>\n\n        m<span class=\"token punctuation\">.</span>Type <span class=\"token operator\">=</span> pb<span class=\"token punctuation\">.</span>MsgSnap\n        snapshot<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> r<span class=\"token punctuation\">.</span>raftLog<span class=\"token punctuation\">.</span><span class=\"token function\">snapshot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> err <span class=\"token operator\">==</span> ErrSnapshotTemporarilyUnavailable <span class=\"token punctuation\">{</span>\n                r<span class=\"token punctuation\">.</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">Debugf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%x failed to send snapshot to %x because snapshot is temporarily unavailable\"</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// TODO(bdarnell)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token function\">IsEmptySnap</span><span class=\"token punctuation\">(</span>snapshot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"need non-empty snapshot\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        m<span class=\"token punctuation\">.</span>Snapshot <span class=\"token operator\">=</span> snapshot\n        sindex<span class=\"token punctuation\">,</span> sterm <span class=\"token operator\">:=</span> snapshot<span class=\"token punctuation\">.</span>Metadata<span class=\"token punctuation\">.</span>Index<span class=\"token punctuation\">,</span> snapshot<span class=\"token punctuation\">.</span>Metadata<span class=\"token punctuation\">.</span>Term\n        r<span class=\"token punctuation\">.</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">Debugf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%x [firstindex: %d, commit: %d] sent snapshot[index: %d, term: %d] to %x [%s]\"</span><span class=\"token punctuation\">,</span>\n            r<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">.</span>raftLog<span class=\"token punctuation\">.</span><span class=\"token function\">firstIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">.</span>raftLog<span class=\"token punctuation\">.</span>committed<span class=\"token punctuation\">,</span> sindex<span class=\"token punctuation\">,</span> sterm<span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">,</span> pr<span class=\"token punctuation\">)</span>\n        pr<span class=\"token punctuation\">.</span><span class=\"token function\">becomeSnapshot</span><span class=\"token punctuation\">(</span>sindex<span class=\"token punctuation\">)</span>\n        r<span class=\"token punctuation\">.</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">Debugf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%x paused sending replication messages to %x [%s]\"</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">,</span> pr<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        m<span class=\"token punctuation\">.</span>Type <span class=\"token operator\">=</span> pb<span class=\"token punctuation\">.</span>MsgApp\n        m<span class=\"token punctuation\">.</span>Index <span class=\"token operator\">=</span> pr<span class=\"token punctuation\">.</span>Next <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n        m<span class=\"token punctuation\">.</span>LogTerm <span class=\"token operator\">=</span> term\n        m<span class=\"token punctuation\">.</span>Entries <span class=\"token operator\">=</span> ents\n        <span class=\"token comment\" spellcheck=\"true\">// leader记录的最大的已经copy到大多数节点上的日志下标</span>\n        m<span class=\"token punctuation\">.</span>Commit <span class=\"token operator\">=</span> r<span class=\"token punctuation\">.</span>raftLog<span class=\"token punctuation\">.</span>committed\n        <span class=\"token keyword\">if</span> n <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>Entries<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> n <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">switch</span> pr<span class=\"token punctuation\">.</span>State <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// optimistically increase the next when in ProgressStateReplicate</span>\n            <span class=\"token keyword\">case</span> ProgressStateReplicate<span class=\"token punctuation\">:</span>\n                last <span class=\"token operator\">:=</span> m<span class=\"token punctuation\">.</span>Entries<span class=\"token punctuation\">[</span>n<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>Index\n                pr<span class=\"token punctuation\">.</span><span class=\"token function\">optimisticUpdate</span><span class=\"token punctuation\">(</span>last<span class=\"token punctuation\">)</span>\n                pr<span class=\"token punctuation\">.</span>ins<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>last<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">case</span> ProgressStateProbe<span class=\"token punctuation\">:</span>\n                pr<span class=\"token punctuation\">.</span><span class=\"token function\">pause</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n                r<span class=\"token punctuation\">.</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">Panicf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%x is sending append in unhandled state %s\"</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> pr<span class=\"token punctuation\">.</span>State<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    r<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>follower在收到leader发送过来的追加日志请求时，会通过handleAppendEntries去处理消息：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>raft<span class=\"token punctuation\">)</span> <span class=\"token function\">handleAppendEntries</span><span class=\"token punctuation\">(</span>m pb<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// r.raftLog.committed实在当前节点已经提交的日志</span>\n    <span class=\"token comment\" spellcheck=\"true\">// m.Index为leader发送给该follower的上一条日志索引</span>\n    <span class=\"token comment\" spellcheck=\"true\">// m.Index &lt; r.raftLog.committed情况多出现在刚刚选出的leader向follower拷贝日志，leader本地还未记录向该follower拷贝了多少日志</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 出现这种请求leader会把自己已经提交的日志的最大下标发送给leader，下次leader就会从r.raftLog.committed + 1开始发送日志</span>\n    <span class=\"token keyword\">if</span> m<span class=\"token punctuation\">.</span>Index <span class=\"token operator\">&lt;</span> r<span class=\"token punctuation\">.</span>raftLog<span class=\"token punctuation\">.</span>committed <span class=\"token punctuation\">{</span>\n        r<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>pb<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">{</span>To<span class=\"token punctuation\">:</span> m<span class=\"token punctuation\">.</span>From<span class=\"token punctuation\">,</span> Type<span class=\"token punctuation\">:</span> pb<span class=\"token punctuation\">.</span>MsgAppResp<span class=\"token punctuation\">,</span> Index<span class=\"token punctuation\">:</span> r<span class=\"token punctuation\">.</span>raftLog<span class=\"token punctuation\">.</span>committed<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// leader拷贝日志有可能在follower已经存在，所以要先找到相对与follower日志比较新的日志下标</span>\n    <span class=\"token keyword\">if</span> mlastIndex<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">:=</span> r<span class=\"token punctuation\">.</span>raftLog<span class=\"token punctuation\">.</span><span class=\"token function\">maybeAppend</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>Index<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">.</span>LogTerm<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">.</span>Commit<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">.</span>Entries<span class=\"token operator\">...</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> ok <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 当leader发送过来的上次发送给该follower的最后一条日志信息与follower本地储存的无冲突时，</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 返回follower本地已经写入的最大日志下标，下次leader就会从该下标发送日志，并会更新leader记录的该follower的日志发送信息</span>\n        r<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>pb<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">{</span>To<span class=\"token punctuation\">:</span> m<span class=\"token punctuation\">.</span>From<span class=\"token punctuation\">,</span> Type<span class=\"token punctuation\">:</span> pb<span class=\"token punctuation\">.</span>MsgAppResp<span class=\"token punctuation\">,</span> Index<span class=\"token punctuation\">:</span> mlastIndex<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 最后leader发送过来的最后一条日志的index，term等信息与follower本地记录的不一样</span>\n        r<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>pb<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">{</span>To<span class=\"token punctuation\">:</span> m<span class=\"token punctuation\">.</span>From<span class=\"token punctuation\">,</span> Type<span class=\"token punctuation\">:</span> pb<span class=\"token punctuation\">.</span>MsgAppResp<span class=\"token punctuation\">,</span> Index<span class=\"token punctuation\">:</span> m<span class=\"token punctuation\">.</span>Index<span class=\"token punctuation\">,</span> Reject<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> RejectHint<span class=\"token punctuation\">:</span> r<span class=\"token punctuation\">.</span>raftLog<span class=\"token punctuation\">.</span><span class=\"token function\">lastIndex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">*</span>raftLog<span class=\"token punctuation\">)</span> <span class=\"token function\">maybeAppend</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> logTerm<span class=\"token punctuation\">,</span> committed <span class=\"token builtin\">uint64</span><span class=\"token punctuation\">,</span> ents <span class=\"token operator\">...</span>pb<span class=\"token punctuation\">.</span>Entry<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>lastnewi <span class=\"token builtin\">uint64</span><span class=\"token punctuation\">,</span> ok <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    lastnewi <span class=\"token operator\">=</span> index <span class=\"token operator\">+</span> <span class=\"token function\">uint64</span><span class=\"token punctuation\">(</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span>ents<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> l<span class=\"token punctuation\">.</span><span class=\"token function\">matchTerm</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> logTerm<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 找到leader发送给follower的第一条新日志的位置</span>\n        ci <span class=\"token operator\">:=</span> l<span class=\"token punctuation\">.</span><span class=\"token function\">findConflict</span><span class=\"token punctuation\">(</span>ents<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 说明leader拷贝过来的日志都在follower的raftlog里面有记录</span>\n        <span class=\"token keyword\">case</span> ci <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 日志冲突的下标小于follower本地已经提交的日志，出现bug了</span>\n        <span class=\"token keyword\">case</span> ci <span class=\"token operator\">&lt;=</span> l<span class=\"token punctuation\">.</span>committed<span class=\"token punctuation\">:</span>\n            l<span class=\"token punctuation\">.</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">Panicf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"entry %d conflict with committed entry [committed(%d)]\"</span><span class=\"token punctuation\">,</span> ci<span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">.</span>committed<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n           <span class=\"token comment\" spellcheck=\"true\">// 把leader拷贝过来的新日志写入follower本地</span>\n            offset <span class=\"token operator\">:=</span> index <span class=\"token operator\">+</span> <span class=\"token number\">1</span> \n            l<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>ents<span class=\"token punctuation\">[</span>ci<span class=\"token operator\">-</span>offset<span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        l<span class=\"token punctuation\">.</span><span class=\"token function\">commitTo</span><span class=\"token punctuation\">(</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>committed<span class=\"token punctuation\">,</span> lastnewi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 返回follower本地最新的日志记录index</span>\n        <span class=\"token keyword\">return</span> lastnewi<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span>   \n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>leader收到的follower对日志追加请求的响应主要有两种：follower拒绝追加日志，follower追加0-n条日志，相关响应的处理代码如下:</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">stepLeader</span><span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>raft<span class=\"token punctuation\">,</span> m pb<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    <span class=\"token keyword\">switch</span> m<span class=\"token punctuation\">.</span>Type <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> pb<span class=\"token punctuation\">.</span>MsgAppResp<span class=\"token punctuation\">:</span>\n        pr<span class=\"token punctuation\">.</span>RecentActive <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n\n        <span class=\"token keyword\">if</span> m<span class=\"token punctuation\">.</span>Reject <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 拒绝追加日志</span>\n            <span class=\"token comment\" spellcheck=\"true\">// follower拒绝追加日志时都会返回一个RejectHint，RejectHint表示当前follower最后一条日志的index</span>\n            <span class=\"token comment\" spellcheck=\"true\">// maybeDecrTo函数在follower为ProgressStateReplicate状态是会把pr[to].Next设置为pr[to].Match + 1，否者会设置为被设置为m.Index、m.RejectHint中较小的一个，然后继续尝试发送。</span>\n            <span class=\"token keyword\">if</span> pr<span class=\"token punctuation\">.</span><span class=\"token function\">maybeDecrTo</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>Index<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">.</span>RejectHint<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> pr<span class=\"token punctuation\">.</span>State <span class=\"token operator\">==</span> ProgressStateReplicate <span class=\"token punctuation\">{</span>\n                    pr<span class=\"token punctuation\">.</span><span class=\"token function\">becomeProbe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span>\n                r<span class=\"token punctuation\">.</span><span class=\"token function\">sendAppend</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>From<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            oldPaused <span class=\"token operator\">:=</span> pr<span class=\"token punctuation\">.</span><span class=\"token function\">isPaused</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 如果又在follower上追加日志，更新以下两个下标:</span>\n            <span class=\"token comment\" spellcheck=\"true\">// （1）follower已经和leader一致的最大日志下标:pr[to].Match = m.Index</span>\n            <span class=\"token comment\" spellcheck=\"true\">// （2）下一条需要拷贝给该follower的日志下标:pr[to].Next = m.Index + 1</span>\n            <span class=\"token keyword\">if</span> pr<span class=\"token punctuation\">.</span><span class=\"token function\">maybeUpdate</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>Index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">case</span> pr<span class=\"token punctuation\">.</span>State <span class=\"token operator\">==</span> ProgressStateProbe<span class=\"token punctuation\">:</span>\n                    pr<span class=\"token punctuation\">.</span><span class=\"token function\">becomeReplicate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">case</span> pr<span class=\"token punctuation\">.</span>State <span class=\"token operator\">==</span> ProgressStateSnapshot <span class=\"token operator\">&amp;&amp;</span> pr<span class=\"token punctuation\">.</span><span class=\"token function\">maybeSnapshotAbort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                    pr<span class=\"token punctuation\">.</span><span class=\"token function\">becomeProbe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">case</span> pr<span class=\"token punctuation\">.</span>State <span class=\"token operator\">==</span> ProgressStateReplicate<span class=\"token punctuation\">:</span>\n                    pr<span class=\"token punctuation\">.</span>ins<span class=\"token punctuation\">.</span><span class=\"token function\">freeTo</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>Index<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 如果该follower有追加成功的日志，可能会出现新的日志条目拷贝到大多数raft节点上，</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 因此leader更新本地raftlog.commitid，然后通过bcastAppend把新更新的commit(如果follower日志落后于leader，可能携带日志)广播给follower，</span>\n                <span class=\"token comment\" spellcheck=\"true\">// follower更新本地已经提交到大多数机器上的日志下标，本地小于commit未apply的日志就可以apply了</span>\n                <span class=\"token keyword\">if</span> r<span class=\"token punctuation\">.</span><span class=\"token function\">maybeCommit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    r<span class=\"token punctuation\">.</span><span class=\"token function\">bcastAppend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> oldPaused <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// update() reset the wait state on this node. If we had delayed sending</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// an update before, send it now.</span>\n                    r<span class=\"token punctuation\">.</span><span class=\"token function\">sendAppend</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>From<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">case</span> <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"Leader选举\"><a href=\"#Leader选举\" class=\"headerlink\" title=\"Leader选举\"></a>Leader选举</h3><h4 id=\"触发条件\"><a href=\"#触发条件\" class=\"headerlink\" title=\"触发条件\"></a>触发条件</h4><ul>\n<li>一般条件下，追随者接到领导者的心跳的时候，把选举定时器清零，不会触发</li>\n<li>最随着的选举定时器超时发生时（比如Leader故障了），那从节点会变成候选者，触发领导人选举</li>\n</ul>\n<h4 id=\"选举过程\"><a href=\"#选举过程\" class=\"headerlink\" title=\"选举过程\"></a>选举过程</h4><ul>\n<li>一开始，所有节点都是以Follow角色启动，同时启动选举定时器（时间随机，降低冲突概率）</li>\n<li>当定时器到期的时候，转为候选人角色【candicate】</li>\n<li>把当前任期+1并且为自己投票</li>\n<li>发起RequestVote的RPC请求，要求其他节点为自己投票</li>\n<li>如果得到办事以上的节点同意，自己称为Leader</li>\n<li>如果选举超时，还没有Leader产生，则进入下一任期，重新选举</li>\n</ul>\n<h4 id=\"限制条件\"><a href=\"#限制条件\" class=\"headerlink\" title=\"限制条件\"></a>限制条件</h4><p>假定这样一个情况，1号节点作为Leader在同步完成3号以后，在对2号同步数据的时候挂掉了，那如果2号 [未携带合法数据] 参与选举则会引起错误。所以必须规避这些问题。</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/7.png\" alt></p>\n<ul>\n<li>每个接待你在<strong>一个任期里面只能投一个票</strong>，采用先到先服务的原则</li>\n<li>如果没有投过票，对比候选人节点的Log和当前节点的Log哪个更新，比较方式为<strong>谁的lastLog的term越大谁越新</strong>，如果term相同，<strong>谁的lastLog的index谁越大谁越新</strong>，如果当前节点更新，则拒绝投票。</li>\n</ul>\n<h3 id=\"日志复制\"><a href=\"#日志复制\" class=\"headerlink\" title=\"日志复制\"></a>日志复制</h3><p>Raft状态机图示</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/9.png\" alt></p>\n<p> Leader将命令并发的复制给其他节点，并等待其他节点将命令写入到日志中，如果此时有些节点失败或者比较慢，Leader节点会一直重试，所有的节点都保存到日志中，之后Leader节点就提交命令， 在接下来的心跳包所有的从节点都会提交对应的修改，并将节点返回给客户端。</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/8.png\" alt></p>\n<p>当客户端向服务器发送修改x的请求时，主节点接收到，并且修改掉自己的日志，但并未提交 ( comit )。</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/10.png\" alt></p>\n<p>此时Leader会告诉所有的节点修改日志，但是都未提交。</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/11.png\" alt></p>\n<p>从节点收到以后，回复Leader收到。</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/12.png\" alt></p>\n<p>Leader节点Comit，然后通过心跳包所有的从节点提交。</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/13.png\" alt></p>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><p>一个作为候选人的节点要赢得选举，就需要喝网络中大部分节点进行通信，这就意味着已经提交的乳汁条目最少在其中一台服务器节点上出现，如果候选人的日志至少和大多数的服务器上的日志一样新，那么他一定包含全部已经提交的日志条目。</p>\n<p>RequestVote RPC 实现了这个限制： RPC包括勾选人的日志信息，如果它自己的日志比候选人的日志要新，他会拒绝给候选人投票。</p>\n<h3 id=\"最新判断标准\"><a href=\"#最新判断标准\" class=\"headerlink\" title=\"最新判断标准\"></a>最新判断标准</h3><ul>\n<li>如果两个日志的任期号不同，任期号打的日志内容更新</li>\n<li>如果任期号一样大，则更具日志中最后一个命令的索引(Index)，谁大谁最新</li>\n</ul>\n<h3 id=\"数据安全性\"><a href=\"#数据安全性\" class=\"headerlink\" title=\"数据安全性\"></a>数据安全性</h3><p>在我们保证了选举时候选出的Leader必须是携带者最新的日志的同时，也需要保证数据的最新性。如下：</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/15.png\" alt></p>\n<p>当我们的节点存在于多个路由器或者交换机下时，比如 D、E、F、节点处在交换机子网2中间，其中D为Leader节点。A、B、C是处于子网1中间。正常通信的时候通过分布式一致性协议下不会有任何问题。</p>\n<p>但是当出现网络问题的时候，比如两个交换机之间出现网络分区的时候【老列】，我们仔细想一下这个问题。</p>\n<ul>\n<li><p>正常通信的时候，分布式一致性协议会保证每个节点的数据一致</p>\n</li>\n<li><p>当网络分区出现时，A、B、C节点给D节点发送收不到回应，则会认为Leader D挂了</p>\n</li>\n<li><p>在A、B、C中间会进行Leader选举，假定A变成了Leader</p>\n</li>\n<li><p>与此同时，客户端发送数据修改请求，因为旧的Leader D节点收不到来自A、B、C、的修改确认回应，他会一直重复发心跳包而停止提交修改。</p>\n</li>\n<li><p>A节点作为新的Leader接受了客户端的请求并且同步到了B、C节点。</p>\n</li>\n</ul>\n<p>当某一时刻，网络情况恢复了以后 :</p>\n<ul>\n<li>新的Leader节点 A  携带的数据最新，D节点会发送心跳包给其他节点，D节点由于Term和数据携带不够新而被舍弃</li>\n<li>A发送心跳包同步到其他节点，当然也包括D节点，D节点发现A的数据包更新，于是丢弃Leader职位成为Follower。于是A节点成为Leader，一切正常</li>\n</ul>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/16.png\" alt></p>\n<p>最后，推荐 <a href=\"http://thesecretlivesofdata.com/raft/\" target=\"_blank\" rel=\"noopener\">Raft</a> 动画演示。可以很清楚了解raft协议的一些过程。</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<h2 id=\"微服务架构-之-Raft协议\"><a href=\"#微服务架构-之-Raft协议\" class=\"headerlink\" title=\"微服务架构 之 Raft协议\"></a>微服务架构 之 Raft协议</h2><h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><ul>\n<li>​    解决分布式系统一致性的问题</li>\n<li>​    基于复制的方式</li>\n</ul>\n<h3 id=\"工作机制\"><a href=\"#工作机制\" class=\"headerlink\" title=\"工作机制\"></a>工作机制</h3><ul>\n<li>Leader选举</li>\n<li>日志复制</li>\n<li>安全性</li>\n</ul>\n<h3 id=\"角色\"><a href=\"#角色\" class=\"headerlink\" title=\"角色\"></a>角色</h3><ul>\n<li>Follower 角色</li>\n<li>Leader 角色</li>\n<li>Candicate 角色</li>\n</ul>\n<h3 id=\"任期-Term-概念\"><a href=\"#任期-Term-概念\" class=\"headerlink\" title=\"任期( Term ) 概念\"></a>任期( Term ) 概念</h3><p>在raft协议中，将时间分为一个个 term（任期），每一个任期内都可正常操作。但是如果主节点挂掉则必须通过选举才可以进行Leader节点的选择。</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/5.png\" alt></p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/6.png\" alt></p>\n<ul>\n<li>Raft 把时间分割成任意长度的任期（term），如图 5 所示。任期用连续的整数标记。</li>\n<li>每一段任期从一次选举开始，一个或者多个 candidate 尝试成为 leader 。如果一个 candidate 赢得选举，然后他就在该任期剩下的时间里充当 leader 。在某些情况下，一次选举无法选出 leader 。在这种情况下，这一任期会以没有 leader 结束；一个新的任期（包含一次新的选举）会很快重新开始。</li>\n<li>Raft 保证了在任意一个任期内，最多只有一个 leader</li>\n</ul>\n<p>个人理解：</p>\n<ul>\n<li>在raft算法中，比较谁的数据最新有2个参考指标，任期和logIndex，任期大的节点，数据一定最新，任期一样的话，就要比较该任期内谁的MaxLogIndex最大了。引入任期的概念可以简化数据比较的精度。</li>\n</ul>\n<h3 id=\"任期的作用\"><a href=\"#任期的作用\" class=\"headerlink\" title=\"任期的作用\"></a>任期的作用</h3><ul>\n<li>不同的服务器节点观察到的任期转换的次数可能不同，在某些情况下，一个服务器节点可能没有看到 leader 选举过程或者甚至整个任期全程。</li>\n<li>任期在 Raft 算法中充当逻辑时钟的作用，这使得服务器节点可以发现一些过期的信息比如过时的 leader 。</li>\n<li>每一个服务器节点存储一个当前任期号，该编号随着时间单调递增。</li>\n<li>服务器之间通信的时候会交换当前任期号；</li>\n<li>如果一个服务器的当前任期号比其他的小，该服务器会将自己的任期号更新为较大的那个值。</li>\n<li>如果一个 candidate 或者 leader 发现自己的任期号过期了，它会立即回到 follower 状态。（所以说老leader如果发生了网络分区，后来接收到新leader的心跳的时候，比拼完任期之后，会自动变成follower。</li>\n<li>如果一个节点接收到一个包含过期的任期号的请求，它会直接拒绝这个请求</li>\n</ul>\n<h3 id=\"状态机复制\"><a href=\"#状态机复制\" class=\"headerlink\" title=\"状态机复制\"></a>状态机复制</h3><p>其实很简单，通过每个节点执行一样的命令序列，则最终会得到相同的状态，Raft就是通过状态机的方式来达到一致性的效果。</p>\n<h3 id=\"心跳和超时机制\"><a href=\"#心跳和超时机制\" class=\"headerlink\" title=\"心跳和超时机制\"></a>心跳和超时机制</h3><p>raft使用两个timeout机制来控制leader的选举，当选举完成后，leader会向所有的从节点发心跳包确认存活，再Leader挂掉的时候，操作是不可用的。</p>\n<p>Raft的Heartbeat是leader在选举成功后巩固自己地位和同步信息的一种方式，日志的复制大多数情况下适合Heartbeat是同步进行的。当一个raft节点选举成为leader后，该节点周期性执行的tick函数指向了raft.tickHeartbeat，对于leader而言主要是通知follower自己还活着，与此同时leader在收到follower对Heartbeat的响应之后，又会向日志比较落后的follower发送追加日志请求，进行log replication。</p>\n<pre><code class=\"go\">func (r *raft) tickHeartbeat() {\n    r.heartbeatElapsed++\n    // ... \n\n    // 如果心跳计时超过了心跳包的发送间隔，就进入发送心跳包流程，并重置心跳计时\n    if r.heartbeatElapsed &gt;= r.heartbeatTimeout {\n        r.heartbeatElapsed = 0 \n        r.Step(pb.Message{From: r.id, Type: pb.MsgBeat})\n    }   \n}\n\nfunc (r *raft) Step(m pb.Message) error {\n    // ...\n\n    // Step最终调用raft.step变量指向的函数\n    // 现阶段当前节点处于leader状态，所以step指向stepLeader \n    r.step(r, m)\n    return nil \n}</code></pre>\n<p>stepLeader中心跳发送代码相关执行流程如下：</p>\n<pre><code class=\"go\">func stepLeader(r *raft, m pb.Message) {\n    switch m.Type {\n    case pb.MsgBeat：\n        // 把心跳包广播出去\n        r.bcastHeartbeat()\n    return\n    // ...\n}\n\n// 在bcastHeartbeat中循环的把心跳包发送出去\nfunc (r *raft) bcastHeartbeat() {\n    for id := range r.prs {\n        if id == r.id {\n            continue\n        }\n        r.sendHeartbeat(id)\n        r.prs[id].resume()\n    }\n}\nfunc (r *raft) sendHeartbeat(to uint64) {\n    // r.raftLog.committed 已经拷贝到大多数节点上的日志index\n    // r.prs[to].Match拷贝到to这个节点的日志最大下标\n    commit := min(r.prs[to].Match, r.raftLog.committed)\n    m := pb.Message{\n        To:     to,\n        Type:   pb.MsgHeartbeat,\n        Commit: commit,\n    }\n    //把心跳包发送出去\n    r.send(m)\n}</code></pre>\n<p>follower在收到心跳包之后，最终处理心跳的包的流程会通过Step-&gt;step-&gt;stepFollower:</p>\n<pre><code class=\"go\">func stepFollower(r *raft, m pb.Message) {\n    switch m.Type {\n    case pb.MsgHeartbeat:\n        r.electionElapsed = 0\n        r.lead = m.From\n        r.handleHeartbeat(m)\n    case //...\n    }\n}\n\n// 更新本地可以提交的日志的最大下标，然后返回响应\nfunc (r *raft) handleHeartbeat(m pb.Message) {\n    r.raftLog.commitTo(m.Commit)\n    r.send(pb.Message{To: m.From, Type: pb.MsgHeartbeatResp})\n}\n</code></pre>\n<p>leader的心跳响应收到之后处理流程依旧会通过Step-&gt;step-&gt;stepLeader:</p>\n<pre><code class=\"go\">func stepLeader(r *raft, m pb.Message) {\n    switch m.Type {\n        // ...\n    case pb.MsgHeartbeatResp:\n        pr.RecentActive = true\n\n        // free one slot for the full inflights window to allow progress.\n        if pr.State == ProgressStateReplicate &amp;&amp; pr.ins.full() {\n            pr.ins.freeFirstOne()\n        }\n        // 检查是否还有日志没有拷贝到当前follower，如果有待发送的日志，通过sendAppend发送过去。\n        if pr.Match &lt; r.raftLog.lastIndex() {\n            r.sendAppend(m.From)\n        }\n        case //...\n    }\n}</code></pre>\n<p>sendAppend函数的实现如下：</p>\n<pre><code class=\"go\">func (r *raft) sendAppend(to uint64) {\n    pr := r.prs[to]\n    if pr.isPaused() {\n        return\n    }\n    m := pb.Message{}\n    m.To = to\n    // 给该follower发送的最后一条日志的term\n    term, errt := r.raftLog.term(pr.Next - 1)\n    // 即将要发送给该follower的日志条目\n    ents, erre := r.raftLog.entries(pr.Next, r.maxMsgSize)\n\n    // 如果待发送给follower已经写到snap里面，在raftlog里面无法找到\n    if errt != nil || erre != nil { // send snapshot if we failed to get term or entries\n        if !pr.RecentActive {\n            r.logger.Debugf(&quot;ignore sending snapshot to %x since it is not recently active&quot;, to)\n            return\n        }\n\n        m.Type = pb.MsgSnap\n        snapshot, err := r.raftLog.snapshot()\n        if err != nil {\n            if err == ErrSnapshotTemporarilyUnavailable {\n                r.logger.Debugf(&quot;%x failed to send snapshot to %x because snapshot is temporarily unavailable&quot;, r.id, to)\n                return\n            }\n            panic(err) // TODO(bdarnell)\n        }\n        if IsEmptySnap(snapshot) {\n            panic(&quot;need non-empty snapshot&quot;)\n        }\n        m.Snapshot = snapshot\n        sindex, sterm := snapshot.Metadata.Index, snapshot.Metadata.Term\n        r.logger.Debugf(&quot;%x [firstindex: %d, commit: %d] sent snapshot[index: %d, term: %d] to %x [%s]&quot;,\n            r.id, r.raftLog.firstIndex(), r.raftLog.committed, sindex, sterm, to, pr)\n        pr.becomeSnapshot(sindex)\n        r.logger.Debugf(&quot;%x paused sending replication messages to %x [%s]&quot;, r.id, to, pr)\n    } else {\n        m.Type = pb.MsgApp\n        m.Index = pr.Next - 1\n        m.LogTerm = term\n        m.Entries = ents\n        // leader记录的最大的已经copy到大多数节点上的日志下标\n        m.Commit = r.raftLog.committed\n        if n := len(m.Entries); n != 0 {\n            switch pr.State {\n            // optimistically increase the next when in ProgressStateReplicate\n            case ProgressStateReplicate:\n                last := m.Entries[n-1].Index\n                pr.optimisticUpdate(last)\n                pr.ins.add(last)\n            case ProgressStateProbe:\n                pr.pause()\n            default:\n                r.logger.Panicf(&quot;%x is sending append in unhandled state %s&quot;, r.id, pr.State)\n            }\n        }\n    }\n    r.send(m)\n}</code></pre>\n<p>follower在收到leader发送过来的追加日志请求时，会通过handleAppendEntries去处理消息：</p>\n<pre><code class=\"go\">func (r *raft) handleAppendEntries(m pb.Message) {\n    // r.raftLog.committed实在当前节点已经提交的日志\n    // m.Index为leader发送给该follower的上一条日志索引\n    // m.Index &lt; r.raftLog.committed情况多出现在刚刚选出的leader向follower拷贝日志，leader本地还未记录向该follower拷贝了多少日志\n    // 出现这种请求leader会把自己已经提交的日志的最大下标发送给leader，下次leader就会从r.raftLog.committed + 1开始发送日志\n    if m.Index &lt; r.raftLog.committed {\n        r.send(pb.Message{To: m.From, Type: pb.MsgAppResp, Index: r.raftLog.committed})\n        return\n    }\n    // leader拷贝日志有可能在follower已经存在，所以要先找到相对与follower日志比较新的日志下标\n    if mlastIndex, ok := r.raftLog.maybeAppend(m.Index, m.LogTerm, m.Commit, m.Entries...); ok {\n        // 当leader发送过来的上次发送给该follower的最后一条日志信息与follower本地储存的无冲突时，\n        // 返回follower本地已经写入的最大日志下标，下次leader就会从该下标发送日志，并会更新leader记录的该follower的日志发送信息\n        r.send(pb.Message{To: m.From, Type: pb.MsgAppResp, Index: mlastIndex})\n    } else {\n        // 最后leader发送过来的最后一条日志的index，term等信息与follower本地记录的不一样\n        r.send(pb.Message{To: m.From, Type: pb.MsgAppResp, Index: m.Index, Reject: true, RejectHint: r.raftLog.lastIndex()})\n    }\n}\n\nfunc (l *raftLog) maybeAppend(index, logTerm, committed uint64, ents ...pb.Entry) (lastnewi uint64, ok bool) {\n    lastnewi = index + uint64(len(ents))\n    if l.matchTerm(index, logTerm) {\n        // 找到leader发送给follower的第一条新日志的位置\n        ci := l.findConflict(ents)\n        switch {\n        // 说明leader拷贝过来的日志都在follower的raftlog里面有记录\n        case ci == 0:\n        // 日志冲突的下标小于follower本地已经提交的日志，出现bug了\n        case ci &lt;= l.committed:\n            l.logger.Panicf(&quot;entry %d conflict with committed entry [committed(%d)]&quot;, ci, l.committed)\n        default:\n           // 把leader拷贝过来的新日志写入follower本地\n            offset := index + 1 \n            l.append(ents[ci-offset:]...)\n        }\n        l.commitTo(min(committed, lastnewi))\n        // 返回follower本地最新的日志记录index\n        return lastnewi, true\n    }   \n    return 0, false\n}</code></pre>\n<p>leader收到的follower对日志追加请求的响应主要有两种：follower拒绝追加日志，follower追加0-n条日志，相关响应的处理代码如下:</p>\n<pre><code class=\"go\">func stepLeader(r *raft, m pb.Message) {\n    // ...\n    switch m.Type {\n    case pb.MsgAppResp:\n        pr.RecentActive = true\n\n        if m.Reject {\n            // 拒绝追加日志\n            // follower拒绝追加日志时都会返回一个RejectHint，RejectHint表示当前follower最后一条日志的index\n            // maybeDecrTo函数在follower为ProgressStateReplicate状态是会把pr[to].Next设置为pr[to].Match + 1，否者会设置为被设置为m.Index、m.RejectHint中较小的一个，然后继续尝试发送。\n            if pr.maybeDecrTo(m.Index, m.RejectHint) {\n                if pr.State == ProgressStateReplicate {\n                    pr.becomeProbe()\n                }\n                r.sendAppend(m.From)\n            }\n        } else {\n            oldPaused := pr.isPaused()\n            // 如果又在follower上追加日志，更新以下两个下标:\n            // （1）follower已经和leader一致的最大日志下标:pr[to].Match = m.Index\n            // （2）下一条需要拷贝给该follower的日志下标:pr[to].Next = m.Index + 1\n            if pr.maybeUpdate(m.Index) {\n                switch {\n                case pr.State == ProgressStateProbe:\n                    pr.becomeReplicate()\n                case pr.State == ProgressStateSnapshot &amp;&amp; pr.maybeSnapshotAbort():\n                    pr.becomeProbe()\n                case pr.State == ProgressStateReplicate:\n                    pr.ins.freeTo(m.Index)\n                }\n                // 如果该follower有追加成功的日志，可能会出现新的日志条目拷贝到大多数raft节点上，\n                // 因此leader更新本地raftlog.commitid，然后通过bcastAppend把新更新的commit(如果follower日志落后于leader，可能携带日志)广播给follower，\n                // follower更新本地已经提交到大多数机器上的日志下标，本地小于commit未apply的日志就可以apply了\n                if r.maybeCommit() {\n                    r.bcastAppend()\n                } else if oldPaused {\n                    // update() reset the wait state on this node. If we had delayed sending\n                    // an update before, send it now.\n                    r.sendAppend(m.From)\n                }\n            }\n        }\n    case // ...\n}</code></pre>\n<h3 id=\"Leader选举\"><a href=\"#Leader选举\" class=\"headerlink\" title=\"Leader选举\"></a>Leader选举</h3><h4 id=\"触发条件\"><a href=\"#触发条件\" class=\"headerlink\" title=\"触发条件\"></a>触发条件</h4><ul>\n<li>一般条件下，追随者接到领导者的心跳的时候，把选举定时器清零，不会触发</li>\n<li>最随着的选举定时器超时发生时（比如Leader故障了），那从节点会变成候选者，触发领导人选举</li>\n</ul>\n<h4 id=\"选举过程\"><a href=\"#选举过程\" class=\"headerlink\" title=\"选举过程\"></a>选举过程</h4><ul>\n<li>一开始，所有节点都是以Follow角色启动，同时启动选举定时器（时间随机，降低冲突概率）</li>\n<li>当定时器到期的时候，转为候选人角色【candicate】</li>\n<li>把当前任期+1并且为自己投票</li>\n<li>发起RequestVote的RPC请求，要求其他节点为自己投票</li>\n<li>如果得到办事以上的节点同意，自己称为Leader</li>\n<li>如果选举超时，还没有Leader产生，则进入下一任期，重新选举</li>\n</ul>\n<h4 id=\"限制条件\"><a href=\"#限制条件\" class=\"headerlink\" title=\"限制条件\"></a>限制条件</h4><p>假定这样一个情况，1号节点作为Leader在同步完成3号以后，在对2号同步数据的时候挂掉了，那如果2号 [未携带合法数据] 参与选举则会引起错误。所以必须规避这些问题。</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/7.png\" alt></p>\n<ul>\n<li>每个接待你在<strong>一个任期里面只能投一个票</strong>，采用先到先服务的原则</li>\n<li>如果没有投过票，对比候选人节点的Log和当前节点的Log哪个更新，比较方式为<strong>谁的lastLog的term越大谁越新</strong>，如果term相同，<strong>谁的lastLog的index谁越大谁越新</strong>，如果当前节点更新，则拒绝投票。</li>\n</ul>\n<h3 id=\"日志复制\"><a href=\"#日志复制\" class=\"headerlink\" title=\"日志复制\"></a>日志复制</h3><p>Raft状态机图示</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/9.png\" alt></p>\n<p> Leader将命令并发的复制给其他节点，并等待其他节点将命令写入到日志中，如果此时有些节点失败或者比较慢，Leader节点会一直重试，所有的节点都保存到日志中，之后Leader节点就提交命令， 在接下来的心跳包所有的从节点都会提交对应的修改，并将节点返回给客户端。</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/8.png\" alt></p>\n<p>当客户端向服务器发送修改x的请求时，主节点接收到，并且修改掉自己的日志，但并未提交 ( comit )。</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/10.png\" alt></p>\n<p>此时Leader会告诉所有的节点修改日志，但是都未提交。</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/11.png\" alt></p>\n<p>从节点收到以后，回复Leader收到。</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/12.png\" alt></p>\n<p>Leader节点Comit，然后通过心跳包所有的从节点提交。</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/13.png\" alt></p>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><p>一个作为候选人的节点要赢得选举，就需要喝网络中大部分节点进行通信，这就意味着已经提交的乳汁条目最少在其中一台服务器节点上出现，如果候选人的日志至少和大多数的服务器上的日志一样新，那么他一定包含全部已经提交的日志条目。</p>\n<p>RequestVote RPC 实现了这个限制： RPC包括勾选人的日志信息，如果它自己的日志比候选人的日志要新，他会拒绝给候选人投票。</p>\n<h3 id=\"最新判断标准\"><a href=\"#最新判断标准\" class=\"headerlink\" title=\"最新判断标准\"></a>最新判断标准</h3><ul>\n<li>如果两个日志的任期号不同，任期号打的日志内容更新</li>\n<li>如果任期号一样大，则更具日志中最后一个命令的索引(Index)，谁大谁最新</li>\n</ul>\n<h3 id=\"数据安全性\"><a href=\"#数据安全性\" class=\"headerlink\" title=\"数据安全性\"></a>数据安全性</h3><p>在我们保证了选举时候选出的Leader必须是携带者最新的日志的同时，也需要保证数据的最新性。如下：</p>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/15.png\" alt></p>\n<p>当我们的节点存在于多个路由器或者交换机下时，比如 D、E、F、节点处在交换机子网2中间，其中D为Leader节点。A、B、C是处于子网1中间。正常通信的时候通过分布式一致性协议下不会有任何问题。</p>\n<p>但是当出现网络问题的时候，比如两个交换机之间出现网络分区的时候【老列】，我们仔细想一下这个问题。</p>\n<ul>\n<li><p>正常通信的时候，分布式一致性协议会保证每个节点的数据一致</p>\n</li>\n<li><p>当网络分区出现时，A、B、C节点给D节点发送收不到回应，则会认为Leader D挂了</p>\n</li>\n<li><p>在A、B、C中间会进行Leader选举，假定A变成了Leader</p>\n</li>\n<li><p>与此同时，客户端发送数据修改请求，因为旧的Leader D节点收不到来自A、B、C、的修改确认回应，他会一直重复发心跳包而停止提交修改。</p>\n</li>\n<li><p>A节点作为新的Leader接受了客户端的请求并且同步到了B、C节点。</p>\n</li>\n</ul>\n<p>当某一时刻，网络情况恢复了以后 :</p>\n<ul>\n<li>新的Leader节点 A  携带的数据最新，D节点会发送心跳包给其他节点，D节点由于Term和数据携带不够新而被舍弃</li>\n<li>A发送心跳包同步到其他节点，当然也包括D节点，D节点发现A的数据包更新，于是丢弃Leader职位成为Follower。于是A节点成为Leader，一切正常</li>\n</ul>\n<p><img src=\"/2020/02/10/wei-fu-wu-jia-gou-san-raft-xie-yi/16.png\" alt></p>\n<p>最后，推荐 <a href=\"http://thesecretlivesofdata.com/raft/\" target=\"_blank\" rel=\"noopener\">Raft</a> 动画演示。可以很清楚了解raft协议的一些过程。</p>\n"},{"title":"服务器平滑升级 柔性重启","date":"2020-01-25T09:19:24.000Z","_content":"\n# 服务器平滑升级\n\n​\t\t当我们的server需要进行升级的时候，我们不可能说吧正在接受和处请求的服务down掉，硬性的进行upgrade，毕竟当流量比较大的时候，这是非常不好的一种体验损失和价值的流失。\n\n​\t\t但我们如何在程序升级的过程中，不影响正在处理的请求呢？还有除了不影响以外，我们需要怎么去做？要是在做的过程中，系统在升级，此时新的请求进来怎么办？\n\n## 柔性重启\n\n- **我们如何在程序升级的过程中，不影响正在处理的请求呢？**\n\n最简单粗暴的方式就是等待其处理完之后再进行退出。当然在1.8里面已经支持，最简单的就是在`goroutine`添加的时候添加计数。\n\n- **还有除了不影响以外，我们需要怎么去做？**\n- **要是在做的过程中，系统在升级，此时新的请求进来怎么办？**\n\n我们可以`Fork`一个新的`子进程`，`继承`父进程监听的Socket,然后子进程启动之后接受新的连接，同时父进程停止接受新的连接，等已有的处理操作完毕后，退出。再进行升级，然后优雅重启成功\n\n### 那按照这个思路，子进程如何继承父进程的文件句柄？\n\n1. 通过 os.Cmd 对象中的ExtraFiles参数进行传递\n\n   ```go\n   os.Cmd\n   ```\n\n   \n\n2. 文件句柄继承\n\n 注:系统进程的继承**只在Linux上面有效**\n\n\n\n","source":"_posts/服务器平滑升级-柔性重启.md","raw":"---\ntitle: 服务器平滑升级 柔性重启\ndate: 2020-01-25 17:19:24\ntags: [Go,服务端开发]\ncategories: Go栈\n---\n\n# 服务器平滑升级\n\n​\t\t当我们的server需要进行升级的时候，我们不可能说吧正在接受和处请求的服务down掉，硬性的进行upgrade，毕竟当流量比较大的时候，这是非常不好的一种体验损失和价值的流失。\n\n​\t\t但我们如何在程序升级的过程中，不影响正在处理的请求呢？还有除了不影响以外，我们需要怎么去做？要是在做的过程中，系统在升级，此时新的请求进来怎么办？\n\n## 柔性重启\n\n- **我们如何在程序升级的过程中，不影响正在处理的请求呢？**\n\n最简单粗暴的方式就是等待其处理完之后再进行退出。当然在1.8里面已经支持，最简单的就是在`goroutine`添加的时候添加计数。\n\n- **还有除了不影响以外，我们需要怎么去做？**\n- **要是在做的过程中，系统在升级，此时新的请求进来怎么办？**\n\n我们可以`Fork`一个新的`子进程`，`继承`父进程监听的Socket,然后子进程启动之后接受新的连接，同时父进程停止接受新的连接，等已有的处理操作完毕后，退出。再进行升级，然后优雅重启成功\n\n### 那按照这个思路，子进程如何继承父进程的文件句柄？\n\n1. 通过 os.Cmd 对象中的ExtraFiles参数进行传递\n\n   ```go\n   os.Cmd\n   ```\n\n   \n\n2. 文件句柄继承\n\n 注:系统进程的继承**只在Linux上面有效**\n\n\n\n","slug":"服务器平滑升级-柔性重启","published":1,"updated":"2020-02-10T07:47:54.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rjs001pzd5b8g21hata","content":"<h1 id=\"服务器平滑升级\"><a href=\"#服务器平滑升级\" class=\"headerlink\" title=\"服务器平滑升级\"></a>服务器平滑升级</h1><p>​        当我们的server需要进行升级的时候，我们不可能说吧正在接受和处请求的服务down掉，硬性的进行upgrade，毕竟当流量比较大的时候，这是非常不好的一种体验损失和价值的流失。</p>\n<p>​        但我们如何在程序升级的过程中，不影响正在处理的请求呢？还有除了不影响以外，我们需要怎么去做？要是在做的过程中，系统在升级，此时新的请求进来怎么办？</p>\n<h2 id=\"柔性重启\"><a href=\"#柔性重启\" class=\"headerlink\" title=\"柔性重启\"></a>柔性重启</h2><ul>\n<li><strong>我们如何在程序升级的过程中，不影响正在处理的请求呢？</strong></li>\n</ul>\n<p>最简单粗暴的方式就是等待其处理完之后再进行退出。当然在1.8里面已经支持，最简单的就是在<code>goroutine</code>添加的时候添加计数。</p>\n<ul>\n<li><strong>还有除了不影响以外，我们需要怎么去做？</strong></li>\n<li><strong>要是在做的过程中，系统在升级，此时新的请求进来怎么办？</strong></li>\n</ul>\n<p>我们可以<code>Fork</code>一个新的<code>子进程</code>，<code>继承</code>父进程监听的Socket,然后子进程启动之后接受新的连接，同时父进程停止接受新的连接，等已有的处理操作完毕后，退出。再进行升级，然后优雅重启成功</p>\n<h3 id=\"那按照这个思路，子进程如何继承父进程的文件句柄？\"><a href=\"#那按照这个思路，子进程如何继承父进程的文件句柄？\" class=\"headerlink\" title=\"那按照这个思路，子进程如何继承父进程的文件句柄？\"></a>那按照这个思路，子进程如何继承父进程的文件句柄？</h3><ol>\n<li><p>通过 os.Cmd 对象中的ExtraFiles参数进行传递</p>\n<pre class=\" language-go\"><code class=\"language-go\">os<span class=\"token punctuation\">.</span>Cmd</code></pre>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>文件句柄继承</p>\n<p>注:系统进程的继承<strong>只在Linux上面有效</strong></p>\n</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<h1 id=\"服务器平滑升级\"><a href=\"#服务器平滑升级\" class=\"headerlink\" title=\"服务器平滑升级\"></a>服务器平滑升级</h1><p>​        当我们的server需要进行升级的时候，我们不可能说吧正在接受和处请求的服务down掉，硬性的进行upgrade，毕竟当流量比较大的时候，这是非常不好的一种体验损失和价值的流失。</p>\n<p>​        但我们如何在程序升级的过程中，不影响正在处理的请求呢？还有除了不影响以外，我们需要怎么去做？要是在做的过程中，系统在升级，此时新的请求进来怎么办？</p>\n<h2 id=\"柔性重启\"><a href=\"#柔性重启\" class=\"headerlink\" title=\"柔性重启\"></a>柔性重启</h2><ul>\n<li><strong>我们如何在程序升级的过程中，不影响正在处理的请求呢？</strong></li>\n</ul>\n<p>最简单粗暴的方式就是等待其处理完之后再进行退出。当然在1.8里面已经支持，最简单的就是在<code>goroutine</code>添加的时候添加计数。</p>\n<ul>\n<li><strong>还有除了不影响以外，我们需要怎么去做？</strong></li>\n<li><strong>要是在做的过程中，系统在升级，此时新的请求进来怎么办？</strong></li>\n</ul>\n<p>我们可以<code>Fork</code>一个新的<code>子进程</code>，<code>继承</code>父进程监听的Socket,然后子进程启动之后接受新的连接，同时父进程停止接受新的连接，等已有的处理操作完毕后，退出。再进行升级，然后优雅重启成功</p>\n<h3 id=\"那按照这个思路，子进程如何继承父进程的文件句柄？\"><a href=\"#那按照这个思路，子进程如何继承父进程的文件句柄？\" class=\"headerlink\" title=\"那按照这个思路，子进程如何继承父进程的文件句柄？\"></a>那按照这个思路，子进程如何继承父进程的文件句柄？</h3><ol>\n<li><p>通过 os.Cmd 对象中的ExtraFiles参数进行传递</p>\n<pre><code class=\"go\">os.Cmd</code></pre>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>文件句柄继承</p>\n<p>注:系统进程的继承<strong>只在Linux上面有效</strong></p>\n</li>\n</ol>\n"},{"title":" 微服务架构 [二] 服务注册","date":"2020-02-06T06:31:46.000Z","_content":"\n# 微服务架构\n\n微服务架构\n\n## 服务注册\n\n以订单服务请求产品服务调用为例，一帮的服务注册可以采用两种实现方式。\n\n### **客户端实现**\n\n1. 需要维护所有调用服务的地址\n2. 有一定的技术难度，需要rpc框架支持\n\n当采用客户端来做的时候，结构图如下\n\n![](/1.png)\n\n当我们订单服务调用产品服务的时候，由于有三个产品服务，在客户端起来的时候，产品服务会把自己的ip地址等信息注册到服务注册中心里，当订单服务请求产品服务的时候，他会优先查询本地的产品服务的源信息[IP，名字等等]，若没有，则回去注册中心查询对应的服务IP列表。\n\n得到IP列表以后，选择调用哪一个则有对应的**负载均衡**的策略。\n\n- 轮询的负载均衡\n- 通过特定映射的一致性Hash\n\n找到以后就可以调用了。\n\n### **服务器实现**\n\n1. 架构简单\n2. 可能会有单点故障\n\n当采用服务器端来做的时候，结构图如下\n\n![](/2.png)\n\n当订单服务来调用产品服务时，已经不直接通过和注册中心联系的方式查询，而是直接调用LB来调用产品服务，这对于调用方来说是完全透明的。不需要自己实现查询这一套方案。\n\n## 注册中心\n\n### etcd注册中心\n\netcd 是一种分布式 kv 存储设施, 他具有一定的**一致性,高性能,高可用**的方案.基于raft一致性协议。类似的 zookeeper, 但没有 zookeeper 那么重型,功能也没有覆盖那么多. 简单直接的应用就是配置中心。\n\n#### etcd使用场景\n\n- 服务注册和发现\n- 共享配置\n- 分布式锁\n- Leader选举\n\n但是etcd虽然是强一致性的，当某时刻etcd的节点如果出现问题，这段时间需要选举一个新的主来，在这段时间内，我们的服务是不可用的。我们对etcd的强一致性是不需要高度一致的，比如在微服务在某时刻查询注册中心的ip列表的时候，各个查询的结果不是强一直也不会有太大影响，只要一致性存在就行。\n\n#### 弱一致性AP系统\n\n虽然在某时刻节点挂掉以后，不影响服务的正常运行，通过主从同步都会恢复，不需要强一致性。\n\n#### 强一致性\n\nEureka是高可用的注册中心。是一个AP系统，由netflix开发。\n\n### 分布式一致性问题\n\n单独一个节点是不存在分布式一致性问题的，但是在集群里面，分布式一致性问题是避免不了的问题。\n\n在一个操作中，需要多个系统之间配合才能完成的整个业务逻辑，叫做分布式系统。\n\n#### 分布式拆分三步骤\n\n　　1.将你的整个整个应用视为一个系统（不管它有多复杂）\n\n　　2.将整个系统分割为一系列的服务模块， 每个服务模块完成一定的功能（单一职责）\n\n　　3.将这些服务模块 分散部署到不同的机器上。分散后，选择若干种（没错一种可能不够）通信协议把他们连接起来，当执行某项操作的时候按照拆分的系统有序的执行。\n\n### 拆分+连接是分布式系统的本质\n\n　　所谓分布式，无非就是”将一个系统拆分成多个子系统并散布到不同设备“的过程而已。\n\n　　本质上而言，实现一个分布式系统，最核心的部分无非有两点：\n\n　　　1.如何拆分——可以有很多方式，核心依据一是业务需求，二是成本限制。这是实践中构建分布式系统时最主要的设计依据。\n\n　　　2.如何连接——光把系统拆开成 单个服务模块还不够，关键是拆开后的 服务模块之间还要能通信，因此涉及通信协议设计的问题，需要考虑的因素很多，好消息是这部分其实成熟，方案很多。\n\n### 为什么你要使用分布式？\n\n　　分布式系统并非灵丹妙药，解决问题的关键还是看你对问题本身的了解。通常我们需要使用分布式的常见理由是：\n\n　　1.为了性能扩展 ——系统负载高，单台机器无法承载，希望通过使用多台机器来提高系统的负载能力。\n\n　　　　例：对一个B2C(京东、淘宝)商城进行拆分，首页部分我们要考虑到高并发、高可用、搜索、缓存等等一系列的情况，需要把这个功能单独拆分出来来扩展性能\n\n 　　2.为了增强可靠性 ——软件不是完美的，网络不是完美的，甚至机器本身也不可能是完美的，随时可能会出错，为了避免故障，需要将业务分散开保留一定的冗余度\n\n在以提供 Service 为主的服务端软件开发过程中常常遇到这些问题。\n\n 一些分布式方案能解决你的问题，另一些却不能，要学会的其实是选择。\n\n　　笼统的讨论分布式没有太大的意义，就如我刚才所谈的，实际上分布式很容易实现。真正难的地方在于如何选择正确的分布方案。\n\n　　例如，当你想要建立一个分布式的数据管理系统的时候，你就必须得面对“一致性”问题。如果你对数据一致性要求很高，你就不得不容忍一些缺陷例如规模伸缩困难；而如果你放弃它，你可以轻松伸缩规模，但你必须解决好由此带来的一系列数据不一致导致的问题。（CAP 问题）\n\n![](/3.jpg)\n\n\n\n","source":"_posts/微服务架构-二-微服务注册和发现.md","raw":"---\ntitle: ' 微服务架构 [二] 服务注册'\ndate: 2020-02-06 14:31:46\ntags: [Go,微服务,Micro Service]\ncategories: Go栈\n---\n\n# 微服务架构\n\n微服务架构\n\n## 服务注册\n\n以订单服务请求产品服务调用为例，一帮的服务注册可以采用两种实现方式。\n\n### **客户端实现**\n\n1. 需要维护所有调用服务的地址\n2. 有一定的技术难度，需要rpc框架支持\n\n当采用客户端来做的时候，结构图如下\n\n![](/1.png)\n\n当我们订单服务调用产品服务的时候，由于有三个产品服务，在客户端起来的时候，产品服务会把自己的ip地址等信息注册到服务注册中心里，当订单服务请求产品服务的时候，他会优先查询本地的产品服务的源信息[IP，名字等等]，若没有，则回去注册中心查询对应的服务IP列表。\n\n得到IP列表以后，选择调用哪一个则有对应的**负载均衡**的策略。\n\n- 轮询的负载均衡\n- 通过特定映射的一致性Hash\n\n找到以后就可以调用了。\n\n### **服务器实现**\n\n1. 架构简单\n2. 可能会有单点故障\n\n当采用服务器端来做的时候，结构图如下\n\n![](/2.png)\n\n当订单服务来调用产品服务时，已经不直接通过和注册中心联系的方式查询，而是直接调用LB来调用产品服务，这对于调用方来说是完全透明的。不需要自己实现查询这一套方案。\n\n## 注册中心\n\n### etcd注册中心\n\netcd 是一种分布式 kv 存储设施, 他具有一定的**一致性,高性能,高可用**的方案.基于raft一致性协议。类似的 zookeeper, 但没有 zookeeper 那么重型,功能也没有覆盖那么多. 简单直接的应用就是配置中心。\n\n#### etcd使用场景\n\n- 服务注册和发现\n- 共享配置\n- 分布式锁\n- Leader选举\n\n但是etcd虽然是强一致性的，当某时刻etcd的节点如果出现问题，这段时间需要选举一个新的主来，在这段时间内，我们的服务是不可用的。我们对etcd的强一致性是不需要高度一致的，比如在微服务在某时刻查询注册中心的ip列表的时候，各个查询的结果不是强一直也不会有太大影响，只要一致性存在就行。\n\n#### 弱一致性AP系统\n\n虽然在某时刻节点挂掉以后，不影响服务的正常运行，通过主从同步都会恢复，不需要强一致性。\n\n#### 强一致性\n\nEureka是高可用的注册中心。是一个AP系统，由netflix开发。\n\n### 分布式一致性问题\n\n单独一个节点是不存在分布式一致性问题的，但是在集群里面，分布式一致性问题是避免不了的问题。\n\n在一个操作中，需要多个系统之间配合才能完成的整个业务逻辑，叫做分布式系统。\n\n#### 分布式拆分三步骤\n\n　　1.将你的整个整个应用视为一个系统（不管它有多复杂）\n\n　　2.将整个系统分割为一系列的服务模块， 每个服务模块完成一定的功能（单一职责）\n\n　　3.将这些服务模块 分散部署到不同的机器上。分散后，选择若干种（没错一种可能不够）通信协议把他们连接起来，当执行某项操作的时候按照拆分的系统有序的执行。\n\n### 拆分+连接是分布式系统的本质\n\n　　所谓分布式，无非就是”将一个系统拆分成多个子系统并散布到不同设备“的过程而已。\n\n　　本质上而言，实现一个分布式系统，最核心的部分无非有两点：\n\n　　　1.如何拆分——可以有很多方式，核心依据一是业务需求，二是成本限制。这是实践中构建分布式系统时最主要的设计依据。\n\n　　　2.如何连接——光把系统拆开成 单个服务模块还不够，关键是拆开后的 服务模块之间还要能通信，因此涉及通信协议设计的问题，需要考虑的因素很多，好消息是这部分其实成熟，方案很多。\n\n### 为什么你要使用分布式？\n\n　　分布式系统并非灵丹妙药，解决问题的关键还是看你对问题本身的了解。通常我们需要使用分布式的常见理由是：\n\n　　1.为了性能扩展 ——系统负载高，单台机器无法承载，希望通过使用多台机器来提高系统的负载能力。\n\n　　　　例：对一个B2C(京东、淘宝)商城进行拆分，首页部分我们要考虑到高并发、高可用、搜索、缓存等等一系列的情况，需要把这个功能单独拆分出来来扩展性能\n\n 　　2.为了增强可靠性 ——软件不是完美的，网络不是完美的，甚至机器本身也不可能是完美的，随时可能会出错，为了避免故障，需要将业务分散开保留一定的冗余度\n\n在以提供 Service 为主的服务端软件开发过程中常常遇到这些问题。\n\n 一些分布式方案能解决你的问题，另一些却不能，要学会的其实是选择。\n\n　　笼统的讨论分布式没有太大的意义，就如我刚才所谈的，实际上分布式很容易实现。真正难的地方在于如何选择正确的分布方案。\n\n　　例如，当你想要建立一个分布式的数据管理系统的时候，你就必须得面对“一致性”问题。如果你对数据一致性要求很高，你就不得不容忍一些缺陷例如规模伸缩困难；而如果你放弃它，你可以轻松伸缩规模，但你必须解决好由此带来的一系列数据不一致导致的问题。（CAP 问题）\n\n![](/3.jpg)\n\n\n\n","slug":"微服务架构-二-微服务注册和发现","published":1,"updated":"2020-02-10T03:12:50.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rjt001szd5bcg6k2vs9","content":"<h1 id=\"微服务架构\"><a href=\"#微服务架构\" class=\"headerlink\" title=\"微服务架构\"></a>微服务架构</h1><p>微服务架构</p>\n<h2 id=\"服务注册\"><a href=\"#服务注册\" class=\"headerlink\" title=\"服务注册\"></a>服务注册</h2><p>以订单服务请求产品服务调用为例，一帮的服务注册可以采用两种实现方式。</p>\n<h3 id=\"客户端实现\"><a href=\"#客户端实现\" class=\"headerlink\" title=\"客户端实现\"></a><strong>客户端实现</strong></h3><ol>\n<li>需要维护所有调用服务的地址</li>\n<li>有一定的技术难度，需要rpc框架支持</li>\n</ol>\n<p>当采用客户端来做的时候，结构图如下</p>\n<p><img src=\"/2020/02/06/wei-fu-wu-jia-gou-er-wei-fu-wu-zhu-ce-he-fa-xian/1.png\" alt></p>\n<p>当我们订单服务调用产品服务的时候，由于有三个产品服务，在客户端起来的时候，产品服务会把自己的ip地址等信息注册到服务注册中心里，当订单服务请求产品服务的时候，他会优先查询本地的产品服务的源信息[IP，名字等等]，若没有，则回去注册中心查询对应的服务IP列表。</p>\n<p>得到IP列表以后，选择调用哪一个则有对应的<strong>负载均衡</strong>的策略。</p>\n<ul>\n<li>轮询的负载均衡</li>\n<li>通过特定映射的一致性Hash</li>\n</ul>\n<p>找到以后就可以调用了。</p>\n<h3 id=\"服务器实现\"><a href=\"#服务器实现\" class=\"headerlink\" title=\"服务器实现\"></a><strong>服务器实现</strong></h3><ol>\n<li>架构简单</li>\n<li>可能会有单点故障</li>\n</ol>\n<p>当采用服务器端来做的时候，结构图如下</p>\n<p><img src=\"/2020/02/06/wei-fu-wu-jia-gou-er-wei-fu-wu-zhu-ce-he-fa-xian/2.png\" alt></p>\n<p>当订单服务来调用产品服务时，已经不直接通过和注册中心联系的方式查询，而是直接调用LB来调用产品服务，这对于调用方来说是完全透明的。不需要自己实现查询这一套方案。</p>\n<h2 id=\"注册中心\"><a href=\"#注册中心\" class=\"headerlink\" title=\"注册中心\"></a>注册中心</h2><h3 id=\"etcd注册中心\"><a href=\"#etcd注册中心\" class=\"headerlink\" title=\"etcd注册中心\"></a>etcd注册中心</h3><p>etcd 是一种分布式 kv 存储设施, 他具有一定的<strong>一致性,高性能,高可用</strong>的方案.基于raft一致性协议。类似的 zookeeper, 但没有 zookeeper 那么重型,功能也没有覆盖那么多. 简单直接的应用就是配置中心。</p>\n<h4 id=\"etcd使用场景\"><a href=\"#etcd使用场景\" class=\"headerlink\" title=\"etcd使用场景\"></a>etcd使用场景</h4><ul>\n<li>服务注册和发现</li>\n<li>共享配置</li>\n<li>分布式锁</li>\n<li>Leader选举</li>\n</ul>\n<p>但是etcd虽然是强一致性的，当某时刻etcd的节点如果出现问题，这段时间需要选举一个新的主来，在这段时间内，我们的服务是不可用的。我们对etcd的强一致性是不需要高度一致的，比如在微服务在某时刻查询注册中心的ip列表的时候，各个查询的结果不是强一直也不会有太大影响，只要一致性存在就行。</p>\n<h4 id=\"弱一致性AP系统\"><a href=\"#弱一致性AP系统\" class=\"headerlink\" title=\"弱一致性AP系统\"></a>弱一致性AP系统</h4><p>虽然在某时刻节点挂掉以后，不影响服务的正常运行，通过主从同步都会恢复，不需要强一致性。</p>\n<h4 id=\"强一致性\"><a href=\"#强一致性\" class=\"headerlink\" title=\"强一致性\"></a>强一致性</h4><p>Eureka是高可用的注册中心。是一个AP系统，由netflix开发。</p>\n<h3 id=\"分布式一致性问题\"><a href=\"#分布式一致性问题\" class=\"headerlink\" title=\"分布式一致性问题\"></a>分布式一致性问题</h3><p>单独一个节点是不存在分布式一致性问题的，但是在集群里面，分布式一致性问题是避免不了的问题。</p>\n<p>在一个操作中，需要多个系统之间配合才能完成的整个业务逻辑，叫做分布式系统。</p>\n<h4 id=\"分布式拆分三步骤\"><a href=\"#分布式拆分三步骤\" class=\"headerlink\" title=\"分布式拆分三步骤\"></a>分布式拆分三步骤</h4><p>　　1.将你的整个整个应用视为一个系统（不管它有多复杂）</p>\n<p>　　2.将整个系统分割为一系列的服务模块， 每个服务模块完成一定的功能（单一职责）</p>\n<p>　　3.将这些服务模块 分散部署到不同的机器上。分散后，选择若干种（没错一种可能不够）通信协议把他们连接起来，当执行某项操作的时候按照拆分的系统有序的执行。</p>\n<h3 id=\"拆分-连接是分布式系统的本质\"><a href=\"#拆分-连接是分布式系统的本质\" class=\"headerlink\" title=\"拆分+连接是分布式系统的本质\"></a>拆分+连接是分布式系统的本质</h3><p>　　所谓分布式，无非就是”将一个系统拆分成多个子系统并散布到不同设备“的过程而已。</p>\n<p>　　本质上而言，实现一个分布式系统，最核心的部分无非有两点：</p>\n<p>　　　1.如何拆分——可以有很多方式，核心依据一是业务需求，二是成本限制。这是实践中构建分布式系统时最主要的设计依据。</p>\n<p>　　　2.如何连接——光把系统拆开成 单个服务模块还不够，关键是拆开后的 服务模块之间还要能通信，因此涉及通信协议设计的问题，需要考虑的因素很多，好消息是这部分其实成熟，方案很多。</p>\n<h3 id=\"为什么你要使用分布式？\"><a href=\"#为什么你要使用分布式？\" class=\"headerlink\" title=\"为什么你要使用分布式？\"></a>为什么你要使用分布式？</h3><p>　　分布式系统并非灵丹妙药，解决问题的关键还是看你对问题本身的了解。通常我们需要使用分布式的常见理由是：</p>\n<p>　　1.为了性能扩展 ——系统负载高，单台机器无法承载，希望通过使用多台机器来提高系统的负载能力。</p>\n<p>　　　　例：对一个B2C(京东、淘宝)商城进行拆分，首页部分我们要考虑到高并发、高可用、搜索、缓存等等一系列的情况，需要把这个功能单独拆分出来来扩展性能</p>\n<p> 　　2.为了增强可靠性 ——软件不是完美的，网络不是完美的，甚至机器本身也不可能是完美的，随时可能会出错，为了避免故障，需要将业务分散开保留一定的冗余度</p>\n<p>在以提供 Service 为主的服务端软件开发过程中常常遇到这些问题。</p>\n<p> 一些分布式方案能解决你的问题，另一些却不能，要学会的其实是选择。</p>\n<p>　　笼统的讨论分布式没有太大的意义，就如我刚才所谈的，实际上分布式很容易实现。真正难的地方在于如何选择正确的分布方案。</p>\n<p>　　例如，当你想要建立一个分布式的数据管理系统的时候，你就必须得面对“一致性”问题。如果你对数据一致性要求很高，你就不得不容忍一些缺陷例如规模伸缩困难；而如果你放弃它，你可以轻松伸缩规模，但你必须解决好由此带来的一系列数据不一致导致的问题。（CAP 问题）</p>\n<p><img src=\"/2020/02/06/wei-fu-wu-jia-gou-er-wei-fu-wu-zhu-ce-he-fa-xian/3.jpg\" alt></p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<h1 id=\"微服务架构\"><a href=\"#微服务架构\" class=\"headerlink\" title=\"微服务架构\"></a>微服务架构</h1><p>微服务架构</p>\n<h2 id=\"服务注册\"><a href=\"#服务注册\" class=\"headerlink\" title=\"服务注册\"></a>服务注册</h2><p>以订单服务请求产品服务调用为例，一帮的服务注册可以采用两种实现方式。</p>\n<h3 id=\"客户端实现\"><a href=\"#客户端实现\" class=\"headerlink\" title=\"客户端实现\"></a><strong>客户端实现</strong></h3><ol>\n<li>需要维护所有调用服务的地址</li>\n<li>有一定的技术难度，需要rpc框架支持</li>\n</ol>\n<p>当采用客户端来做的时候，结构图如下</p>\n<p><img src=\"/2020/02/06/wei-fu-wu-jia-gou-er-wei-fu-wu-zhu-ce-he-fa-xian/1.png\" alt></p>\n<p>当我们订单服务调用产品服务的时候，由于有三个产品服务，在客户端起来的时候，产品服务会把自己的ip地址等信息注册到服务注册中心里，当订单服务请求产品服务的时候，他会优先查询本地的产品服务的源信息[IP，名字等等]，若没有，则回去注册中心查询对应的服务IP列表。</p>\n<p>得到IP列表以后，选择调用哪一个则有对应的<strong>负载均衡</strong>的策略。</p>\n<ul>\n<li>轮询的负载均衡</li>\n<li>通过特定映射的一致性Hash</li>\n</ul>\n<p>找到以后就可以调用了。</p>\n<h3 id=\"服务器实现\"><a href=\"#服务器实现\" class=\"headerlink\" title=\"服务器实现\"></a><strong>服务器实现</strong></h3><ol>\n<li>架构简单</li>\n<li>可能会有单点故障</li>\n</ol>\n<p>当采用服务器端来做的时候，结构图如下</p>\n<p><img src=\"/2020/02/06/wei-fu-wu-jia-gou-er-wei-fu-wu-zhu-ce-he-fa-xian/2.png\" alt></p>\n<p>当订单服务来调用产品服务时，已经不直接通过和注册中心联系的方式查询，而是直接调用LB来调用产品服务，这对于调用方来说是完全透明的。不需要自己实现查询这一套方案。</p>\n<h2 id=\"注册中心\"><a href=\"#注册中心\" class=\"headerlink\" title=\"注册中心\"></a>注册中心</h2><h3 id=\"etcd注册中心\"><a href=\"#etcd注册中心\" class=\"headerlink\" title=\"etcd注册中心\"></a>etcd注册中心</h3><p>etcd 是一种分布式 kv 存储设施, 他具有一定的<strong>一致性,高性能,高可用</strong>的方案.基于raft一致性协议。类似的 zookeeper, 但没有 zookeeper 那么重型,功能也没有覆盖那么多. 简单直接的应用就是配置中心。</p>\n<h4 id=\"etcd使用场景\"><a href=\"#etcd使用场景\" class=\"headerlink\" title=\"etcd使用场景\"></a>etcd使用场景</h4><ul>\n<li>服务注册和发现</li>\n<li>共享配置</li>\n<li>分布式锁</li>\n<li>Leader选举</li>\n</ul>\n<p>但是etcd虽然是强一致性的，当某时刻etcd的节点如果出现问题，这段时间需要选举一个新的主来，在这段时间内，我们的服务是不可用的。我们对etcd的强一致性是不需要高度一致的，比如在微服务在某时刻查询注册中心的ip列表的时候，各个查询的结果不是强一直也不会有太大影响，只要一致性存在就行。</p>\n<h4 id=\"弱一致性AP系统\"><a href=\"#弱一致性AP系统\" class=\"headerlink\" title=\"弱一致性AP系统\"></a>弱一致性AP系统</h4><p>虽然在某时刻节点挂掉以后，不影响服务的正常运行，通过主从同步都会恢复，不需要强一致性。</p>\n<h4 id=\"强一致性\"><a href=\"#强一致性\" class=\"headerlink\" title=\"强一致性\"></a>强一致性</h4><p>Eureka是高可用的注册中心。是一个AP系统，由netflix开发。</p>\n<h3 id=\"分布式一致性问题\"><a href=\"#分布式一致性问题\" class=\"headerlink\" title=\"分布式一致性问题\"></a>分布式一致性问题</h3><p>单独一个节点是不存在分布式一致性问题的，但是在集群里面，分布式一致性问题是避免不了的问题。</p>\n<p>在一个操作中，需要多个系统之间配合才能完成的整个业务逻辑，叫做分布式系统。</p>\n<h4 id=\"分布式拆分三步骤\"><a href=\"#分布式拆分三步骤\" class=\"headerlink\" title=\"分布式拆分三步骤\"></a>分布式拆分三步骤</h4><p>　　1.将你的整个整个应用视为一个系统（不管它有多复杂）</p>\n<p>　　2.将整个系统分割为一系列的服务模块， 每个服务模块完成一定的功能（单一职责）</p>\n<p>　　3.将这些服务模块 分散部署到不同的机器上。分散后，选择若干种（没错一种可能不够）通信协议把他们连接起来，当执行某项操作的时候按照拆分的系统有序的执行。</p>\n<h3 id=\"拆分-连接是分布式系统的本质\"><a href=\"#拆分-连接是分布式系统的本质\" class=\"headerlink\" title=\"拆分+连接是分布式系统的本质\"></a>拆分+连接是分布式系统的本质</h3><p>　　所谓分布式，无非就是”将一个系统拆分成多个子系统并散布到不同设备“的过程而已。</p>\n<p>　　本质上而言，实现一个分布式系统，最核心的部分无非有两点：</p>\n<p>　　　1.如何拆分——可以有很多方式，核心依据一是业务需求，二是成本限制。这是实践中构建分布式系统时最主要的设计依据。</p>\n<p>　　　2.如何连接——光把系统拆开成 单个服务模块还不够，关键是拆开后的 服务模块之间还要能通信，因此涉及通信协议设计的问题，需要考虑的因素很多，好消息是这部分其实成熟，方案很多。</p>\n<h3 id=\"为什么你要使用分布式？\"><a href=\"#为什么你要使用分布式？\" class=\"headerlink\" title=\"为什么你要使用分布式？\"></a>为什么你要使用分布式？</h3><p>　　分布式系统并非灵丹妙药，解决问题的关键还是看你对问题本身的了解。通常我们需要使用分布式的常见理由是：</p>\n<p>　　1.为了性能扩展 ——系统负载高，单台机器无法承载，希望通过使用多台机器来提高系统的负载能力。</p>\n<p>　　　　例：对一个B2C(京东、淘宝)商城进行拆分，首页部分我们要考虑到高并发、高可用、搜索、缓存等等一系列的情况，需要把这个功能单独拆分出来来扩展性能</p>\n<p> 　　2.为了增强可靠性 ——软件不是完美的，网络不是完美的，甚至机器本身也不可能是完美的，随时可能会出错，为了避免故障，需要将业务分散开保留一定的冗余度</p>\n<p>在以提供 Service 为主的服务端软件开发过程中常常遇到这些问题。</p>\n<p> 一些分布式方案能解决你的问题，另一些却不能，要学会的其实是选择。</p>\n<p>　　笼统的讨论分布式没有太大的意义，就如我刚才所谈的，实际上分布式很容易实现。真正难的地方在于如何选择正确的分布方案。</p>\n<p>　　例如，当你想要建立一个分布式的数据管理系统的时候，你就必须得面对“一致性”问题。如果你对数据一致性要求很高，你就不得不容忍一些缺陷例如规模伸缩困难；而如果你放弃它，你可以轻松伸缩规模，但你必须解决好由此带来的一系列数据不一致导致的问题。（CAP 问题）</p>\n<p><img src=\"/2020/02/06/wei-fu-wu-jia-gou-er-wei-fu-wu-zhu-ce-he-fa-xian/3.jpg\" alt></p>\n"},{"title":"游戏中的四元数","date":"2020-01-07T07:30:26.000Z","_content":"\n![](/start.png)\n\n## 四元数简介\n\nQuaternion又称四元数，由x,y,z和w这四个分量组成，是由爱尔兰数学家威廉·卢云·哈密顿在1843年发现的数学概念。四元数的乘法不符合交换律。从明确地角度而言，四元数是复数的不可交换延伸。如把四元数的集合考虑成多维实数空间的话，四元数就代表着一个四维空间，相对于复数为二维空间。\n\n在实际的图示如下：\n\n![](/show.jpg)\n\n说实话关于四元数这一节真的是不好懂，因为里面涉及到好多数学知识，单说推出来的公式就有很多。不怕大家笑话，对于四元数的学习我足足花了两天的时间，包括整理出这篇文章。在前面一章我写到了“变换”，这也是总结的学习笔记。我发现，写博客真是的是一个好多学习方法，加上之前一个博士师兄告诉我，要想好好的学习一本书或者一门技术，那么以此将学习笔记或者经验写成博客专栏是一种有效的方法。现在我要坚持这种方式，给自己留下学习过程中的足迹，也给大家分享一下。欢迎大家指出其中的不足，谢谢！\n\n四元数是表示旋转的另一种数学形式，使用四元数可以节省存储空间，其之间的连接运算需要的算术运算更少，在产生平滑的三维动画时，用四元数更容易进行修改。\n\n四元数集合，在数学上被称为哈密顿四元数环(ring of Hamiltonian quaternions)，用H表示，可以理解为四维空间向量，空间中的元素q可以表示为：\n\nq = (x,y,z,w) = w + xi +yj + zk;\n\n也可以用实数和向量的形式进行表示，即：\n\nq = w + v;其中w是实数部分，v是v(x,y,z)。\n\n四元数集合是复数集合的自然扩展。四元数的乘法服从分配率。\n\n每个图形引擎都避免不了四元数的讨论，Unity游戏引擎的四元数类封装的比较好。\n\n## Quaternion类属性\n\n##### eulerAngles-欧拉角\n\n定义：\n\n```c#\npublic Vector3 eulerAngles{get;set;}\n```\n\n  如何改变一个游戏对象旋的转状态，我们可以通过改变其Transform进行欧拉角的变换次序，例如假设p(x,y,z)是游戏对象上的一个点，绕x轴旋转a角，绕y轴旋转b角，绕z轴旋转c角，这样就可以得到旋转之后的状态p'(x',y',z')。\n\n​\tUnity的实现过程是很简单的，一句代码就可以搞定。但是具体的实现过程确实很复杂的,涉及到很多矩阵的运算，这里就不过多的介绍。\n\n​\t下面给出一个例子，演示一下如何使用欧拉角。\n\n```c#\n\nusing UnityEngine;\nusing System.Collections;\n \npublic class EulerAngler_ts : MonoBehaviour {\n    public Transform A, B;\n    Quaternion rotations = Quaternion.identity;\n    Vector3 eulerAngle = Vector3.zero;\n    float speed = 10.0f;\n    float tSpeed = 0.0f;\n    // Use this for initialization\n    void Start () {\n \n    }\n    \n    // Update is called once per frame\n    void Update () {\n        tSpeed += speed * Time.deltaTime;\n        //第一种方式：将Quaternion实例对象赋值给transform的rotation\n        rotations.eulerAngles = new Vector3(0.0f, tSpeed, 0.0f);\n        A.rotation = rotations;\n        //第二种方式：将三位向量代表的欧拉角直接赋值给transform的eulerAngle\n        B.eulerAngles = new Vector3(0.0f, tSpeed, 0.0f);\n    }\n}\n\n```\n\n## 四元数在Unity Quaternion类实例方法映射\n\n四元数向量的旋转矩阵变换，对于∂方向到ß方向的旋转变换有 SetFromToRotation (  ) 方法，原型是：\n\n```c#\npublic void SetFromToRotion(Vector3 fromDirection,Vector3 toDirection);\n```\n\n如使用其创建旋转实例:\n\n```c#\nusing UnityEngine;\nusing System.Collections;\n \npublic class SetFromToDirection_ts : MonoBehaviour {\n    public Transform A, B, C;\n    Quaternion q = Quaternion.identity;\n    // Use this for initialization\n    void Start () {\n    \n    }\n    \n    // Update is called once per frame\n    void Update () {\n \n        q.SetFromToRotation(A.position, B.position);\n        C.rotation = q;\n        Debug.DrawLine(Vector3.zero, A.position, Color.red);\n        Debug.DrawLine(Vector3.zero, B.position, Color.green);\n        Debug.DrawLine(C.position, C.position + new Vector3(0.0f, 1.0f, 0.0f), Color.black);\n        Debug.DrawLine(C.position, C.TransformPoint(Vector3.up * 1.5f), Color.yellow);\n    }\n}\n```\n\n结果如图示: \n\n![](/rotation.jpg)\n\n### 设置Quaternion实例的朝向\n\n```c#\npublic void SetLookRotation(Vector3 view);\npublic void SetLookRotation(Vector3 view,Vector3 up);\n```\n\n如:\n\n```c#\nQuaternion q = Quaternion.identity;\nq.SetLookRotation(v1,v2);\ntransform.rotation = q;\n```\n\ntransform.forward方向与V1方向相同。\n\ntransform.right垂直于由Vector3.zer0、V1和V2这3点构成的平面。\n\nv2决定了transform.up的朝向，因为当transform.forward和transform.right方向确定后，transform.up的方向总会与V2的方向的夹角小于或等于90度。\n\n当v1为Vector3.zero时，方法失效。\n\n### ToAngleAxis\n\n```c#\npublic void ToAngleAxis(out float angle,out Vector3 axis);\n```\n\n参数angle为旋转角，参数axis为轴向量。\n\n该函数可以实现将GameObject对象的rotation从Quaternion.identity状态变换到当前状态，只需要将GameObject对象绕着axis轴（世界坐标系）旋转angle角度即可。\n\n演示实例:\n\n```c#\nusing UnityEngine;\nusing System.Collections;\n \npublic class ToAngleAxis_ts : MonoBehaviour {\n    public Transform A, B;\n    float angle;\n    Vector3 axis = Vector3.zero;\n    float xSpeed = 0.0f, ySpeed = 0.0f, zSpeed = 0.0f;\n    // Use this for initialization\n    void Start () {\n    \n    }\n    \n    // Update is called once per frame\n    void Update () {\n        xSpeed += 0.5f * Time.deltaTime;\n        ySpeed += 1.0f * Time.deltaTime;\n        zSpeed += 2.5f * Time.deltaTime;\n        A.eulerAngles = new Vector3(xSpeed, ySpeed, zSpeed);\n        //获取A的rotation的旋转轴和角度\n        A.rotation.ToAngleAxis(out angle, out axis);\n        //设置B的rotation，使得B的rotation和A相同\n        B.rotation = Quaternion.AngleAxis(angle, axis);\n    }\n\n```\n\n## Quaternion类静态方法\n\nQuaternion中的静态方法有9个即：Angle方法、Dot方法、Euler方法、FromToRotation方法、Inverse方法、Lerp方法、LookRotation方法、RotateToWards方法和Slerp方法。关于静态的方法的使用就是直接用类名调用其静态方法，例如Quaternion.Angle(q1,q2);下面对这些静态方法做下分析。\n\n1. ### Angle方法\n\n   ```c#\n   public static float Angle(Quaternion a,Quaternion b);\n   ```\n\n   该方法可以计算两个旋转状态a达到b时需要旋转的最小夹角。\n\n   实例演示:\n\n   ```\n   using UnityEngine;\n   using System.Collections;\n    \n   public class Angle_ts : MonoBehaviour {\n      \n    \n       // Use this for initialization\n       void Start () {\n    \n           Quaternion q1 = Quaternion.identity;\n           Quaternion q2 = Quaternion.identity;\n           q1.eulerAngles = new Vector3(30.0f, 40.0f, 50.0f);\n           float a1 = Quaternion.Angle(q1, q2);\n           float a2 = 0.0f;\n           Vector3 v = Vector3.zero;\n           q1.ToAngleAxis(out a2,out v);\n    \n           Debug.Log(\"a1: \" + a1);\n           Debug.Log(\"a2: \" + a2);\n           Debug.Log(\"q1的欧拉角: \" + q1.eulerAngles + \" q1的rotation: \" + q1);\n           Debug.Log(\"q2的欧拉角: \" + q2.eulerAngles + \" q2的rotation: \" + q2);\n       }\n       \n       // Update is called once per frame\n       void Update () {\n       \n       }\n   \n   ```\n\n   结果：\n\n   ![](/show1.png)\n\n   从输出结果可以看出a1和a2的值相等，即Angle的返回值是两个Quaternion实例转换的最小夹角。\n\n2. ### Dot方法-点乘\n\n   ```c#\n   public static float Dot(Quaternion a,Quaternion b);\n   ```\n\n   该方法可以根据点乘的结果，判断a和b对应欧拉角的关系。\n\n   例如有两个Quaternion实例q1(x1,y1,z1,w1)和q2(x2,y2,z2,w2)，则float f = Quaternion.Dot(q1,q2);即f = x1*x2+y1*y2+z1*z2+w1*w2，结果值f的范围为[-1,1]。\n\n   当f=+(-)1时，q1和q2对应的欧拉角是相等的，即旋转状态是一致的。特别地，当f = -1时，说明其中一个rotation比另外一个rotation多旋转了360°。\n\n   实例演示\n\n   ```c#\n   using UnityEngine;\n   using System.Collections;\n    \n   public class Dot_ts : MonoBehaviour {\n      \n       public Transform A, B;\n       Quaternion q1 = Quaternion.identity;\n       Quaternion q2 = Quaternion.identity;\n       // Use this for initialization\n       void Start () {\n    \n           A.eulerAngles = new Vector3(0.0f, 40.0f, 0.0f);\n           B.eulerAngles = new Vector3(0.0f, 360.0f + 40.0f, 0.0f);\n           q1 = A.rotation;\n           q2 = B.rotation;\n           float f = Quaternion.Dot(q1, q2);\n           \n           Debug.Log(\"q1的欧拉角: \" + q1.eulerAngles + \" q1的rotation: \" + q1);\n           Debug.Log(\"q2的欧拉角: \" + q2.eulerAngles + \" q2的rotation: \" + q2);\n           Debug.Log(\"Dot(q1,q2): \" + f);\n       }\n       \n       // Update is called once per frame\n       void Update () {\n       \n       }\n   }\n   ```\n\n   输出:\n\n   ![](/show2.png)\n\n3. ### Euler方法\n\n   ```c#\n   public static Quaternion Euler(Vector3 euler);\n   public static Quaternion Euler(float x,float y,float z);\n   ```\n\n   该方法用于返回欧拉角Vector3(ex,ey,ez)对应的四元数Quaternion q(qx,qy,qz,qw)。其对应关系如下：\n\n   已知PIover180 = 3.141592/180 = 0.0174532925f是计算机图形学中的一个常亮，其变换过程如下：\n\n   ```c#\n   ex = ex * PIover180 / 2.0f;\n   ey = ey * PIover180 / 2.0f;\n   ez = ez * PIover180 / 2.0f;\n    \n   qx = Mathf.Sin(ex) * Mathf.Cos(ey) * Mathf.Cos(ez) + Mathf.Cos(ex) * Mathf.Sin(ey) * Mathf.Sin(ez);\n   qy = Mathf.Cos(ex) * Mathf.Sin(ey) * Mathf.Cos(ez) - Mathf.Sin(ex) * Mathf.Cos(ey) * Mathf.Sin(ez);\n   qz = Mathf.Cos(ex) * Mathf.Cos(ey) * Mathf.Sin(ez) - Mathf.Sin(ex) * Mathf.Sin(ey) * Mathf.Cos(ez);\n   qw = Mathf.Cos(ex) * Mathf.Cos(ey) * Mathf.Cos(ez) + Mathf.Sin(ex) * Mathf.Sin(ey) * Mathf.Sin(ez);\n   ```\n\n   验证变换过程\n\n   ```c#\n   using UnityEngine;\n   using System.Collections;\n    \n   public class Euler_ts : MonoBehaviour {\n    \n       public float ex, ey, ez;\n       float qx, qy, qz,qw;\n       float PIover180 = 0.0174532925f;\n       Quaternion q = Quaternion.identity;\n       Vector3 euler;\n     \n       void OnGUI()\n       {\n           if(GUI.Button(new Rect(10.0f,10.0f,100.0f,45.0f),\"计算\"))\n           {\n               euler = new Vector3(ex,ey,ez);\n               Debug.Log(\"欧拉角Euler(ex,ey,ez): \" + euler);\n               q = Quaternion.Euler(ex, ey, ez);\n               Debug.Log(\"对应的四元数为: \" + q);\n               Debug.Log(\"q.x: \" + q.x + \" q.y: \" + q.y + \" q.z: \" + q.z + \" q.w: \" + q.w);\n               //验证算法\n               ex = ex * PIover180 / 2.0f;\n               ey = ey * PIover180 / 2.0f;\n               ez = ez * PIover180 / 2.0f;\n    \n               qx = Mathf.Sin(ex) * Mathf.Cos(ey) * Mathf.Cos(ez) + Mathf.Cos(ex) * Mathf.Sin(ey) * Mathf.Sin(ez);\n               qy = Mathf.Cos(ex) * Mathf.Sin(ey) * Mathf.Cos(ez) - Mathf.Sin(ex) * Mathf.Cos(ey) * Mathf.Sin(ez);\n               qz = Mathf.Cos(ex) * Mathf.Cos(ey) * Mathf.Sin(ez) - Mathf.Sin(ex) * Mathf.Sin(ey) * Mathf.Cos(ez);\n               qw = Mathf.Cos(ex) * Mathf.Cos(ey) * Mathf.Cos(ez) + Mathf.Sin(ex) * Mathf.Sin(ey) * Mathf.Sin(ez);\n               Debug.Log(\"qx: \" + qx + \" qy: \" + qy + \" qz: \" + qz + \" qw: \" + qw);\n           }\n       }\n   }\n   ```\n\n   运行结果\n\n   ![](/show3.png)\n\n   从输出结果可以证明该公式是正确，另外转换后的四元数直接输出的话，如下：\n\n   ```c#\n   q = Quaternion.Euler(ex, ey, ez);\n    Debug.Log(\"对应的四元数为: \" + q);\n   ```\n\n   输出的值是做了四舍五入处理的。\n\n   \n\n4. ### FromToRotation\n\n   ```c#\n   public static Quaternion FromToRotation(Vector3 fromDirection,Vector3 ToDirection);\n   ```\n\n   在前面介绍了SetFromToRotation实例方法，它们的功能都是一样的只不过用法稍有不同。使用FromToRotation类静态方法，需要直接使用类名进行调用，如Quaternion.FromToRotation(v1,v2);\n\n   在此就不做演示了！\n\n5. ### Inverse方法\n\n   ```c#\n   public static Quaternion Inverse(Quaternion rotation);\n   ```\n\n   该方法可以返回参数rotation的逆向Quaternion值。\n\n   例如rotation(x,y,z,w)，那么Quaternion.Inverse(rotation) = (-x,-y,-z,w)。假设rotation的欧拉角为(a,b,c)，则transform.rotation = Quaternion.Inverse(rotation)相当于transform依次绕自身坐标系的z轴、x轴和y轴分别旋转-c°、-a°和-z°。由于是在局部坐标系内的变换，最后transform的欧拉角的各个分量值并不一定等于-a、-b或-c。\n\n   实例演示:\n\n   ```c#\n   using UnityEngine;\n   using System.Collections;\n    \n   public class Invers_ts : MonoBehaviour {\n       public Transform A, B;\n    \n       // Use this for initialization\n       void Start () {\n    \n           Quaternion q1 = Quaternion.identity;\n           Quaternion q2 = Quaternion.identity;\n           q1.eulerAngles = new Vector3(30.0f,40.0f,50.0f);\n           q2 = Quaternion.Inverse(q1);\n           A.rotation = q1;\n           B.rotation = q2;\n    \n           Debug.Log(\"q1的欧拉角: \" + q1.eulerAngles + \"q1的rotation: \" + q1);\n           Debug.Log(\"q2的欧拉角: \" + q2.eulerAngles + \"q2的rotation: \" + q2);\n       }\n       \n       // Update is called once per frame\n       void Update () {\n       \n       }\n   }\n   \n   ```\n\n   \n\n6. ### Lerp和Slerp方法\n\n   ```c#\n   public static Quaternion Lerp(Quaternion form, Quaternion to,float t);\n   public static Quaternion Slerp(Quaternion form, Quaternion to,float t);\n   ```\n\n   两种方法的作用都是返回从form到to的插值。当参数t<=0时返回值为from，当参数t>=1时返回值为to。其中Lerp是线性差值，而Slerp是球形插值。关于球形差值我会在另外一篇博客里面说。\n\n   实例演示\n\n   ```c#\n   \n   using UnityEngine;\n   using System.Collections;\n    \n   public class LerpAndSlerp_ts : MonoBehaviour\n   {\n       public Transform A, B, C,D;\n       float speed = 0.2f;\n       float total = 0.0f;\n       // Use this for initialization\n       void Start () {\n       \n       }\n       \n       // Update is called once per frame\n       void Update () {\n           total += Time.deltaTime * speed;\n           if(total >= 1.0f)\n               total = 1.0f;\n           C.rotation = Quaternion.Lerp(A.rotation, B.rotation, total);\n           D.rotation = Quaternion.Lerp(A.rotation, B.rotation, total);\n           //C.rotation = Quaternion.Lerp(A.rotation, B.rotation, Time.deltaTime * speed);\n           //D.rotation = Quaternion.Lerp(A.rotation, B.rotation, Time.deltaTime * speed);\n       }\n   \n   }\n   ```\n\n7. ### RotateTowards\n\n   ```c#\n   public static Quaternion RotateTowards(Quaternion from, Quaternion to, float maxDegreesDelta);\n   ```\n\n   该方法也是一个插值方法，即从返回参数from到to的插值，且返回值的最大角度不超过maxDegreesDelta。maxDegreesDelta是角度值，不是插值系数，当maxDegreesDelta < 0时，将进行逆向插值即从to到from的方向进行插值计算。\n\n   ```c#\n   using UnityEngine;\n   using System.Collections;\n    \n   public class RotateToWards_ts : MonoBehaviour {\n    \n       public Transform A, B, C;\n       float speed = 10.0f;\n       float total = 0.0f;\n       // Use this for initialization\n       void Start()\n       {\n    \n       }\n    \n       // Update is called once per frame\n       void Update()\n       {\n           total += Time.deltaTime * speed;\n           if (total >= 1.0f)\n               total = 1.0f;\n           C.rotation = Quaternion.RotateTowards(A.rotation, B.rotation, Time.time * speed - 40.0f);\n           Debug.Log(\"C与A的欧拉角的插值: \" + (C.eulerAngles - A.eulerAngles) + \"maxDegreesDelta: \" + (Time.time * speed - 40.0f));\n    \n       }\n   }\n   ```\n\n   ![](/show4.png)\n\n8. ### LookRotation\n\n   ```c#\n   public static Quaternion LookRotation(Vector3 forward);\n   public static Quaternion LookRotation(Vector3 forward,Vector3 upwards);\n   ```\n\n   参数forward为返回Quaternion实例的forward朝向。该方法和前面讲到的SetLookRotation实例方法的功能是一样的，故不多做阐述了。\n\n## Quaternion类运算符\n\nQuaternion类涉及到两个**Quaternion对象**相乘和**Quaternion**对象与**Vector3**对象相乘，那么就必须重载\"*\"运算符\n\n```c#\npublic static Quaternion operator *(Quaternion lhs, Quaternion rhs);\npublic static Vector3 operator *(Quaternion rotation, Vector3 point);\n```\n\n- ### 两个Quaternion对象相乘\n\n  对于两个Quaternion对象相乘主要用于自身旋转变换，例如：\n\n  ```c#\n  B.rotation *= A.rotation;\n  ```\n\n  - B会绕着B的局部坐标系的z、x、y轴按照先绕z轴再绕x轴最后绕y轴的旋转次序，分别旋转A.eulerAngles.z度、A.eulerAngles.x度、和A.eulerAngles.y度。由于是绕着局部坐标系进行旋转，所以当绕着其中一个轴进行旋转时，可能会影响其余两个坐标轴方向的欧拉角（除非其余两轴的欧拉角都为0才不会受到影响）。\n\n  - 假如A的欧拉角为aEuler(ax,ay,az)，则沿着B的初始局部坐标系的aEuler方向向下看B在绕着aEuler顺时针旋转。B的旋转状况还受到其初始状态的影响。\n\n    实例演示:\n\n    ```c#\n    using UnityEngine;\n    using System.Collections;\n     \n    public class Multiply1_ts : MonoBehaviour {\n     \n        public Transform A, B;\n     \n        // Use this for initialization\n        void Start () {\n     \n            A.eulerAngles = new Vector3(1.0f, 1.5f, 2.0f);\n        }\n        \n        // Update is called once per frame\n        void Update () {\n     \n            B.rotation *= A.rotation;\n            Debug.Log(B.eulerAngles);\n        }\n    }\n    ```\n\n    ![](/show5.png)\n\n    分析：B绕着其自身坐标系的Vector3(1.0f,1.5f,2.0f)方向旋转。虽然每次都绕着这个轴向旋转的角度相同，但角度的旋转在3个坐标轴的值都不为零，三个轴的旋转会相互影响，所以B的欧拉角的各个分量的每次递增是不固定的。\n\n- ### Quaternion对象与Vector3对象\n\n  对于Quaternion对象与Vector3对象相乘主要用于自身移动变换，例如：\n\n  ```c#\n  transform.position += tansform.rotation * A;\n  ```\n\n  其中A为Vector3的对象。transform对应的对象会沿着自身坐标系中向量A的方向移动A的模长的距离。transform.rotation与A相乘可以确定移动的方向和距离。\n\n  实例演示\n\n  ```c#\n  \n  using UnityEngine;\n  using System.Collections;\n   \n  public class Multiply2_ts : MonoBehaviour {\n      public Transform A;\n      float speed = 0.1f;\n   \n      // Use this for initialization\n      void Start () {\n   \n          A.position = Vector3.zero;\n          A.eulerAngles = new Vector3(0.0f, 45.0f, 0.0f);\n      }\n      \n      // Update is called once per frame\n      void Update () {\n   \n          A.position += A.rotation * (Vector3.forward * speed);\n          Debug.Log(A.position);\n      }\n  }\n  ```\n\n  运行截图:\n\n  ![](show6.png)\n\n  \n\n- ### 两个Quaternion对象相乘与Quaternion对象与Vector3对象相乘的异同\n\n  - 设A为两个两个Quaternion对象相乘的结果。B为Quaternion对象与Vector3对象相乘的结果。其中A为Quaternion类型，B为Vector3类型。\n  - A与B的相同之处是它们都通过自身坐标系的“相乘”方式来实现在世界坐标系中的变换。\n  - A主要用来实现transform绕自身坐标系的某个轴旋转，B主要用来实现transform沿着自身坐标系的某个方向移动。\n  - 必须遵守Quaternion对象*Vector3对象的形式，不可以颠倒顺序。\n\n  由于它们都是相对于自身坐标系进行的旋转或移动，所以当自身坐标系的轴向和世界坐标系的轴向不一致时，它们绕着自身坐标系中的某个轴向的变动都会影响到物体在世界坐标系中各个坐标轴的变动。\n\n  　四元数quaternion的变换比较复杂，但是在unity中已经给我们写好了相应的函数实现对transform的操作。\n\n  　　在最近的一个项目中，遇到了一个单手指滑动手机屏幕实现对模型的一个旋转操作，在尝试了各种unity中的旋转函数之后都没能够达到想要的效果之后，我选择了用Quaternion.AngleAxis的函数来实现旋转的操作效果。\n\n  　　首先我们来分析一下Quaternion.AngleAxis(angle,axis)，参数angle和axis代表了物体的旋转角度和旋转轴心。如下图：红色箭头方向代表物体所围绕的旋转轴，旋转角度可以是自定义的。\n\n  ![](/show7.jpg)\n\n  接下来，我们就要做两件事情，确定axis和计算angle。在这个项目中，我们是根据单个手指在手机屏幕上滑动，我们通过记录滑动的距离，X方向的增量，以及Y轴方向的增量来为后面计算axis和angle打下基础。unity的Input函数有GetTouch这个函数，我们只需要调用这个函数的相关方法就可以实现需求。\n\n  　　现在，我们在unity中新建一个场景，在场景中新建一个立方块。\n\n  ![](/show8.png)\n\n  注意立方块的世界坐标轴，Z轴的朝向应该是朝着摄像机的。根据之前对四元数脚本的分析，立方体的旋转脚本为：\n\n  　　Gesture.cs:\n\n  ```c#\n  using UnityEngine;\n   2 using System.Collections;\n   3 \n   4 public class gesture : MonoBehaviour {\n   5     public Transform Cube;\n   6     private float radius = 1080;\n   7     private Vector3 originalDir = new Vector3(0f,0f,1080f);\n   8     private Vector3 CenterPos = new Vector3(0, 0, 0);\n   9     private Vector2 startPos;\n  10     private Vector2 tempPos;\n  11     private Vector3 tempVec;\n  12     private Vector3 normalAxis;\n  13     private float angle;\n  14     // Use this for initialization\n  15     void Start () {\n  16         Cube = GameObject.Find(\"Cube\").transform;\n  17     }\n  18     \n  19     // Update is called once per frame\n  20     void Update () {\n  21         if (Input.touchCount == 1)\n  22         {\n  23             //Vector2 startPos = Input.compositionCursorPos;\n  24             if (Input.GetTouch(0).phase == TouchPhase.Began)\n  25             {\n  26                 startPos = Input.GetTouch(0).position;\n  27                 //tempPos = startPos;\n  28             }\n  29             //if (Input.GetTouch(0).phase == TouchPhase.Ended)\n  30             //{\n  31             //    tempPos = startPos;\n  32             //}\n  33             if (Input.GetTouch(0).phase == TouchPhase.Moved)\n  34             {\n  35                 tempPos = Event.current.mousePosition;\n  36 \n  37                 float tempX = tempPos.x - startPos.x;\n  38                     \n  39                 float tempY = tempPos.y - startPos.y;\n  40 \n  41                 //tempPos = Input.GetTouch(0).deltaPosition;\n  42                 //float tempX = tempPos.x;\n  43 \n  44                 //float tempY = tempPos.y;\n  45 \n  46                 float tempZ = Mathf.Sqrt(radius * radius - tempX * tempX - tempY * tempY);\n  47 \n  48                 tempVec = new Vector3(tempX, tempY, tempZ);\n  49 \n  50                 angle = Mathf.Acos(Vector3.Dot(originalDir.normalized, tempVec.normalized)) * Mathf.Rad2Deg;\n  51 \n  52                 normalAxis = getNormal(CenterPos, originalDir, tempVec);\n  53 \n  54                 Cube.rotation = Quaternion.AngleAxis(2 *angle, normalAxis);\n  55 \n  56             }\n  57         }\n  58     }\n  59 \n  60     void OnGUI()\n  61     {\n  62         GUILayout.Label(\"StartPos 的坐标值为： \"+startPos);\n  63         GUILayout.Label(\"tempPos 的坐标值为： \" + tempPos);\n  64         GUILayout.Label(\"tempVec 的坐标值为： \" + tempVec);\n  65         GUILayout.Label(\"normalAxis 的坐标值为： \" + normalAxis);\n  66         GUILayout.Label(\"旋转角度的值为： \" + 2*angle);\n  67         GUILayout.Label(\"Cube的四元数角度： \" + Cube.rotation);\n  68         GUILayout.Label(\"Cube de rotation.x： \" + Cube.rotation.eulerAngles.x);\n  69         GUILayout.Label(\"Cube de rotation.y： \" + Cube.rotation.eulerAngles.y);\n  70         GUILayout.Label(\"Cube de rotation.z： \" + Cube.rotation.eulerAngles.z);\n  71     }\n  72 \n  73     private Vector3 getNormal(Vector3 p1,Vector3 p2,Vector3 p3)\n  74     {\n  75         float a = ((p2.y - p1.y) * (p3.z - p1.z) - (p2.z - p1.z) * (p3.y - p1.y));\n  76 \n  77         float b = ((p2.z - p1.z) * (p3.x - p1.x) - (p2.x - p1.x) * (p3.z - p1.z));\n  78 \n  79         float c = ((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n  80         //a对应的屏幕的垂直方向，b对应的屏幕的水平方向。\n  81         return new Vector3(a, -b, c);\n  82     }\n  83 }\n  ```\n\n  如果我们将这个在新机上运行，会发现在第一次手指滑动旋转是正常的，但是第二次就会有个跳动的过程。在这里我们需要注意一个问题，四元数函数Quaternion.AngleAxis是将立方体以初始的旋转角度来进行围绕着轴Axis旋转Angle角度，不是在上一个状态下的增量。如果需要延续上一次的旋转状态，就需要将这个物体的rotation恢复到初始的状态。按照这个思路，我在Cube添加了一个父对象，我们在操作的时候对这个父对象进行操作，然后手指在离开屏幕的时候，将Cube脱离父对象，然后将父对象的rotation进行还原，再将Cube绑定为父物体的子对象，在一下次手指旋转之后就会接着上一次的旋转状态进行旋转，实现了旋转的延续。\n\n  ![](/show9.png)\n\n  实现的代码为：\n\n  ```c#\n  using UnityEngine;\n   2 using System.Collections;\n   3 \n   4 public class gesture : MonoBehaviour {\n   5     public Transform Cube;\n   6     public Transform RotObj;\n   7     private float radius = 1080;\n   8     private Vector3 originalDir = new Vector3(0f,0f,1080f);\n   9     private Vector3 CenterPos = new Vector3(0, 0, 0);\n  10     private Vector2 startPos;\n  11     private Vector2 tempPos;\n  12     private Vector3 tempVec;\n  13     private Vector3 normalAxis;\n  14     private float angle;\n  15     // Use this for initialization\n  16     void Start () {\n  17         Cube = GameObject.Find(\"Cube\").transform;\n  18     }\n  19     \n  20     // Update is called once per frame\n  21     void Update () {\n  22         if (Input.touchCount == 1)\n  23         {\n  24             //Vector2 startPos = Input.compositionCursorPos;\n  25             if (Input.GetTouch(0).phase == TouchPhase.Began)\n  26             {\n  27                 startPos = Input.GetTouch(0).position;\n  28             }\n  29             if (Input.GetTouch(0).phase == TouchPhase.Moved)\n  30             {\n  31                 tempPos = Event.current.mousePosition;\n  32 \n  33                 float tempX = tempPos.x - startPos.x;\n  34                     \n  35                 float tempY = tempPos.y - startPos.y;\n  36 \n  37                 float tempZ = Mathf.Sqrt(radius * radius - tempX * tempX - tempY * tempY);\n  38 \n  39                 tempVec = new Vector3(tempX, tempY, tempZ);\n  40 \n  41                 angle = Mathf.Acos(Vector3.Dot(originalDir.normalized, tempVec.normalized)) * Mathf.Rad2Deg;\n  42 \n  43                 normalAxis = getNormal(CenterPos, originalDir, tempVec);\n  44 \n  45                 RotObj.rotation = Quaternion.AngleAxis(2 *angle, normalAxis);\n  46 \n  47             }\n  48             if (Input.GetTouch(0).phase == TouchPhase.Ended)\n  49             {\n  50                 Cube.transform.parent = null;\n  51                 RotObj.rotation = Quaternion.identity;\n  52                 Cube.parent = RotObj;\n  53             }\n  54         }\n  55     }\n  56 \n  57     void OnGUI()\n  58     {\n  59         GUILayout.Label(\"StartPos 的坐标值为： \"+startPos);\n  60         GUILayout.Label(\"tempPos 的坐标值为： \" + tempPos);\n  61         GUILayout.Label(\"tempVec 的坐标值为： \" + tempVec);\n  62         GUILayout.Label(\"normalAxis 的坐标值为： \" + normalAxis);\n  63         GUILayout.Label(\"旋转角度的值为： \" + 2*angle);\n  64         GUILayout.Label(\"Cube的四元数角度： \" + Cube.rotation);\n  65         GUILayout.Label(\"Cube de rotation.x： \" + Cube.rotation.eulerAngles.x);\n  66         GUILayout.Label(\"Cube de rotation.y： \" + Cube.rotation.eulerAngles.y);\n  67         GUILayout.Label(\"Cube de rotation.z： \" + Cube.rotation.eulerAngles.z);\n  68     }\n  69 \n  70     private Vector3 getNormal(Vector3 p1,Vector3 p2,Vector3 p3)\n  71     {\n  72         float a = ((p2.y - p1.y) * (p3.z - p1.z) - (p2.z - p1.z) * (p3.y - p1.y));\n  73 \n  74         float b = ((p2.z - p1.z) * (p3.x - p1.x) - (p2.x - p1.x) * (p3.z - p1.z));\n  75 \n  76         float c = ((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n  77         //a对应的屏幕的垂直方向，b对应的屏幕的水平方向。\n  78         return new Vector3(a, -b, c);\n  79     }\n  80 }\n  ```\n\n  现在对应着手指的滑动距离，然后调整参数radius，就可以实现比较顺滑的旋转效果，真机实现的效果就不展示了。\n\n老实说，图形学里面数学部分比较难懂的四元数应该算是一个，嗯，就到这吧。","source":"_posts/游戏中的四元数.md","raw":"---\ntitle: 游戏中的四元数\ndate: 2020-01-07 15:30:26\ntags: [Unity,游戏开发,图形学]\ncategories: 游戏栈\n---\n\n![](/start.png)\n\n## 四元数简介\n\nQuaternion又称四元数，由x,y,z和w这四个分量组成，是由爱尔兰数学家威廉·卢云·哈密顿在1843年发现的数学概念。四元数的乘法不符合交换律。从明确地角度而言，四元数是复数的不可交换延伸。如把四元数的集合考虑成多维实数空间的话，四元数就代表着一个四维空间，相对于复数为二维空间。\n\n在实际的图示如下：\n\n![](/show.jpg)\n\n说实话关于四元数这一节真的是不好懂，因为里面涉及到好多数学知识，单说推出来的公式就有很多。不怕大家笑话，对于四元数的学习我足足花了两天的时间，包括整理出这篇文章。在前面一章我写到了“变换”，这也是总结的学习笔记。我发现，写博客真是的是一个好多学习方法，加上之前一个博士师兄告诉我，要想好好的学习一本书或者一门技术，那么以此将学习笔记或者经验写成博客专栏是一种有效的方法。现在我要坚持这种方式，给自己留下学习过程中的足迹，也给大家分享一下。欢迎大家指出其中的不足，谢谢！\n\n四元数是表示旋转的另一种数学形式，使用四元数可以节省存储空间，其之间的连接运算需要的算术运算更少，在产生平滑的三维动画时，用四元数更容易进行修改。\n\n四元数集合，在数学上被称为哈密顿四元数环(ring of Hamiltonian quaternions)，用H表示，可以理解为四维空间向量，空间中的元素q可以表示为：\n\nq = (x,y,z,w) = w + xi +yj + zk;\n\n也可以用实数和向量的形式进行表示，即：\n\nq = w + v;其中w是实数部分，v是v(x,y,z)。\n\n四元数集合是复数集合的自然扩展。四元数的乘法服从分配率。\n\n每个图形引擎都避免不了四元数的讨论，Unity游戏引擎的四元数类封装的比较好。\n\n## Quaternion类属性\n\n##### eulerAngles-欧拉角\n\n定义：\n\n```c#\npublic Vector3 eulerAngles{get;set;}\n```\n\n  如何改变一个游戏对象旋的转状态，我们可以通过改变其Transform进行欧拉角的变换次序，例如假设p(x,y,z)是游戏对象上的一个点，绕x轴旋转a角，绕y轴旋转b角，绕z轴旋转c角，这样就可以得到旋转之后的状态p'(x',y',z')。\n\n​\tUnity的实现过程是很简单的，一句代码就可以搞定。但是具体的实现过程确实很复杂的,涉及到很多矩阵的运算，这里就不过多的介绍。\n\n​\t下面给出一个例子，演示一下如何使用欧拉角。\n\n```c#\n\nusing UnityEngine;\nusing System.Collections;\n \npublic class EulerAngler_ts : MonoBehaviour {\n    public Transform A, B;\n    Quaternion rotations = Quaternion.identity;\n    Vector3 eulerAngle = Vector3.zero;\n    float speed = 10.0f;\n    float tSpeed = 0.0f;\n    // Use this for initialization\n    void Start () {\n \n    }\n    \n    // Update is called once per frame\n    void Update () {\n        tSpeed += speed * Time.deltaTime;\n        //第一种方式：将Quaternion实例对象赋值给transform的rotation\n        rotations.eulerAngles = new Vector3(0.0f, tSpeed, 0.0f);\n        A.rotation = rotations;\n        //第二种方式：将三位向量代表的欧拉角直接赋值给transform的eulerAngle\n        B.eulerAngles = new Vector3(0.0f, tSpeed, 0.0f);\n    }\n}\n\n```\n\n## 四元数在Unity Quaternion类实例方法映射\n\n四元数向量的旋转矩阵变换，对于∂方向到ß方向的旋转变换有 SetFromToRotation (  ) 方法，原型是：\n\n```c#\npublic void SetFromToRotion(Vector3 fromDirection,Vector3 toDirection);\n```\n\n如使用其创建旋转实例:\n\n```c#\nusing UnityEngine;\nusing System.Collections;\n \npublic class SetFromToDirection_ts : MonoBehaviour {\n    public Transform A, B, C;\n    Quaternion q = Quaternion.identity;\n    // Use this for initialization\n    void Start () {\n    \n    }\n    \n    // Update is called once per frame\n    void Update () {\n \n        q.SetFromToRotation(A.position, B.position);\n        C.rotation = q;\n        Debug.DrawLine(Vector3.zero, A.position, Color.red);\n        Debug.DrawLine(Vector3.zero, B.position, Color.green);\n        Debug.DrawLine(C.position, C.position + new Vector3(0.0f, 1.0f, 0.0f), Color.black);\n        Debug.DrawLine(C.position, C.TransformPoint(Vector3.up * 1.5f), Color.yellow);\n    }\n}\n```\n\n结果如图示: \n\n![](/rotation.jpg)\n\n### 设置Quaternion实例的朝向\n\n```c#\npublic void SetLookRotation(Vector3 view);\npublic void SetLookRotation(Vector3 view,Vector3 up);\n```\n\n如:\n\n```c#\nQuaternion q = Quaternion.identity;\nq.SetLookRotation(v1,v2);\ntransform.rotation = q;\n```\n\ntransform.forward方向与V1方向相同。\n\ntransform.right垂直于由Vector3.zer0、V1和V2这3点构成的平面。\n\nv2决定了transform.up的朝向，因为当transform.forward和transform.right方向确定后，transform.up的方向总会与V2的方向的夹角小于或等于90度。\n\n当v1为Vector3.zero时，方法失效。\n\n### ToAngleAxis\n\n```c#\npublic void ToAngleAxis(out float angle,out Vector3 axis);\n```\n\n参数angle为旋转角，参数axis为轴向量。\n\n该函数可以实现将GameObject对象的rotation从Quaternion.identity状态变换到当前状态，只需要将GameObject对象绕着axis轴（世界坐标系）旋转angle角度即可。\n\n演示实例:\n\n```c#\nusing UnityEngine;\nusing System.Collections;\n \npublic class ToAngleAxis_ts : MonoBehaviour {\n    public Transform A, B;\n    float angle;\n    Vector3 axis = Vector3.zero;\n    float xSpeed = 0.0f, ySpeed = 0.0f, zSpeed = 0.0f;\n    // Use this for initialization\n    void Start () {\n    \n    }\n    \n    // Update is called once per frame\n    void Update () {\n        xSpeed += 0.5f * Time.deltaTime;\n        ySpeed += 1.0f * Time.deltaTime;\n        zSpeed += 2.5f * Time.deltaTime;\n        A.eulerAngles = new Vector3(xSpeed, ySpeed, zSpeed);\n        //获取A的rotation的旋转轴和角度\n        A.rotation.ToAngleAxis(out angle, out axis);\n        //设置B的rotation，使得B的rotation和A相同\n        B.rotation = Quaternion.AngleAxis(angle, axis);\n    }\n\n```\n\n## Quaternion类静态方法\n\nQuaternion中的静态方法有9个即：Angle方法、Dot方法、Euler方法、FromToRotation方法、Inverse方法、Lerp方法、LookRotation方法、RotateToWards方法和Slerp方法。关于静态的方法的使用就是直接用类名调用其静态方法，例如Quaternion.Angle(q1,q2);下面对这些静态方法做下分析。\n\n1. ### Angle方法\n\n   ```c#\n   public static float Angle(Quaternion a,Quaternion b);\n   ```\n\n   该方法可以计算两个旋转状态a达到b时需要旋转的最小夹角。\n\n   实例演示:\n\n   ```\n   using UnityEngine;\n   using System.Collections;\n    \n   public class Angle_ts : MonoBehaviour {\n      \n    \n       // Use this for initialization\n       void Start () {\n    \n           Quaternion q1 = Quaternion.identity;\n           Quaternion q2 = Quaternion.identity;\n           q1.eulerAngles = new Vector3(30.0f, 40.0f, 50.0f);\n           float a1 = Quaternion.Angle(q1, q2);\n           float a2 = 0.0f;\n           Vector3 v = Vector3.zero;\n           q1.ToAngleAxis(out a2,out v);\n    \n           Debug.Log(\"a1: \" + a1);\n           Debug.Log(\"a2: \" + a2);\n           Debug.Log(\"q1的欧拉角: \" + q1.eulerAngles + \" q1的rotation: \" + q1);\n           Debug.Log(\"q2的欧拉角: \" + q2.eulerAngles + \" q2的rotation: \" + q2);\n       }\n       \n       // Update is called once per frame\n       void Update () {\n       \n       }\n   \n   ```\n\n   结果：\n\n   ![](/show1.png)\n\n   从输出结果可以看出a1和a2的值相等，即Angle的返回值是两个Quaternion实例转换的最小夹角。\n\n2. ### Dot方法-点乘\n\n   ```c#\n   public static float Dot(Quaternion a,Quaternion b);\n   ```\n\n   该方法可以根据点乘的结果，判断a和b对应欧拉角的关系。\n\n   例如有两个Quaternion实例q1(x1,y1,z1,w1)和q2(x2,y2,z2,w2)，则float f = Quaternion.Dot(q1,q2);即f = x1*x2+y1*y2+z1*z2+w1*w2，结果值f的范围为[-1,1]。\n\n   当f=+(-)1时，q1和q2对应的欧拉角是相等的，即旋转状态是一致的。特别地，当f = -1时，说明其中一个rotation比另外一个rotation多旋转了360°。\n\n   实例演示\n\n   ```c#\n   using UnityEngine;\n   using System.Collections;\n    \n   public class Dot_ts : MonoBehaviour {\n      \n       public Transform A, B;\n       Quaternion q1 = Quaternion.identity;\n       Quaternion q2 = Quaternion.identity;\n       // Use this for initialization\n       void Start () {\n    \n           A.eulerAngles = new Vector3(0.0f, 40.0f, 0.0f);\n           B.eulerAngles = new Vector3(0.0f, 360.0f + 40.0f, 0.0f);\n           q1 = A.rotation;\n           q2 = B.rotation;\n           float f = Quaternion.Dot(q1, q2);\n           \n           Debug.Log(\"q1的欧拉角: \" + q1.eulerAngles + \" q1的rotation: \" + q1);\n           Debug.Log(\"q2的欧拉角: \" + q2.eulerAngles + \" q2的rotation: \" + q2);\n           Debug.Log(\"Dot(q1,q2): \" + f);\n       }\n       \n       // Update is called once per frame\n       void Update () {\n       \n       }\n   }\n   ```\n\n   输出:\n\n   ![](/show2.png)\n\n3. ### Euler方法\n\n   ```c#\n   public static Quaternion Euler(Vector3 euler);\n   public static Quaternion Euler(float x,float y,float z);\n   ```\n\n   该方法用于返回欧拉角Vector3(ex,ey,ez)对应的四元数Quaternion q(qx,qy,qz,qw)。其对应关系如下：\n\n   已知PIover180 = 3.141592/180 = 0.0174532925f是计算机图形学中的一个常亮，其变换过程如下：\n\n   ```c#\n   ex = ex * PIover180 / 2.0f;\n   ey = ey * PIover180 / 2.0f;\n   ez = ez * PIover180 / 2.0f;\n    \n   qx = Mathf.Sin(ex) * Mathf.Cos(ey) * Mathf.Cos(ez) + Mathf.Cos(ex) * Mathf.Sin(ey) * Mathf.Sin(ez);\n   qy = Mathf.Cos(ex) * Mathf.Sin(ey) * Mathf.Cos(ez) - Mathf.Sin(ex) * Mathf.Cos(ey) * Mathf.Sin(ez);\n   qz = Mathf.Cos(ex) * Mathf.Cos(ey) * Mathf.Sin(ez) - Mathf.Sin(ex) * Mathf.Sin(ey) * Mathf.Cos(ez);\n   qw = Mathf.Cos(ex) * Mathf.Cos(ey) * Mathf.Cos(ez) + Mathf.Sin(ex) * Mathf.Sin(ey) * Mathf.Sin(ez);\n   ```\n\n   验证变换过程\n\n   ```c#\n   using UnityEngine;\n   using System.Collections;\n    \n   public class Euler_ts : MonoBehaviour {\n    \n       public float ex, ey, ez;\n       float qx, qy, qz,qw;\n       float PIover180 = 0.0174532925f;\n       Quaternion q = Quaternion.identity;\n       Vector3 euler;\n     \n       void OnGUI()\n       {\n           if(GUI.Button(new Rect(10.0f,10.0f,100.0f,45.0f),\"计算\"))\n           {\n               euler = new Vector3(ex,ey,ez);\n               Debug.Log(\"欧拉角Euler(ex,ey,ez): \" + euler);\n               q = Quaternion.Euler(ex, ey, ez);\n               Debug.Log(\"对应的四元数为: \" + q);\n               Debug.Log(\"q.x: \" + q.x + \" q.y: \" + q.y + \" q.z: \" + q.z + \" q.w: \" + q.w);\n               //验证算法\n               ex = ex * PIover180 / 2.0f;\n               ey = ey * PIover180 / 2.0f;\n               ez = ez * PIover180 / 2.0f;\n    \n               qx = Mathf.Sin(ex) * Mathf.Cos(ey) * Mathf.Cos(ez) + Mathf.Cos(ex) * Mathf.Sin(ey) * Mathf.Sin(ez);\n               qy = Mathf.Cos(ex) * Mathf.Sin(ey) * Mathf.Cos(ez) - Mathf.Sin(ex) * Mathf.Cos(ey) * Mathf.Sin(ez);\n               qz = Mathf.Cos(ex) * Mathf.Cos(ey) * Mathf.Sin(ez) - Mathf.Sin(ex) * Mathf.Sin(ey) * Mathf.Cos(ez);\n               qw = Mathf.Cos(ex) * Mathf.Cos(ey) * Mathf.Cos(ez) + Mathf.Sin(ex) * Mathf.Sin(ey) * Mathf.Sin(ez);\n               Debug.Log(\"qx: \" + qx + \" qy: \" + qy + \" qz: \" + qz + \" qw: \" + qw);\n           }\n       }\n   }\n   ```\n\n   运行结果\n\n   ![](/show3.png)\n\n   从输出结果可以证明该公式是正确，另外转换后的四元数直接输出的话，如下：\n\n   ```c#\n   q = Quaternion.Euler(ex, ey, ez);\n    Debug.Log(\"对应的四元数为: \" + q);\n   ```\n\n   输出的值是做了四舍五入处理的。\n\n   \n\n4. ### FromToRotation\n\n   ```c#\n   public static Quaternion FromToRotation(Vector3 fromDirection,Vector3 ToDirection);\n   ```\n\n   在前面介绍了SetFromToRotation实例方法，它们的功能都是一样的只不过用法稍有不同。使用FromToRotation类静态方法，需要直接使用类名进行调用，如Quaternion.FromToRotation(v1,v2);\n\n   在此就不做演示了！\n\n5. ### Inverse方法\n\n   ```c#\n   public static Quaternion Inverse(Quaternion rotation);\n   ```\n\n   该方法可以返回参数rotation的逆向Quaternion值。\n\n   例如rotation(x,y,z,w)，那么Quaternion.Inverse(rotation) = (-x,-y,-z,w)。假设rotation的欧拉角为(a,b,c)，则transform.rotation = Quaternion.Inverse(rotation)相当于transform依次绕自身坐标系的z轴、x轴和y轴分别旋转-c°、-a°和-z°。由于是在局部坐标系内的变换，最后transform的欧拉角的各个分量值并不一定等于-a、-b或-c。\n\n   实例演示:\n\n   ```c#\n   using UnityEngine;\n   using System.Collections;\n    \n   public class Invers_ts : MonoBehaviour {\n       public Transform A, B;\n    \n       // Use this for initialization\n       void Start () {\n    \n           Quaternion q1 = Quaternion.identity;\n           Quaternion q2 = Quaternion.identity;\n           q1.eulerAngles = new Vector3(30.0f,40.0f,50.0f);\n           q2 = Quaternion.Inverse(q1);\n           A.rotation = q1;\n           B.rotation = q2;\n    \n           Debug.Log(\"q1的欧拉角: \" + q1.eulerAngles + \"q1的rotation: \" + q1);\n           Debug.Log(\"q2的欧拉角: \" + q2.eulerAngles + \"q2的rotation: \" + q2);\n       }\n       \n       // Update is called once per frame\n       void Update () {\n       \n       }\n   }\n   \n   ```\n\n   \n\n6. ### Lerp和Slerp方法\n\n   ```c#\n   public static Quaternion Lerp(Quaternion form, Quaternion to,float t);\n   public static Quaternion Slerp(Quaternion form, Quaternion to,float t);\n   ```\n\n   两种方法的作用都是返回从form到to的插值。当参数t<=0时返回值为from，当参数t>=1时返回值为to。其中Lerp是线性差值，而Slerp是球形插值。关于球形差值我会在另外一篇博客里面说。\n\n   实例演示\n\n   ```c#\n   \n   using UnityEngine;\n   using System.Collections;\n    \n   public class LerpAndSlerp_ts : MonoBehaviour\n   {\n       public Transform A, B, C,D;\n       float speed = 0.2f;\n       float total = 0.0f;\n       // Use this for initialization\n       void Start () {\n       \n       }\n       \n       // Update is called once per frame\n       void Update () {\n           total += Time.deltaTime * speed;\n           if(total >= 1.0f)\n               total = 1.0f;\n           C.rotation = Quaternion.Lerp(A.rotation, B.rotation, total);\n           D.rotation = Quaternion.Lerp(A.rotation, B.rotation, total);\n           //C.rotation = Quaternion.Lerp(A.rotation, B.rotation, Time.deltaTime * speed);\n           //D.rotation = Quaternion.Lerp(A.rotation, B.rotation, Time.deltaTime * speed);\n       }\n   \n   }\n   ```\n\n7. ### RotateTowards\n\n   ```c#\n   public static Quaternion RotateTowards(Quaternion from, Quaternion to, float maxDegreesDelta);\n   ```\n\n   该方法也是一个插值方法，即从返回参数from到to的插值，且返回值的最大角度不超过maxDegreesDelta。maxDegreesDelta是角度值，不是插值系数，当maxDegreesDelta < 0时，将进行逆向插值即从to到from的方向进行插值计算。\n\n   ```c#\n   using UnityEngine;\n   using System.Collections;\n    \n   public class RotateToWards_ts : MonoBehaviour {\n    \n       public Transform A, B, C;\n       float speed = 10.0f;\n       float total = 0.0f;\n       // Use this for initialization\n       void Start()\n       {\n    \n       }\n    \n       // Update is called once per frame\n       void Update()\n       {\n           total += Time.deltaTime * speed;\n           if (total >= 1.0f)\n               total = 1.0f;\n           C.rotation = Quaternion.RotateTowards(A.rotation, B.rotation, Time.time * speed - 40.0f);\n           Debug.Log(\"C与A的欧拉角的插值: \" + (C.eulerAngles - A.eulerAngles) + \"maxDegreesDelta: \" + (Time.time * speed - 40.0f));\n    \n       }\n   }\n   ```\n\n   ![](/show4.png)\n\n8. ### LookRotation\n\n   ```c#\n   public static Quaternion LookRotation(Vector3 forward);\n   public static Quaternion LookRotation(Vector3 forward,Vector3 upwards);\n   ```\n\n   参数forward为返回Quaternion实例的forward朝向。该方法和前面讲到的SetLookRotation实例方法的功能是一样的，故不多做阐述了。\n\n## Quaternion类运算符\n\nQuaternion类涉及到两个**Quaternion对象**相乘和**Quaternion**对象与**Vector3**对象相乘，那么就必须重载\"*\"运算符\n\n```c#\npublic static Quaternion operator *(Quaternion lhs, Quaternion rhs);\npublic static Vector3 operator *(Quaternion rotation, Vector3 point);\n```\n\n- ### 两个Quaternion对象相乘\n\n  对于两个Quaternion对象相乘主要用于自身旋转变换，例如：\n\n  ```c#\n  B.rotation *= A.rotation;\n  ```\n\n  - B会绕着B的局部坐标系的z、x、y轴按照先绕z轴再绕x轴最后绕y轴的旋转次序，分别旋转A.eulerAngles.z度、A.eulerAngles.x度、和A.eulerAngles.y度。由于是绕着局部坐标系进行旋转，所以当绕着其中一个轴进行旋转时，可能会影响其余两个坐标轴方向的欧拉角（除非其余两轴的欧拉角都为0才不会受到影响）。\n\n  - 假如A的欧拉角为aEuler(ax,ay,az)，则沿着B的初始局部坐标系的aEuler方向向下看B在绕着aEuler顺时针旋转。B的旋转状况还受到其初始状态的影响。\n\n    实例演示:\n\n    ```c#\n    using UnityEngine;\n    using System.Collections;\n     \n    public class Multiply1_ts : MonoBehaviour {\n     \n        public Transform A, B;\n     \n        // Use this for initialization\n        void Start () {\n     \n            A.eulerAngles = new Vector3(1.0f, 1.5f, 2.0f);\n        }\n        \n        // Update is called once per frame\n        void Update () {\n     \n            B.rotation *= A.rotation;\n            Debug.Log(B.eulerAngles);\n        }\n    }\n    ```\n\n    ![](/show5.png)\n\n    分析：B绕着其自身坐标系的Vector3(1.0f,1.5f,2.0f)方向旋转。虽然每次都绕着这个轴向旋转的角度相同，但角度的旋转在3个坐标轴的值都不为零，三个轴的旋转会相互影响，所以B的欧拉角的各个分量的每次递增是不固定的。\n\n- ### Quaternion对象与Vector3对象\n\n  对于Quaternion对象与Vector3对象相乘主要用于自身移动变换，例如：\n\n  ```c#\n  transform.position += tansform.rotation * A;\n  ```\n\n  其中A为Vector3的对象。transform对应的对象会沿着自身坐标系中向量A的方向移动A的模长的距离。transform.rotation与A相乘可以确定移动的方向和距离。\n\n  实例演示\n\n  ```c#\n  \n  using UnityEngine;\n  using System.Collections;\n   \n  public class Multiply2_ts : MonoBehaviour {\n      public Transform A;\n      float speed = 0.1f;\n   \n      // Use this for initialization\n      void Start () {\n   \n          A.position = Vector3.zero;\n          A.eulerAngles = new Vector3(0.0f, 45.0f, 0.0f);\n      }\n      \n      // Update is called once per frame\n      void Update () {\n   \n          A.position += A.rotation * (Vector3.forward * speed);\n          Debug.Log(A.position);\n      }\n  }\n  ```\n\n  运行截图:\n\n  ![](show6.png)\n\n  \n\n- ### 两个Quaternion对象相乘与Quaternion对象与Vector3对象相乘的异同\n\n  - 设A为两个两个Quaternion对象相乘的结果。B为Quaternion对象与Vector3对象相乘的结果。其中A为Quaternion类型，B为Vector3类型。\n  - A与B的相同之处是它们都通过自身坐标系的“相乘”方式来实现在世界坐标系中的变换。\n  - A主要用来实现transform绕自身坐标系的某个轴旋转，B主要用来实现transform沿着自身坐标系的某个方向移动。\n  - 必须遵守Quaternion对象*Vector3对象的形式，不可以颠倒顺序。\n\n  由于它们都是相对于自身坐标系进行的旋转或移动，所以当自身坐标系的轴向和世界坐标系的轴向不一致时，它们绕着自身坐标系中的某个轴向的变动都会影响到物体在世界坐标系中各个坐标轴的变动。\n\n  　四元数quaternion的变换比较复杂，但是在unity中已经给我们写好了相应的函数实现对transform的操作。\n\n  　　在最近的一个项目中，遇到了一个单手指滑动手机屏幕实现对模型的一个旋转操作，在尝试了各种unity中的旋转函数之后都没能够达到想要的效果之后，我选择了用Quaternion.AngleAxis的函数来实现旋转的操作效果。\n\n  　　首先我们来分析一下Quaternion.AngleAxis(angle,axis)，参数angle和axis代表了物体的旋转角度和旋转轴心。如下图：红色箭头方向代表物体所围绕的旋转轴，旋转角度可以是自定义的。\n\n  ![](/show7.jpg)\n\n  接下来，我们就要做两件事情，确定axis和计算angle。在这个项目中，我们是根据单个手指在手机屏幕上滑动，我们通过记录滑动的距离，X方向的增量，以及Y轴方向的增量来为后面计算axis和angle打下基础。unity的Input函数有GetTouch这个函数，我们只需要调用这个函数的相关方法就可以实现需求。\n\n  　　现在，我们在unity中新建一个场景，在场景中新建一个立方块。\n\n  ![](/show8.png)\n\n  注意立方块的世界坐标轴，Z轴的朝向应该是朝着摄像机的。根据之前对四元数脚本的分析，立方体的旋转脚本为：\n\n  　　Gesture.cs:\n\n  ```c#\n  using UnityEngine;\n   2 using System.Collections;\n   3 \n   4 public class gesture : MonoBehaviour {\n   5     public Transform Cube;\n   6     private float radius = 1080;\n   7     private Vector3 originalDir = new Vector3(0f,0f,1080f);\n   8     private Vector3 CenterPos = new Vector3(0, 0, 0);\n   9     private Vector2 startPos;\n  10     private Vector2 tempPos;\n  11     private Vector3 tempVec;\n  12     private Vector3 normalAxis;\n  13     private float angle;\n  14     // Use this for initialization\n  15     void Start () {\n  16         Cube = GameObject.Find(\"Cube\").transform;\n  17     }\n  18     \n  19     // Update is called once per frame\n  20     void Update () {\n  21         if (Input.touchCount == 1)\n  22         {\n  23             //Vector2 startPos = Input.compositionCursorPos;\n  24             if (Input.GetTouch(0).phase == TouchPhase.Began)\n  25             {\n  26                 startPos = Input.GetTouch(0).position;\n  27                 //tempPos = startPos;\n  28             }\n  29             //if (Input.GetTouch(0).phase == TouchPhase.Ended)\n  30             //{\n  31             //    tempPos = startPos;\n  32             //}\n  33             if (Input.GetTouch(0).phase == TouchPhase.Moved)\n  34             {\n  35                 tempPos = Event.current.mousePosition;\n  36 \n  37                 float tempX = tempPos.x - startPos.x;\n  38                     \n  39                 float tempY = tempPos.y - startPos.y;\n  40 \n  41                 //tempPos = Input.GetTouch(0).deltaPosition;\n  42                 //float tempX = tempPos.x;\n  43 \n  44                 //float tempY = tempPos.y;\n  45 \n  46                 float tempZ = Mathf.Sqrt(radius * radius - tempX * tempX - tempY * tempY);\n  47 \n  48                 tempVec = new Vector3(tempX, tempY, tempZ);\n  49 \n  50                 angle = Mathf.Acos(Vector3.Dot(originalDir.normalized, tempVec.normalized)) * Mathf.Rad2Deg;\n  51 \n  52                 normalAxis = getNormal(CenterPos, originalDir, tempVec);\n  53 \n  54                 Cube.rotation = Quaternion.AngleAxis(2 *angle, normalAxis);\n  55 \n  56             }\n  57         }\n  58     }\n  59 \n  60     void OnGUI()\n  61     {\n  62         GUILayout.Label(\"StartPos 的坐标值为： \"+startPos);\n  63         GUILayout.Label(\"tempPos 的坐标值为： \" + tempPos);\n  64         GUILayout.Label(\"tempVec 的坐标值为： \" + tempVec);\n  65         GUILayout.Label(\"normalAxis 的坐标值为： \" + normalAxis);\n  66         GUILayout.Label(\"旋转角度的值为： \" + 2*angle);\n  67         GUILayout.Label(\"Cube的四元数角度： \" + Cube.rotation);\n  68         GUILayout.Label(\"Cube de rotation.x： \" + Cube.rotation.eulerAngles.x);\n  69         GUILayout.Label(\"Cube de rotation.y： \" + Cube.rotation.eulerAngles.y);\n  70         GUILayout.Label(\"Cube de rotation.z： \" + Cube.rotation.eulerAngles.z);\n  71     }\n  72 \n  73     private Vector3 getNormal(Vector3 p1,Vector3 p2,Vector3 p3)\n  74     {\n  75         float a = ((p2.y - p1.y) * (p3.z - p1.z) - (p2.z - p1.z) * (p3.y - p1.y));\n  76 \n  77         float b = ((p2.z - p1.z) * (p3.x - p1.x) - (p2.x - p1.x) * (p3.z - p1.z));\n  78 \n  79         float c = ((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n  80         //a对应的屏幕的垂直方向，b对应的屏幕的水平方向。\n  81         return new Vector3(a, -b, c);\n  82     }\n  83 }\n  ```\n\n  如果我们将这个在新机上运行，会发现在第一次手指滑动旋转是正常的，但是第二次就会有个跳动的过程。在这里我们需要注意一个问题，四元数函数Quaternion.AngleAxis是将立方体以初始的旋转角度来进行围绕着轴Axis旋转Angle角度，不是在上一个状态下的增量。如果需要延续上一次的旋转状态，就需要将这个物体的rotation恢复到初始的状态。按照这个思路，我在Cube添加了一个父对象，我们在操作的时候对这个父对象进行操作，然后手指在离开屏幕的时候，将Cube脱离父对象，然后将父对象的rotation进行还原，再将Cube绑定为父物体的子对象，在一下次手指旋转之后就会接着上一次的旋转状态进行旋转，实现了旋转的延续。\n\n  ![](/show9.png)\n\n  实现的代码为：\n\n  ```c#\n  using UnityEngine;\n   2 using System.Collections;\n   3 \n   4 public class gesture : MonoBehaviour {\n   5     public Transform Cube;\n   6     public Transform RotObj;\n   7     private float radius = 1080;\n   8     private Vector3 originalDir = new Vector3(0f,0f,1080f);\n   9     private Vector3 CenterPos = new Vector3(0, 0, 0);\n  10     private Vector2 startPos;\n  11     private Vector2 tempPos;\n  12     private Vector3 tempVec;\n  13     private Vector3 normalAxis;\n  14     private float angle;\n  15     // Use this for initialization\n  16     void Start () {\n  17         Cube = GameObject.Find(\"Cube\").transform;\n  18     }\n  19     \n  20     // Update is called once per frame\n  21     void Update () {\n  22         if (Input.touchCount == 1)\n  23         {\n  24             //Vector2 startPos = Input.compositionCursorPos;\n  25             if (Input.GetTouch(0).phase == TouchPhase.Began)\n  26             {\n  27                 startPos = Input.GetTouch(0).position;\n  28             }\n  29             if (Input.GetTouch(0).phase == TouchPhase.Moved)\n  30             {\n  31                 tempPos = Event.current.mousePosition;\n  32 \n  33                 float tempX = tempPos.x - startPos.x;\n  34                     \n  35                 float tempY = tempPos.y - startPos.y;\n  36 \n  37                 float tempZ = Mathf.Sqrt(radius * radius - tempX * tempX - tempY * tempY);\n  38 \n  39                 tempVec = new Vector3(tempX, tempY, tempZ);\n  40 \n  41                 angle = Mathf.Acos(Vector3.Dot(originalDir.normalized, tempVec.normalized)) * Mathf.Rad2Deg;\n  42 \n  43                 normalAxis = getNormal(CenterPos, originalDir, tempVec);\n  44 \n  45                 RotObj.rotation = Quaternion.AngleAxis(2 *angle, normalAxis);\n  46 \n  47             }\n  48             if (Input.GetTouch(0).phase == TouchPhase.Ended)\n  49             {\n  50                 Cube.transform.parent = null;\n  51                 RotObj.rotation = Quaternion.identity;\n  52                 Cube.parent = RotObj;\n  53             }\n  54         }\n  55     }\n  56 \n  57     void OnGUI()\n  58     {\n  59         GUILayout.Label(\"StartPos 的坐标值为： \"+startPos);\n  60         GUILayout.Label(\"tempPos 的坐标值为： \" + tempPos);\n  61         GUILayout.Label(\"tempVec 的坐标值为： \" + tempVec);\n  62         GUILayout.Label(\"normalAxis 的坐标值为： \" + normalAxis);\n  63         GUILayout.Label(\"旋转角度的值为： \" + 2*angle);\n  64         GUILayout.Label(\"Cube的四元数角度： \" + Cube.rotation);\n  65         GUILayout.Label(\"Cube de rotation.x： \" + Cube.rotation.eulerAngles.x);\n  66         GUILayout.Label(\"Cube de rotation.y： \" + Cube.rotation.eulerAngles.y);\n  67         GUILayout.Label(\"Cube de rotation.z： \" + Cube.rotation.eulerAngles.z);\n  68     }\n  69 \n  70     private Vector3 getNormal(Vector3 p1,Vector3 p2,Vector3 p3)\n  71     {\n  72         float a = ((p2.y - p1.y) * (p3.z - p1.z) - (p2.z - p1.z) * (p3.y - p1.y));\n  73 \n  74         float b = ((p2.z - p1.z) * (p3.x - p1.x) - (p2.x - p1.x) * (p3.z - p1.z));\n  75 \n  76         float c = ((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n  77         //a对应的屏幕的垂直方向，b对应的屏幕的水平方向。\n  78         return new Vector3(a, -b, c);\n  79     }\n  80 }\n  ```\n\n  现在对应着手指的滑动距离，然后调整参数radius，就可以实现比较顺滑的旋转效果，真机实现的效果就不展示了。\n\n老实说，图形学里面数学部分比较难懂的四元数应该算是一个，嗯，就到这吧。","slug":"游戏中的四元数","published":1,"updated":"2020-02-07T05:34:11.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rju001wzd5bfc6o9v3i","content":"<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/start.png\" alt></p>\n<h2 id=\"四元数简介\"><a href=\"#四元数简介\" class=\"headerlink\" title=\"四元数简介\"></a>四元数简介</h2><p>Quaternion又称四元数，由x,y,z和w这四个分量组成，是由爱尔兰数学家威廉·卢云·哈密顿在1843年发现的数学概念。四元数的乘法不符合交换律。从明确地角度而言，四元数是复数的不可交换延伸。如把四元数的集合考虑成多维实数空间的话，四元数就代表着一个四维空间，相对于复数为二维空间。</p>\n<p>在实际的图示如下：</p>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show.jpg\" alt></p>\n<p>说实话关于四元数这一节真的是不好懂，因为里面涉及到好多数学知识，单说推出来的公式就有很多。不怕大家笑话，对于四元数的学习我足足花了两天的时间，包括整理出这篇文章。在前面一章我写到了“变换”，这也是总结的学习笔记。我发现，写博客真是的是一个好多学习方法，加上之前一个博士师兄告诉我，要想好好的学习一本书或者一门技术，那么以此将学习笔记或者经验写成博客专栏是一种有效的方法。现在我要坚持这种方式，给自己留下学习过程中的足迹，也给大家分享一下。欢迎大家指出其中的不足，谢谢！</p>\n<p>四元数是表示旋转的另一种数学形式，使用四元数可以节省存储空间，其之间的连接运算需要的算术运算更少，在产生平滑的三维动画时，用四元数更容易进行修改。</p>\n<p>四元数集合，在数学上被称为哈密顿四元数环(ring of Hamiltonian quaternions)，用H表示，可以理解为四维空间向量，空间中的元素q可以表示为：</p>\n<p>q = (x,y,z,w) = w + xi +yj + zk;</p>\n<p>也可以用实数和向量的形式进行表示，即：</p>\n<p>q = w + v;其中w是实数部分，v是v(x,y,z)。</p>\n<p>四元数集合是复数集合的自然扩展。四元数的乘法服从分配率。</p>\n<p>每个图形引擎都避免不了四元数的讨论，Unity游戏引擎的四元数类封装的比较好。</p>\n<h2 id=\"Quaternion类属性\"><a href=\"#Quaternion类属性\" class=\"headerlink\" title=\"Quaternion类属性\"></a>Quaternion类属性</h2><h5 id=\"eulerAngles-欧拉角\"><a href=\"#eulerAngles-欧拉角\" class=\"headerlink\" title=\"eulerAngles-欧拉角\"></a>eulerAngles-欧拉角</h5><p>定义：</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">public Vector3 eulerAngles{get;set;}</code></pre>\n<p>  如何改变一个游戏对象旋的转状态，我们可以通过改变其Transform进行欧拉角的变换次序，例如假设p(x,y,z)是游戏对象上的一个点，绕x轴旋转a角，绕y轴旋转b角，绕z轴旋转c角，这样就可以得到旋转之后的状态p’(x’,y’,z’)。</p>\n<p>​    Unity的实现过程是很简单的，一句代码就可以搞定。但是具体的实现过程确实很复杂的,涉及到很多矩阵的运算，这里就不过多的介绍。</p>\n<p>​    下面给出一个例子，演示一下如何使用欧拉角。</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">\nusing UnityEngine;\nusing System.Collections;\n\npublic class EulerAngler_ts : MonoBehaviour {\n    public Transform A, B;\n    Quaternion rotations = Quaternion.identity;\n    Vector3 eulerAngle = Vector3.zero;\n    float speed = 10.0f;\n    float tSpeed = 0.0f;\n    // Use this for initialization\n    void Start () {\n\n    }\n\n    // Update is called once per frame\n    void Update () {\n        tSpeed += speed * Time.deltaTime;\n        //第一种方式：将Quaternion实例对象赋值给transform的rotation\n        rotations.eulerAngles = new Vector3(0.0f, tSpeed, 0.0f);\n        A.rotation = rotations;\n        //第二种方式：将三位向量代表的欧拉角直接赋值给transform的eulerAngle\n        B.eulerAngles = new Vector3(0.0f, tSpeed, 0.0f);\n    }\n}\n</code></pre>\n<h2 id=\"四元数在Unity-Quaternion类实例方法映射\"><a href=\"#四元数在Unity-Quaternion类实例方法映射\" class=\"headerlink\" title=\"四元数在Unity Quaternion类实例方法映射\"></a>四元数在Unity Quaternion类实例方法映射</h2><p>四元数向量的旋转矩阵变换，对于∂方向到ß方向的旋转变换有 SetFromToRotation (  ) 方法，原型是：</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">public void SetFromToRotion(Vector3 fromDirection,Vector3 toDirection);</code></pre>\n<p>如使用其创建旋转实例:</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">using UnityEngine;\nusing System.Collections;\n\npublic class SetFromToDirection_ts : MonoBehaviour {\n    public Transform A, B, C;\n    Quaternion q = Quaternion.identity;\n    // Use this for initialization\n    void Start () {\n\n    }\n\n    // Update is called once per frame\n    void Update () {\n\n        q.SetFromToRotation(A.position, B.position);\n        C.rotation = q;\n        Debug.DrawLine(Vector3.zero, A.position, Color.red);\n        Debug.DrawLine(Vector3.zero, B.position, Color.green);\n        Debug.DrawLine(C.position, C.position + new Vector3(0.0f, 1.0f, 0.0f), Color.black);\n        Debug.DrawLine(C.position, C.TransformPoint(Vector3.up * 1.5f), Color.yellow);\n    }\n}</code></pre>\n<p>结果如图示: </p>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/rotation.jpg\" alt></p>\n<h3 id=\"设置Quaternion实例的朝向\"><a href=\"#设置Quaternion实例的朝向\" class=\"headerlink\" title=\"设置Quaternion实例的朝向\"></a>设置Quaternion实例的朝向</h3><pre class=\" language-c#\"><code class=\"language-c#\">public void SetLookRotation(Vector3 view);\npublic void SetLookRotation(Vector3 view,Vector3 up);</code></pre>\n<p>如:</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">Quaternion q = Quaternion.identity;\nq.SetLookRotation(v1,v2);\ntransform.rotation = q;</code></pre>\n<p>transform.forward方向与V1方向相同。</p>\n<p>transform.right垂直于由Vector3.zer0、V1和V2这3点构成的平面。</p>\n<p>v2决定了transform.up的朝向，因为当transform.forward和transform.right方向确定后，transform.up的方向总会与V2的方向的夹角小于或等于90度。</p>\n<p>当v1为Vector3.zero时，方法失效。</p>\n<h3 id=\"ToAngleAxis\"><a href=\"#ToAngleAxis\" class=\"headerlink\" title=\"ToAngleAxis\"></a>ToAngleAxis</h3><pre class=\" language-c#\"><code class=\"language-c#\">public void ToAngleAxis(out float angle,out Vector3 axis);</code></pre>\n<p>参数angle为旋转角，参数axis为轴向量。</p>\n<p>该函数可以实现将GameObject对象的rotation从Quaternion.identity状态变换到当前状态，只需要将GameObject对象绕着axis轴（世界坐标系）旋转angle角度即可。</p>\n<p>演示实例:</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">using UnityEngine;\nusing System.Collections;\n\npublic class ToAngleAxis_ts : MonoBehaviour {\n    public Transform A, B;\n    float angle;\n    Vector3 axis = Vector3.zero;\n    float xSpeed = 0.0f, ySpeed = 0.0f, zSpeed = 0.0f;\n    // Use this for initialization\n    void Start () {\n\n    }\n\n    // Update is called once per frame\n    void Update () {\n        xSpeed += 0.5f * Time.deltaTime;\n        ySpeed += 1.0f * Time.deltaTime;\n        zSpeed += 2.5f * Time.deltaTime;\n        A.eulerAngles = new Vector3(xSpeed, ySpeed, zSpeed);\n        //获取A的rotation的旋转轴和角度\n        A.rotation.ToAngleAxis(out angle, out axis);\n        //设置B的rotation，使得B的rotation和A相同\n        B.rotation = Quaternion.AngleAxis(angle, axis);\n    }\n</code></pre>\n<h2 id=\"Quaternion类静态方法\"><a href=\"#Quaternion类静态方法\" class=\"headerlink\" title=\"Quaternion类静态方法\"></a>Quaternion类静态方法</h2><p>Quaternion中的静态方法有9个即：Angle方法、Dot方法、Euler方法、FromToRotation方法、Inverse方法、Lerp方法、LookRotation方法、RotateToWards方法和Slerp方法。关于静态的方法的使用就是直接用类名调用其静态方法，例如Quaternion.Angle(q1,q2);下面对这些静态方法做下分析。</p>\n<ol>\n<li><h3 id=\"Angle方法\"><a href=\"#Angle方法\" class=\"headerlink\" title=\"Angle方法\"></a>Angle方法</h3><pre class=\" language-c#\"><code class=\"language-c#\">public static float Angle(Quaternion a,Quaternion b);</code></pre>\n<p>该方法可以计算两个旋转状态a达到b时需要旋转的最小夹角。</p>\n<p>实例演示:</p>\n<pre><code>using UnityEngine;\nusing System.Collections;\n\npublic class Angle_ts : MonoBehaviour {\n\n</code></pre></li>\n</ol>\n<pre><code>   // Use this for initialization\n   void Start () {\n\n       Quaternion q1 = Quaternion.identity;\n       Quaternion q2 = Quaternion.identity;\n       q1.eulerAngles = new Vector3(30.0f, 40.0f, 50.0f);\n       float a1 = Quaternion.Angle(q1, q2);\n       float a2 = 0.0f;\n       Vector3 v = Vector3.zero;\n       q1.ToAngleAxis(out a2,out v);\n\n       Debug.Log(&quot;a1: &quot; + a1);\n       Debug.Log(&quot;a2: &quot; + a2);\n       Debug.Log(&quot;q1的欧拉角: &quot; + q1.eulerAngles + &quot; q1的rotation: &quot; + q1);\n       Debug.Log(&quot;q2的欧拉角: &quot; + q2.eulerAngles + &quot; q2的rotation: &quot; + q2);\n   }\n\n   // Update is called once per frame\n   void Update () {\n\n   }</code></pre><pre><code>\n   结果：\n\n   ![](/show1.png)\n\n   从输出结果可以看出a1和a2的值相等，即Angle的返回值是两个Quaternion实例转换的最小夹角。\n\n2. ### Dot方法-点乘\n\n   ```c#\n   public static float Dot(Quaternion a,Quaternion b);</code></pre><p>   该方法可以根据点乘的结果，判断a和b对应欧拉角的关系。</p>\n<p>   例如有两个Quaternion实例q1(x1,y1,z1,w1)和q2(x2,y2,z2,w2)，则float f = Quaternion.Dot(q1,q2);即f = x1<em>x2+y1</em>y2+z1<em>z2+w1</em>w2，结果值f的范围为[-1,1]。</p>\n<p>   当f=+(-)1时，q1和q2对应的欧拉角是相等的，即旋转状态是一致的。特别地，当f = -1时，说明其中一个rotation比另外一个rotation多旋转了360°。</p>\n<p>   实例演示</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">   using UnityEngine;\n   using System.Collections;\n\n   public class Dot_ts : MonoBehaviour {\n\n       public Transform A, B;\n       Quaternion q1 = Quaternion.identity;\n       Quaternion q2 = Quaternion.identity;\n       // Use this for initialization\n       void Start () {\n\n           A.eulerAngles = new Vector3(0.0f, 40.0f, 0.0f);\n           B.eulerAngles = new Vector3(0.0f, 360.0f + 40.0f, 0.0f);\n           q1 = A.rotation;\n           q2 = B.rotation;\n           float f = Quaternion.Dot(q1, q2);\n\n           Debug.Log(\"q1的欧拉角: \" + q1.eulerAngles + \" q1的rotation: \" + q1);\n           Debug.Log(\"q2的欧拉角: \" + q2.eulerAngles + \" q2的rotation: \" + q2);\n           Debug.Log(\"Dot(q1,q2): \" + f);\n       }\n\n       // Update is called once per frame\n       void Update () {\n\n       }\n   }</code></pre>\n<p>   输出:</p>\n<p>   <img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show2.png\" alt></p>\n<ol start=\"3\">\n<li><h3 id=\"Euler方法\"><a href=\"#Euler方法\" class=\"headerlink\" title=\"Euler方法\"></a>Euler方法</h3><pre class=\" language-c#\"><code class=\"language-c#\">public static Quaternion Euler(Vector3 euler);\npublic static Quaternion Euler(float x,float y,float z);</code></pre>\n<p>该方法用于返回欧拉角Vector3(ex,ey,ez)对应的四元数Quaternion q(qx,qy,qz,qw)。其对应关系如下：</p>\n<p>已知PIover180 = 3.141592/180 = 0.0174532925f是计算机图形学中的一个常亮，其变换过程如下：</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">ex = ex * PIover180 / 2.0f;\ney = ey * PIover180 / 2.0f;\nez = ez * PIover180 / 2.0f;\n\nqx = Mathf.Sin(ex) * Mathf.Cos(ey) * Mathf.Cos(ez) + Mathf.Cos(ex) * Mathf.Sin(ey) * Mathf.Sin(ez);\nqy = Mathf.Cos(ex) * Mathf.Sin(ey) * Mathf.Cos(ez) - Mathf.Sin(ex) * Mathf.Cos(ey) * Mathf.Sin(ez);\nqz = Mathf.Cos(ex) * Mathf.Cos(ey) * Mathf.Sin(ez) - Mathf.Sin(ex) * Mathf.Sin(ey) * Mathf.Cos(ez);\nqw = Mathf.Cos(ex) * Mathf.Cos(ey) * Mathf.Cos(ez) + Mathf.Sin(ex) * Mathf.Sin(ey) * Mathf.Sin(ez);</code></pre>\n<p>验证变换过程</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">using UnityEngine;\nusing System.Collections;\n\npublic class Euler_ts : MonoBehaviour {\n\n    public float ex, ey, ez;\n    float qx, qy, qz,qw;\n    float PIover180 = 0.0174532925f;\n    Quaternion q = Quaternion.identity;\n    Vector3 euler;\n\n    void OnGUI()\n    {\n        if(GUI.Button(new Rect(10.0f,10.0f,100.0f,45.0f),\"计算\"))\n        {\n            euler = new Vector3(ex,ey,ez);\n            Debug.Log(\"欧拉角Euler(ex,ey,ez): \" + euler);\n            q = Quaternion.Euler(ex, ey, ez);\n            Debug.Log(\"对应的四元数为: \" + q);\n            Debug.Log(\"q.x: \" + q.x + \" q.y: \" + q.y + \" q.z: \" + q.z + \" q.w: \" + q.w);\n            //验证算法\n            ex = ex * PIover180 / 2.0f;\n            ey = ey * PIover180 / 2.0f;\n            ez = ez * PIover180 / 2.0f;\n\n            qx = Mathf.Sin(ex) * Mathf.Cos(ey) * Mathf.Cos(ez) + Mathf.Cos(ex) * Mathf.Sin(ey) * Mathf.Sin(ez);\n            qy = Mathf.Cos(ex) * Mathf.Sin(ey) * Mathf.Cos(ez) - Mathf.Sin(ex) * Mathf.Cos(ey) * Mathf.Sin(ez);\n            qz = Mathf.Cos(ex) * Mathf.Cos(ey) * Mathf.Sin(ez) - Mathf.Sin(ex) * Mathf.Sin(ey) * Mathf.Cos(ez);\n            qw = Mathf.Cos(ex) * Mathf.Cos(ey) * Mathf.Cos(ez) + Mathf.Sin(ex) * Mathf.Sin(ey) * Mathf.Sin(ez);\n            Debug.Log(\"qx: \" + qx + \" qy: \" + qy + \" qz: \" + qz + \" qw: \" + qw);\n        }\n    }\n}</code></pre>\n<p>运行结果</p>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show3.png\" alt></p>\n<p>从输出结果可以证明该公式是正确，另外转换后的四元数直接输出的话，如下：</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">q = Quaternion.Euler(ex, ey, ez);\n Debug.Log(\"对应的四元数为: \" + q);</code></pre>\n<p>输出的值是做了四舍五入处理的。</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li><h3 id=\"FromToRotation\"><a href=\"#FromToRotation\" class=\"headerlink\" title=\"FromToRotation\"></a>FromToRotation</h3><pre class=\" language-c#\"><code class=\"language-c#\">public static Quaternion FromToRotation(Vector3 fromDirection,Vector3 ToDirection);</code></pre>\n<p>在前面介绍了SetFromToRotation实例方法，它们的功能都是一样的只不过用法稍有不同。使用FromToRotation类静态方法，需要直接使用类名进行调用，如Quaternion.FromToRotation(v1,v2);</p>\n<p>在此就不做演示了！</p>\n</li>\n<li><h3 id=\"Inverse方法\"><a href=\"#Inverse方法\" class=\"headerlink\" title=\"Inverse方法\"></a>Inverse方法</h3><pre class=\" language-c#\"><code class=\"language-c#\">public static Quaternion Inverse(Quaternion rotation);</code></pre>\n<p>该方法可以返回参数rotation的逆向Quaternion值。</p>\n<p>例如rotation(x,y,z,w)，那么Quaternion.Inverse(rotation) = (-x,-y,-z,w)。假设rotation的欧拉角为(a,b,c)，则transform.rotation = Quaternion.Inverse(rotation)相当于transform依次绕自身坐标系的z轴、x轴和y轴分别旋转-c°、-a°和-z°。由于是在局部坐标系内的变换，最后transform的欧拉角的各个分量值并不一定等于-a、-b或-c。</p>\n<p>实例演示:</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">using UnityEngine;\nusing System.Collections;\n\npublic class Invers_ts : MonoBehaviour {\n    public Transform A, B;\n\n    // Use this for initialization\n    void Start () {\n\n        Quaternion q1 = Quaternion.identity;\n        Quaternion q2 = Quaternion.identity;\n        q1.eulerAngles = new Vector3(30.0f,40.0f,50.0f);\n        q2 = Quaternion.Inverse(q1);\n        A.rotation = q1;\n        B.rotation = q2;\n\n        Debug.Log(\"q1的欧拉角: \" + q1.eulerAngles + \"q1的rotation: \" + q1);\n        Debug.Log(\"q2的欧拉角: \" + q2.eulerAngles + \"q2的rotation: \" + q2);\n    }\n\n    // Update is called once per frame\n    void Update () {\n\n    }\n}\n</code></pre>\n</li>\n</ol>\n<ol start=\"6\">\n<li><h3 id=\"Lerp和Slerp方法\"><a href=\"#Lerp和Slerp方法\" class=\"headerlink\" title=\"Lerp和Slerp方法\"></a>Lerp和Slerp方法</h3><pre class=\" language-c#\"><code class=\"language-c#\">public static Quaternion Lerp(Quaternion form, Quaternion to,float t);\npublic static Quaternion Slerp(Quaternion form, Quaternion to,float t);</code></pre>\n<p>两种方法的作用都是返回从form到to的插值。当参数t&lt;=0时返回值为from，当参数t&gt;=1时返回值为to。其中Lerp是线性差值，而Slerp是球形插值。关于球形差值我会在另外一篇博客里面说。</p>\n<p>实例演示</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">\nusing UnityEngine;\nusing System.Collections;\n\npublic class LerpAndSlerp_ts : MonoBehaviour\n{\n    public Transform A, B, C,D;\n    float speed = 0.2f;\n    float total = 0.0f;\n    // Use this for initialization\n    void Start () {\n\n    }\n\n    // Update is called once per frame\n    void Update () {\n        total += Time.deltaTime * speed;\n        if(total >= 1.0f)\n            total = 1.0f;\n        C.rotation = Quaternion.Lerp(A.rotation, B.rotation, total);\n        D.rotation = Quaternion.Lerp(A.rotation, B.rotation, total);\n        //C.rotation = Quaternion.Lerp(A.rotation, B.rotation, Time.deltaTime * speed);\n        //D.rotation = Quaternion.Lerp(A.rotation, B.rotation, Time.deltaTime * speed);\n    }\n\n}</code></pre>\n</li>\n<li><h3 id=\"RotateTowards\"><a href=\"#RotateTowards\" class=\"headerlink\" title=\"RotateTowards\"></a>RotateTowards</h3><pre class=\" language-c#\"><code class=\"language-c#\">public static Quaternion RotateTowards(Quaternion from, Quaternion to, float maxDegreesDelta);</code></pre>\n<p>该方法也是一个插值方法，即从返回参数from到to的插值，且返回值的最大角度不超过maxDegreesDelta。maxDegreesDelta是角度值，不是插值系数，当maxDegreesDelta &lt; 0时，将进行逆向插值即从to到from的方向进行插值计算。</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">using UnityEngine;\nusing System.Collections;\n\npublic class RotateToWards_ts : MonoBehaviour {\n\n    public Transform A, B, C;\n    float speed = 10.0f;\n    float total = 0.0f;\n    // Use this for initialization\n    void Start()\n    {\n\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        total += Time.deltaTime * speed;\n        if (total >= 1.0f)\n            total = 1.0f;\n        C.rotation = Quaternion.RotateTowards(A.rotation, B.rotation, Time.time * speed - 40.0f);\n        Debug.Log(\"C与A的欧拉角的插值: \" + (C.eulerAngles - A.eulerAngles) + \"maxDegreesDelta: \" + (Time.time * speed - 40.0f));\n\n    }\n}</code></pre>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show4.png\" alt></p>\n</li>\n<li><h3 id=\"LookRotation\"><a href=\"#LookRotation\" class=\"headerlink\" title=\"LookRotation\"></a>LookRotation</h3><pre class=\" language-c#\"><code class=\"language-c#\">public static Quaternion LookRotation(Vector3 forward);\npublic static Quaternion LookRotation(Vector3 forward,Vector3 upwards);</code></pre>\n<p>参数forward为返回Quaternion实例的forward朝向。该方法和前面讲到的SetLookRotation实例方法的功能是一样的，故不多做阐述了。</p>\n</li>\n</ol>\n<h2 id=\"Quaternion类运算符\"><a href=\"#Quaternion类运算符\" class=\"headerlink\" title=\"Quaternion类运算符\"></a>Quaternion类运算符</h2><p>Quaternion类涉及到两个<strong>Quaternion对象</strong>相乘和<strong>Quaternion</strong>对象与<strong>Vector3</strong>对象相乘，那么就必须重载”*”运算符</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">public static Quaternion operator *(Quaternion lhs, Quaternion rhs);\npublic static Vector3 operator *(Quaternion rotation, Vector3 point);</code></pre>\n<ul>\n<li><h3 id=\"两个Quaternion对象相乘\"><a href=\"#两个Quaternion对象相乘\" class=\"headerlink\" title=\"两个Quaternion对象相乘\"></a>两个Quaternion对象相乘</h3><p>对于两个Quaternion对象相乘主要用于自身旋转变换，例如：</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">B.rotation *= A.rotation;</code></pre>\n<ul>\n<li><p>B会绕着B的局部坐标系的z、x、y轴按照先绕z轴再绕x轴最后绕y轴的旋转次序，分别旋转A.eulerAngles.z度、A.eulerAngles.x度、和A.eulerAngles.y度。由于是绕着局部坐标系进行旋转，所以当绕着其中一个轴进行旋转时，可能会影响其余两个坐标轴方向的欧拉角（除非其余两轴的欧拉角都为0才不会受到影响）。</p>\n</li>\n<li><p>假如A的欧拉角为aEuler(ax,ay,az)，则沿着B的初始局部坐标系的aEuler方向向下看B在绕着aEuler顺时针旋转。B的旋转状况还受到其初始状态的影响。</p>\n<p>实例演示:</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">using UnityEngine;\nusing System.Collections;\n\npublic class Multiply1_ts : MonoBehaviour {\n\n    public Transform A, B;\n\n    // Use this for initialization\n    void Start () {\n\n        A.eulerAngles = new Vector3(1.0f, 1.5f, 2.0f);\n    }\n\n    // Update is called once per frame\n    void Update () {\n\n        B.rotation *= A.rotation;\n        Debug.Log(B.eulerAngles);\n    }\n}</code></pre>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show5.png\" alt></p>\n<p>分析：B绕着其自身坐标系的Vector3(1.0f,1.5f,2.0f)方向旋转。虽然每次都绕着这个轴向旋转的角度相同，但角度的旋转在3个坐标轴的值都不为零，三个轴的旋转会相互影响，所以B的欧拉角的各个分量的每次递增是不固定的。</p>\n</li>\n</ul>\n</li>\n<li><h3 id=\"Quaternion对象与Vector3对象\"><a href=\"#Quaternion对象与Vector3对象\" class=\"headerlink\" title=\"Quaternion对象与Vector3对象\"></a>Quaternion对象与Vector3对象</h3><p>对于Quaternion对象与Vector3对象相乘主要用于自身移动变换，例如：</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">transform.position += tansform.rotation * A;</code></pre>\n<p>其中A为Vector3的对象。transform对应的对象会沿着自身坐标系中向量A的方向移动A的模长的距离。transform.rotation与A相乘可以确定移动的方向和距离。</p>\n<p>实例演示</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">\nusing UnityEngine;\nusing System.Collections;\n\npublic class Multiply2_ts : MonoBehaviour {\n    public Transform A;\n    float speed = 0.1f;\n\n    // Use this for initialization\n    void Start () {\n\n        A.position = Vector3.zero;\n        A.eulerAngles = new Vector3(0.0f, 45.0f, 0.0f);\n    }\n\n    // Update is called once per frame\n    void Update () {\n\n        A.position += A.rotation * (Vector3.forward * speed);\n        Debug.Log(A.position);\n    }\n}</code></pre>\n<p>运行截图:</p>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show6.png\" alt></p>\n</li>\n</ul>\n<ul>\n<li><h3 id=\"两个Quaternion对象相乘与Quaternion对象与Vector3对象相乘的异同\"><a href=\"#两个Quaternion对象相乘与Quaternion对象与Vector3对象相乘的异同\" class=\"headerlink\" title=\"两个Quaternion对象相乘与Quaternion对象与Vector3对象相乘的异同\"></a>两个Quaternion对象相乘与Quaternion对象与Vector3对象相乘的异同</h3><ul>\n<li>设A为两个两个Quaternion对象相乘的结果。B为Quaternion对象与Vector3对象相乘的结果。其中A为Quaternion类型，B为Vector3类型。</li>\n<li>A与B的相同之处是它们都通过自身坐标系的“相乘”方式来实现在世界坐标系中的变换。</li>\n<li>A主要用来实现transform绕自身坐标系的某个轴旋转，B主要用来实现transform沿着自身坐标系的某个方向移动。</li>\n<li>必须遵守Quaternion对象*Vector3对象的形式，不可以颠倒顺序。</li>\n</ul>\n<p>由于它们都是相对于自身坐标系进行的旋转或移动，所以当自身坐标系的轴向和世界坐标系的轴向不一致时，它们绕着自身坐标系中的某个轴向的变动都会影响到物体在世界坐标系中各个坐标轴的变动。</p>\n<p>　四元数quaternion的变换比较复杂，但是在unity中已经给我们写好了相应的函数实现对transform的操作。</p>\n<p>　　在最近的一个项目中，遇到了一个单手指滑动手机屏幕实现对模型的一个旋转操作，在尝试了各种unity中的旋转函数之后都没能够达到想要的效果之后，我选择了用Quaternion.AngleAxis的函数来实现旋转的操作效果。</p>\n<p>　　首先我们来分析一下Quaternion.AngleAxis(angle,axis)，参数angle和axis代表了物体的旋转角度和旋转轴心。如下图：红色箭头方向代表物体所围绕的旋转轴，旋转角度可以是自定义的。</p>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show7.jpg\" alt></p>\n<p>接下来，我们就要做两件事情，确定axis和计算angle。在这个项目中，我们是根据单个手指在手机屏幕上滑动，我们通过记录滑动的距离，X方向的增量，以及Y轴方向的增量来为后面计算axis和angle打下基础。unity的Input函数有GetTouch这个函数，我们只需要调用这个函数的相关方法就可以实现需求。</p>\n<p>　　现在，我们在unity中新建一个场景，在场景中新建一个立方块。</p>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show8.png\" alt></p>\n<p>注意立方块的世界坐标轴，Z轴的朝向应该是朝着摄像机的。根据之前对四元数脚本的分析，立方体的旋转脚本为：</p>\n<p>　　Gesture.cs:</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">using UnityEngine;\n 2 using System.Collections;\n 3 \n 4 public class gesture : MonoBehaviour {\n 5     public Transform Cube;\n 6     private float radius = 1080;\n 7     private Vector3 originalDir = new Vector3(0f,0f,1080f);\n 8     private Vector3 CenterPos = new Vector3(0, 0, 0);\n 9     private Vector2 startPos;\n10     private Vector2 tempPos;\n11     private Vector3 tempVec;\n12     private Vector3 normalAxis;\n13     private float angle;\n14     // Use this for initialization\n15     void Start () {\n16         Cube = GameObject.Find(\"Cube\").transform;\n17     }\n18     \n19     // Update is called once per frame\n20     void Update () {\n21         if (Input.touchCount == 1)\n22         {\n23             //Vector2 startPos = Input.compositionCursorPos;\n24             if (Input.GetTouch(0).phase == TouchPhase.Began)\n25             {\n26                 startPos = Input.GetTouch(0).position;\n27                 //tempPos = startPos;\n28             }\n29             //if (Input.GetTouch(0).phase == TouchPhase.Ended)\n30             //{\n31             //    tempPos = startPos;\n32             //}\n33             if (Input.GetTouch(0).phase == TouchPhase.Moved)\n34             {\n35                 tempPos = Event.current.mousePosition;\n36 \n37                 float tempX = tempPos.x - startPos.x;\n38                     \n39                 float tempY = tempPos.y - startPos.y;\n40 \n41                 //tempPos = Input.GetTouch(0).deltaPosition;\n42                 //float tempX = tempPos.x;\n43 \n44                 //float tempY = tempPos.y;\n45 \n46                 float tempZ = Mathf.Sqrt(radius * radius - tempX * tempX - tempY * tempY);\n47 \n48                 tempVec = new Vector3(tempX, tempY, tempZ);\n49 \n50                 angle = Mathf.Acos(Vector3.Dot(originalDir.normalized, tempVec.normalized)) * Mathf.Rad2Deg;\n51 \n52                 normalAxis = getNormal(CenterPos, originalDir, tempVec);\n53 \n54                 Cube.rotation = Quaternion.AngleAxis(2 *angle, normalAxis);\n55 \n56             }\n57         }\n58     }\n59 \n60     void OnGUI()\n61     {\n62         GUILayout.Label(\"StartPos 的坐标值为： \"+startPos);\n63         GUILayout.Label(\"tempPos 的坐标值为： \" + tempPos);\n64         GUILayout.Label(\"tempVec 的坐标值为： \" + tempVec);\n65         GUILayout.Label(\"normalAxis 的坐标值为： \" + normalAxis);\n66         GUILayout.Label(\"旋转角度的值为： \" + 2*angle);\n67         GUILayout.Label(\"Cube的四元数角度： \" + Cube.rotation);\n68         GUILayout.Label(\"Cube de rotation.x： \" + Cube.rotation.eulerAngles.x);\n69         GUILayout.Label(\"Cube de rotation.y： \" + Cube.rotation.eulerAngles.y);\n70         GUILayout.Label(\"Cube de rotation.z： \" + Cube.rotation.eulerAngles.z);\n71     }\n72 \n73     private Vector3 getNormal(Vector3 p1,Vector3 p2,Vector3 p3)\n74     {\n75         float a = ((p2.y - p1.y) * (p3.z - p1.z) - (p2.z - p1.z) * (p3.y - p1.y));\n76 \n77         float b = ((p2.z - p1.z) * (p3.x - p1.x) - (p2.x - p1.x) * (p3.z - p1.z));\n78 \n79         float c = ((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n80         //a对应的屏幕的垂直方向，b对应的屏幕的水平方向。\n81         return new Vector3(a, -b, c);\n82     }\n83 }</code></pre>\n<p>如果我们将这个在新机上运行，会发现在第一次手指滑动旋转是正常的，但是第二次就会有个跳动的过程。在这里我们需要注意一个问题，四元数函数Quaternion.AngleAxis是将立方体以初始的旋转角度来进行围绕着轴Axis旋转Angle角度，不是在上一个状态下的增量。如果需要延续上一次的旋转状态，就需要将这个物体的rotation恢复到初始的状态。按照这个思路，我在Cube添加了一个父对象，我们在操作的时候对这个父对象进行操作，然后手指在离开屏幕的时候，将Cube脱离父对象，然后将父对象的rotation进行还原，再将Cube绑定为父物体的子对象，在一下次手指旋转之后就会接着上一次的旋转状态进行旋转，实现了旋转的延续。</p>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show9.png\" alt></p>\n<p>实现的代码为：</p>\n<pre class=\" language-c#\"><code class=\"language-c#\">using UnityEngine;\n 2 using System.Collections;\n 3 \n 4 public class gesture : MonoBehaviour {\n 5     public Transform Cube;\n 6     public Transform RotObj;\n 7     private float radius = 1080;\n 8     private Vector3 originalDir = new Vector3(0f,0f,1080f);\n 9     private Vector3 CenterPos = new Vector3(0, 0, 0);\n10     private Vector2 startPos;\n11     private Vector2 tempPos;\n12     private Vector3 tempVec;\n13     private Vector3 normalAxis;\n14     private float angle;\n15     // Use this for initialization\n16     void Start () {\n17         Cube = GameObject.Find(\"Cube\").transform;\n18     }\n19     \n20     // Update is called once per frame\n21     void Update () {\n22         if (Input.touchCount == 1)\n23         {\n24             //Vector2 startPos = Input.compositionCursorPos;\n25             if (Input.GetTouch(0).phase == TouchPhase.Began)\n26             {\n27                 startPos = Input.GetTouch(0).position;\n28             }\n29             if (Input.GetTouch(0).phase == TouchPhase.Moved)\n30             {\n31                 tempPos = Event.current.mousePosition;\n32 \n33                 float tempX = tempPos.x - startPos.x;\n34                     \n35                 float tempY = tempPos.y - startPos.y;\n36 \n37                 float tempZ = Mathf.Sqrt(radius * radius - tempX * tempX - tempY * tempY);\n38 \n39                 tempVec = new Vector3(tempX, tempY, tempZ);\n40 \n41                 angle = Mathf.Acos(Vector3.Dot(originalDir.normalized, tempVec.normalized)) * Mathf.Rad2Deg;\n42 \n43                 normalAxis = getNormal(CenterPos, originalDir, tempVec);\n44 \n45                 RotObj.rotation = Quaternion.AngleAxis(2 *angle, normalAxis);\n46 \n47             }\n48             if (Input.GetTouch(0).phase == TouchPhase.Ended)\n49             {\n50                 Cube.transform.parent = null;\n51                 RotObj.rotation = Quaternion.identity;\n52                 Cube.parent = RotObj;\n53             }\n54         }\n55     }\n56 \n57     void OnGUI()\n58     {\n59         GUILayout.Label(\"StartPos 的坐标值为： \"+startPos);\n60         GUILayout.Label(\"tempPos 的坐标值为： \" + tempPos);\n61         GUILayout.Label(\"tempVec 的坐标值为： \" + tempVec);\n62         GUILayout.Label(\"normalAxis 的坐标值为： \" + normalAxis);\n63         GUILayout.Label(\"旋转角度的值为： \" + 2*angle);\n64         GUILayout.Label(\"Cube的四元数角度： \" + Cube.rotation);\n65         GUILayout.Label(\"Cube de rotation.x： \" + Cube.rotation.eulerAngles.x);\n66         GUILayout.Label(\"Cube de rotation.y： \" + Cube.rotation.eulerAngles.y);\n67         GUILayout.Label(\"Cube de rotation.z： \" + Cube.rotation.eulerAngles.z);\n68     }\n69 \n70     private Vector3 getNormal(Vector3 p1,Vector3 p2,Vector3 p3)\n71     {\n72         float a = ((p2.y - p1.y) * (p3.z - p1.z) - (p2.z - p1.z) * (p3.y - p1.y));\n73 \n74         float b = ((p2.z - p1.z) * (p3.x - p1.x) - (p2.x - p1.x) * (p3.z - p1.z));\n75 \n76         float c = ((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n77         //a对应的屏幕的垂直方向，b对应的屏幕的水平方向。\n78         return new Vector3(a, -b, c);\n79     }\n80 }</code></pre>\n<p>现在对应着手指的滑动距离，然后调整参数radius，就可以实现比较顺滑的旋转效果，真机实现的效果就不展示了。</p>\n</li>\n</ul>\n<p>老实说，图形学里面数学部分比较难懂的四元数应该算是一个，嗯，就到这吧。</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/start.png\" alt></p>\n<h2 id=\"四元数简介\"><a href=\"#四元数简介\" class=\"headerlink\" title=\"四元数简介\"></a>四元数简介</h2><p>Quaternion又称四元数，由x,y,z和w这四个分量组成，是由爱尔兰数学家威廉·卢云·哈密顿在1843年发现的数学概念。四元数的乘法不符合交换律。从明确地角度而言，四元数是复数的不可交换延伸。如把四元数的集合考虑成多维实数空间的话，四元数就代表着一个四维空间，相对于复数为二维空间。</p>\n<p>在实际的图示如下：</p>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show.jpg\" alt></p>\n<p>说实话关于四元数这一节真的是不好懂，因为里面涉及到好多数学知识，单说推出来的公式就有很多。不怕大家笑话，对于四元数的学习我足足花了两天的时间，包括整理出这篇文章。在前面一章我写到了“变换”，这也是总结的学习笔记。我发现，写博客真是的是一个好多学习方法，加上之前一个博士师兄告诉我，要想好好的学习一本书或者一门技术，那么以此将学习笔记或者经验写成博客专栏是一种有效的方法。现在我要坚持这种方式，给自己留下学习过程中的足迹，也给大家分享一下。欢迎大家指出其中的不足，谢谢！</p>\n<p>四元数是表示旋转的另一种数学形式，使用四元数可以节省存储空间，其之间的连接运算需要的算术运算更少，在产生平滑的三维动画时，用四元数更容易进行修改。</p>\n<p>四元数集合，在数学上被称为哈密顿四元数环(ring of Hamiltonian quaternions)，用H表示，可以理解为四维空间向量，空间中的元素q可以表示为：</p>\n<p>q = (x,y,z,w) = w + xi +yj + zk;</p>\n<p>也可以用实数和向量的形式进行表示，即：</p>\n<p>q = w + v;其中w是实数部分，v是v(x,y,z)。</p>\n<p>四元数集合是复数集合的自然扩展。四元数的乘法服从分配率。</p>\n<p>每个图形引擎都避免不了四元数的讨论，Unity游戏引擎的四元数类封装的比较好。</p>\n<h2 id=\"Quaternion类属性\"><a href=\"#Quaternion类属性\" class=\"headerlink\" title=\"Quaternion类属性\"></a>Quaternion类属性</h2><h5 id=\"eulerAngles-欧拉角\"><a href=\"#eulerAngles-欧拉角\" class=\"headerlink\" title=\"eulerAngles-欧拉角\"></a>eulerAngles-欧拉角</h5><p>定义：</p>\n<pre><code class=\"c#\">public Vector3 eulerAngles{get;set;}</code></pre>\n<p>  如何改变一个游戏对象旋的转状态，我们可以通过改变其Transform进行欧拉角的变换次序，例如假设p(x,y,z)是游戏对象上的一个点，绕x轴旋转a角，绕y轴旋转b角，绕z轴旋转c角，这样就可以得到旋转之后的状态p’(x’,y’,z’)。</p>\n<p>​    Unity的实现过程是很简单的，一句代码就可以搞定。但是具体的实现过程确实很复杂的,涉及到很多矩阵的运算，这里就不过多的介绍。</p>\n<p>​    下面给出一个例子，演示一下如何使用欧拉角。</p>\n<pre><code class=\"c#\">\nusing UnityEngine;\nusing System.Collections;\n\npublic class EulerAngler_ts : MonoBehaviour {\n    public Transform A, B;\n    Quaternion rotations = Quaternion.identity;\n    Vector3 eulerAngle = Vector3.zero;\n    float speed = 10.0f;\n    float tSpeed = 0.0f;\n    // Use this for initialization\n    void Start () {\n\n    }\n\n    // Update is called once per frame\n    void Update () {\n        tSpeed += speed * Time.deltaTime;\n        //第一种方式：将Quaternion实例对象赋值给transform的rotation\n        rotations.eulerAngles = new Vector3(0.0f, tSpeed, 0.0f);\n        A.rotation = rotations;\n        //第二种方式：将三位向量代表的欧拉角直接赋值给transform的eulerAngle\n        B.eulerAngles = new Vector3(0.0f, tSpeed, 0.0f);\n    }\n}\n</code></pre>\n<h2 id=\"四元数在Unity-Quaternion类实例方法映射\"><a href=\"#四元数在Unity-Quaternion类实例方法映射\" class=\"headerlink\" title=\"四元数在Unity Quaternion类实例方法映射\"></a>四元数在Unity Quaternion类实例方法映射</h2><p>四元数向量的旋转矩阵变换，对于∂方向到ß方向的旋转变换有 SetFromToRotation (  ) 方法，原型是：</p>\n<pre><code class=\"c#\">public void SetFromToRotion(Vector3 fromDirection,Vector3 toDirection);</code></pre>\n<p>如使用其创建旋转实例:</p>\n<pre><code class=\"c#\">using UnityEngine;\nusing System.Collections;\n\npublic class SetFromToDirection_ts : MonoBehaviour {\n    public Transform A, B, C;\n    Quaternion q = Quaternion.identity;\n    // Use this for initialization\n    void Start () {\n\n    }\n\n    // Update is called once per frame\n    void Update () {\n\n        q.SetFromToRotation(A.position, B.position);\n        C.rotation = q;\n        Debug.DrawLine(Vector3.zero, A.position, Color.red);\n        Debug.DrawLine(Vector3.zero, B.position, Color.green);\n        Debug.DrawLine(C.position, C.position + new Vector3(0.0f, 1.0f, 0.0f), Color.black);\n        Debug.DrawLine(C.position, C.TransformPoint(Vector3.up * 1.5f), Color.yellow);\n    }\n}</code></pre>\n<p>结果如图示: </p>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/rotation.jpg\" alt></p>\n<h3 id=\"设置Quaternion实例的朝向\"><a href=\"#设置Quaternion实例的朝向\" class=\"headerlink\" title=\"设置Quaternion实例的朝向\"></a>设置Quaternion实例的朝向</h3><pre><code class=\"c#\">public void SetLookRotation(Vector3 view);\npublic void SetLookRotation(Vector3 view,Vector3 up);</code></pre>\n<p>如:</p>\n<pre><code class=\"c#\">Quaternion q = Quaternion.identity;\nq.SetLookRotation(v1,v2);\ntransform.rotation = q;</code></pre>\n<p>transform.forward方向与V1方向相同。</p>\n<p>transform.right垂直于由Vector3.zer0、V1和V2这3点构成的平面。</p>\n<p>v2决定了transform.up的朝向，因为当transform.forward和transform.right方向确定后，transform.up的方向总会与V2的方向的夹角小于或等于90度。</p>\n<p>当v1为Vector3.zero时，方法失效。</p>\n<h3 id=\"ToAngleAxis\"><a href=\"#ToAngleAxis\" class=\"headerlink\" title=\"ToAngleAxis\"></a>ToAngleAxis</h3><pre><code class=\"c#\">public void ToAngleAxis(out float angle,out Vector3 axis);</code></pre>\n<p>参数angle为旋转角，参数axis为轴向量。</p>\n<p>该函数可以实现将GameObject对象的rotation从Quaternion.identity状态变换到当前状态，只需要将GameObject对象绕着axis轴（世界坐标系）旋转angle角度即可。</p>\n<p>演示实例:</p>\n<pre><code class=\"c#\">using UnityEngine;\nusing System.Collections;\n\npublic class ToAngleAxis_ts : MonoBehaviour {\n    public Transform A, B;\n    float angle;\n    Vector3 axis = Vector3.zero;\n    float xSpeed = 0.0f, ySpeed = 0.0f, zSpeed = 0.0f;\n    // Use this for initialization\n    void Start () {\n\n    }\n\n    // Update is called once per frame\n    void Update () {\n        xSpeed += 0.5f * Time.deltaTime;\n        ySpeed += 1.0f * Time.deltaTime;\n        zSpeed += 2.5f * Time.deltaTime;\n        A.eulerAngles = new Vector3(xSpeed, ySpeed, zSpeed);\n        //获取A的rotation的旋转轴和角度\n        A.rotation.ToAngleAxis(out angle, out axis);\n        //设置B的rotation，使得B的rotation和A相同\n        B.rotation = Quaternion.AngleAxis(angle, axis);\n    }\n</code></pre>\n<h2 id=\"Quaternion类静态方法\"><a href=\"#Quaternion类静态方法\" class=\"headerlink\" title=\"Quaternion类静态方法\"></a>Quaternion类静态方法</h2><p>Quaternion中的静态方法有9个即：Angle方法、Dot方法、Euler方法、FromToRotation方法、Inverse方法、Lerp方法、LookRotation方法、RotateToWards方法和Slerp方法。关于静态的方法的使用就是直接用类名调用其静态方法，例如Quaternion.Angle(q1,q2);下面对这些静态方法做下分析。</p>\n<ol>\n<li><h3 id=\"Angle方法\"><a href=\"#Angle方法\" class=\"headerlink\" title=\"Angle方法\"></a>Angle方法</h3><pre><code class=\"c#\">public static float Angle(Quaternion a,Quaternion b);</code></pre>\n<p>该方法可以计算两个旋转状态a达到b时需要旋转的最小夹角。</p>\n<p>实例演示:</p>\n<pre><code>using UnityEngine;\nusing System.Collections;\n\npublic class Angle_ts : MonoBehaviour {\n\n</code></pre></li>\n</ol>\n<pre><code>   // Use this for initialization\n   void Start () {\n\n       Quaternion q1 = Quaternion.identity;\n       Quaternion q2 = Quaternion.identity;\n       q1.eulerAngles = new Vector3(30.0f, 40.0f, 50.0f);\n       float a1 = Quaternion.Angle(q1, q2);\n       float a2 = 0.0f;\n       Vector3 v = Vector3.zero;\n       q1.ToAngleAxis(out a2,out v);\n\n       Debug.Log(&quot;a1: &quot; + a1);\n       Debug.Log(&quot;a2: &quot; + a2);\n       Debug.Log(&quot;q1的欧拉角: &quot; + q1.eulerAngles + &quot; q1的rotation: &quot; + q1);\n       Debug.Log(&quot;q2的欧拉角: &quot; + q2.eulerAngles + &quot; q2的rotation: &quot; + q2);\n   }\n\n   // Update is called once per frame\n   void Update () {\n\n   }</code></pre><pre><code>\n   结果：\n\n   ![](/show1.png)\n\n   从输出结果可以看出a1和a2的值相等，即Angle的返回值是两个Quaternion实例转换的最小夹角。\n\n2. ### Dot方法-点乘\n\n   ```c#\n   public static float Dot(Quaternion a,Quaternion b);</code></pre><p>   该方法可以根据点乘的结果，判断a和b对应欧拉角的关系。</p>\n<p>   例如有两个Quaternion实例q1(x1,y1,z1,w1)和q2(x2,y2,z2,w2)，则float f = Quaternion.Dot(q1,q2);即f = x1<em>x2+y1</em>y2+z1<em>z2+w1</em>w2，结果值f的范围为[-1,1]。</p>\n<p>   当f=+(-)1时，q1和q2对应的欧拉角是相等的，即旋转状态是一致的。特别地，当f = -1时，说明其中一个rotation比另外一个rotation多旋转了360°。</p>\n<p>   实例演示</p>\n<pre><code class=\"c#\">   using UnityEngine;\n   using System.Collections;\n\n   public class Dot_ts : MonoBehaviour {\n\n       public Transform A, B;\n       Quaternion q1 = Quaternion.identity;\n       Quaternion q2 = Quaternion.identity;\n       // Use this for initialization\n       void Start () {\n\n           A.eulerAngles = new Vector3(0.0f, 40.0f, 0.0f);\n           B.eulerAngles = new Vector3(0.0f, 360.0f + 40.0f, 0.0f);\n           q1 = A.rotation;\n           q2 = B.rotation;\n           float f = Quaternion.Dot(q1, q2);\n\n           Debug.Log(&quot;q1的欧拉角: &quot; + q1.eulerAngles + &quot; q1的rotation: &quot; + q1);\n           Debug.Log(&quot;q2的欧拉角: &quot; + q2.eulerAngles + &quot; q2的rotation: &quot; + q2);\n           Debug.Log(&quot;Dot(q1,q2): &quot; + f);\n       }\n\n       // Update is called once per frame\n       void Update () {\n\n       }\n   }</code></pre>\n<p>   输出:</p>\n<p>   <img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show2.png\" alt></p>\n<ol start=\"3\">\n<li><h3 id=\"Euler方法\"><a href=\"#Euler方法\" class=\"headerlink\" title=\"Euler方法\"></a>Euler方法</h3><pre><code class=\"c#\">public static Quaternion Euler(Vector3 euler);\npublic static Quaternion Euler(float x,float y,float z);</code></pre>\n<p>该方法用于返回欧拉角Vector3(ex,ey,ez)对应的四元数Quaternion q(qx,qy,qz,qw)。其对应关系如下：</p>\n<p>已知PIover180 = 3.141592/180 = 0.0174532925f是计算机图形学中的一个常亮，其变换过程如下：</p>\n<pre><code class=\"c#\">ex = ex * PIover180 / 2.0f;\ney = ey * PIover180 / 2.0f;\nez = ez * PIover180 / 2.0f;\n\nqx = Mathf.Sin(ex) * Mathf.Cos(ey) * Mathf.Cos(ez) + Mathf.Cos(ex) * Mathf.Sin(ey) * Mathf.Sin(ez);\nqy = Mathf.Cos(ex) * Mathf.Sin(ey) * Mathf.Cos(ez) - Mathf.Sin(ex) * Mathf.Cos(ey) * Mathf.Sin(ez);\nqz = Mathf.Cos(ex) * Mathf.Cos(ey) * Mathf.Sin(ez) - Mathf.Sin(ex) * Mathf.Sin(ey) * Mathf.Cos(ez);\nqw = Mathf.Cos(ex) * Mathf.Cos(ey) * Mathf.Cos(ez) + Mathf.Sin(ex) * Mathf.Sin(ey) * Mathf.Sin(ez);</code></pre>\n<p>验证变换过程</p>\n<pre><code class=\"c#\">using UnityEngine;\nusing System.Collections;\n\npublic class Euler_ts : MonoBehaviour {\n\n    public float ex, ey, ez;\n    float qx, qy, qz,qw;\n    float PIover180 = 0.0174532925f;\n    Quaternion q = Quaternion.identity;\n    Vector3 euler;\n\n    void OnGUI()\n    {\n        if(GUI.Button(new Rect(10.0f,10.0f,100.0f,45.0f),&quot;计算&quot;))\n        {\n            euler = new Vector3(ex,ey,ez);\n            Debug.Log(&quot;欧拉角Euler(ex,ey,ez): &quot; + euler);\n            q = Quaternion.Euler(ex, ey, ez);\n            Debug.Log(&quot;对应的四元数为: &quot; + q);\n            Debug.Log(&quot;q.x: &quot; + q.x + &quot; q.y: &quot; + q.y + &quot; q.z: &quot; + q.z + &quot; q.w: &quot; + q.w);\n            //验证算法\n            ex = ex * PIover180 / 2.0f;\n            ey = ey * PIover180 / 2.0f;\n            ez = ez * PIover180 / 2.0f;\n\n            qx = Mathf.Sin(ex) * Mathf.Cos(ey) * Mathf.Cos(ez) + Mathf.Cos(ex) * Mathf.Sin(ey) * Mathf.Sin(ez);\n            qy = Mathf.Cos(ex) * Mathf.Sin(ey) * Mathf.Cos(ez) - Mathf.Sin(ex) * Mathf.Cos(ey) * Mathf.Sin(ez);\n            qz = Mathf.Cos(ex) * Mathf.Cos(ey) * Mathf.Sin(ez) - Mathf.Sin(ex) * Mathf.Sin(ey) * Mathf.Cos(ez);\n            qw = Mathf.Cos(ex) * Mathf.Cos(ey) * Mathf.Cos(ez) + Mathf.Sin(ex) * Mathf.Sin(ey) * Mathf.Sin(ez);\n            Debug.Log(&quot;qx: &quot; + qx + &quot; qy: &quot; + qy + &quot; qz: &quot; + qz + &quot; qw: &quot; + qw);\n        }\n    }\n}</code></pre>\n<p>运行结果</p>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show3.png\" alt></p>\n<p>从输出结果可以证明该公式是正确，另外转换后的四元数直接输出的话，如下：</p>\n<pre><code class=\"c#\">q = Quaternion.Euler(ex, ey, ez);\n Debug.Log(&quot;对应的四元数为: &quot; + q);</code></pre>\n<p>输出的值是做了四舍五入处理的。</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li><h3 id=\"FromToRotation\"><a href=\"#FromToRotation\" class=\"headerlink\" title=\"FromToRotation\"></a>FromToRotation</h3><pre><code class=\"c#\">public static Quaternion FromToRotation(Vector3 fromDirection,Vector3 ToDirection);</code></pre>\n<p>在前面介绍了SetFromToRotation实例方法，它们的功能都是一样的只不过用法稍有不同。使用FromToRotation类静态方法，需要直接使用类名进行调用，如Quaternion.FromToRotation(v1,v2);</p>\n<p>在此就不做演示了！</p>\n</li>\n<li><h3 id=\"Inverse方法\"><a href=\"#Inverse方法\" class=\"headerlink\" title=\"Inverse方法\"></a>Inverse方法</h3><pre><code class=\"c#\">public static Quaternion Inverse(Quaternion rotation);</code></pre>\n<p>该方法可以返回参数rotation的逆向Quaternion值。</p>\n<p>例如rotation(x,y,z,w)，那么Quaternion.Inverse(rotation) = (-x,-y,-z,w)。假设rotation的欧拉角为(a,b,c)，则transform.rotation = Quaternion.Inverse(rotation)相当于transform依次绕自身坐标系的z轴、x轴和y轴分别旋转-c°、-a°和-z°。由于是在局部坐标系内的变换，最后transform的欧拉角的各个分量值并不一定等于-a、-b或-c。</p>\n<p>实例演示:</p>\n<pre><code class=\"c#\">using UnityEngine;\nusing System.Collections;\n\npublic class Invers_ts : MonoBehaviour {\n    public Transform A, B;\n\n    // Use this for initialization\n    void Start () {\n\n        Quaternion q1 = Quaternion.identity;\n        Quaternion q2 = Quaternion.identity;\n        q1.eulerAngles = new Vector3(30.0f,40.0f,50.0f);\n        q2 = Quaternion.Inverse(q1);\n        A.rotation = q1;\n        B.rotation = q2;\n\n        Debug.Log(&quot;q1的欧拉角: &quot; + q1.eulerAngles + &quot;q1的rotation: &quot; + q1);\n        Debug.Log(&quot;q2的欧拉角: &quot; + q2.eulerAngles + &quot;q2的rotation: &quot; + q2);\n    }\n\n    // Update is called once per frame\n    void Update () {\n\n    }\n}\n</code></pre>\n</li>\n</ol>\n<ol start=\"6\">\n<li><h3 id=\"Lerp和Slerp方法\"><a href=\"#Lerp和Slerp方法\" class=\"headerlink\" title=\"Lerp和Slerp方法\"></a>Lerp和Slerp方法</h3><pre><code class=\"c#\">public static Quaternion Lerp(Quaternion form, Quaternion to,float t);\npublic static Quaternion Slerp(Quaternion form, Quaternion to,float t);</code></pre>\n<p>两种方法的作用都是返回从form到to的插值。当参数t&lt;=0时返回值为from，当参数t&gt;=1时返回值为to。其中Lerp是线性差值，而Slerp是球形插值。关于球形差值我会在另外一篇博客里面说。</p>\n<p>实例演示</p>\n<pre><code class=\"c#\">\nusing UnityEngine;\nusing System.Collections;\n\npublic class LerpAndSlerp_ts : MonoBehaviour\n{\n    public Transform A, B, C,D;\n    float speed = 0.2f;\n    float total = 0.0f;\n    // Use this for initialization\n    void Start () {\n\n    }\n\n    // Update is called once per frame\n    void Update () {\n        total += Time.deltaTime * speed;\n        if(total &gt;= 1.0f)\n            total = 1.0f;\n        C.rotation = Quaternion.Lerp(A.rotation, B.rotation, total);\n        D.rotation = Quaternion.Lerp(A.rotation, B.rotation, total);\n        //C.rotation = Quaternion.Lerp(A.rotation, B.rotation, Time.deltaTime * speed);\n        //D.rotation = Quaternion.Lerp(A.rotation, B.rotation, Time.deltaTime * speed);\n    }\n\n}</code></pre>\n</li>\n<li><h3 id=\"RotateTowards\"><a href=\"#RotateTowards\" class=\"headerlink\" title=\"RotateTowards\"></a>RotateTowards</h3><pre><code class=\"c#\">public static Quaternion RotateTowards(Quaternion from, Quaternion to, float maxDegreesDelta);</code></pre>\n<p>该方法也是一个插值方法，即从返回参数from到to的插值，且返回值的最大角度不超过maxDegreesDelta。maxDegreesDelta是角度值，不是插值系数，当maxDegreesDelta &lt; 0时，将进行逆向插值即从to到from的方向进行插值计算。</p>\n<pre><code class=\"c#\">using UnityEngine;\nusing System.Collections;\n\npublic class RotateToWards_ts : MonoBehaviour {\n\n    public Transform A, B, C;\n    float speed = 10.0f;\n    float total = 0.0f;\n    // Use this for initialization\n    void Start()\n    {\n\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        total += Time.deltaTime * speed;\n        if (total &gt;= 1.0f)\n            total = 1.0f;\n        C.rotation = Quaternion.RotateTowards(A.rotation, B.rotation, Time.time * speed - 40.0f);\n        Debug.Log(&quot;C与A的欧拉角的插值: &quot; + (C.eulerAngles - A.eulerAngles) + &quot;maxDegreesDelta: &quot; + (Time.time * speed - 40.0f));\n\n    }\n}</code></pre>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show4.png\" alt></p>\n</li>\n<li><h3 id=\"LookRotation\"><a href=\"#LookRotation\" class=\"headerlink\" title=\"LookRotation\"></a>LookRotation</h3><pre><code class=\"c#\">public static Quaternion LookRotation(Vector3 forward);\npublic static Quaternion LookRotation(Vector3 forward,Vector3 upwards);</code></pre>\n<p>参数forward为返回Quaternion实例的forward朝向。该方法和前面讲到的SetLookRotation实例方法的功能是一样的，故不多做阐述了。</p>\n</li>\n</ol>\n<h2 id=\"Quaternion类运算符\"><a href=\"#Quaternion类运算符\" class=\"headerlink\" title=\"Quaternion类运算符\"></a>Quaternion类运算符</h2><p>Quaternion类涉及到两个<strong>Quaternion对象</strong>相乘和<strong>Quaternion</strong>对象与<strong>Vector3</strong>对象相乘，那么就必须重载”*”运算符</p>\n<pre><code class=\"c#\">public static Quaternion operator *(Quaternion lhs, Quaternion rhs);\npublic static Vector3 operator *(Quaternion rotation, Vector3 point);</code></pre>\n<ul>\n<li><h3 id=\"两个Quaternion对象相乘\"><a href=\"#两个Quaternion对象相乘\" class=\"headerlink\" title=\"两个Quaternion对象相乘\"></a>两个Quaternion对象相乘</h3><p>对于两个Quaternion对象相乘主要用于自身旋转变换，例如：</p>\n<pre><code class=\"c#\">B.rotation *= A.rotation;</code></pre>\n<ul>\n<li><p>B会绕着B的局部坐标系的z、x、y轴按照先绕z轴再绕x轴最后绕y轴的旋转次序，分别旋转A.eulerAngles.z度、A.eulerAngles.x度、和A.eulerAngles.y度。由于是绕着局部坐标系进行旋转，所以当绕着其中一个轴进行旋转时，可能会影响其余两个坐标轴方向的欧拉角（除非其余两轴的欧拉角都为0才不会受到影响）。</p>\n</li>\n<li><p>假如A的欧拉角为aEuler(ax,ay,az)，则沿着B的初始局部坐标系的aEuler方向向下看B在绕着aEuler顺时针旋转。B的旋转状况还受到其初始状态的影响。</p>\n<p>实例演示:</p>\n<pre><code class=\"c#\">using UnityEngine;\nusing System.Collections;\n\npublic class Multiply1_ts : MonoBehaviour {\n\n    public Transform A, B;\n\n    // Use this for initialization\n    void Start () {\n\n        A.eulerAngles = new Vector3(1.0f, 1.5f, 2.0f);\n    }\n\n    // Update is called once per frame\n    void Update () {\n\n        B.rotation *= A.rotation;\n        Debug.Log(B.eulerAngles);\n    }\n}</code></pre>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show5.png\" alt></p>\n<p>分析：B绕着其自身坐标系的Vector3(1.0f,1.5f,2.0f)方向旋转。虽然每次都绕着这个轴向旋转的角度相同，但角度的旋转在3个坐标轴的值都不为零，三个轴的旋转会相互影响，所以B的欧拉角的各个分量的每次递增是不固定的。</p>\n</li>\n</ul>\n</li>\n<li><h3 id=\"Quaternion对象与Vector3对象\"><a href=\"#Quaternion对象与Vector3对象\" class=\"headerlink\" title=\"Quaternion对象与Vector3对象\"></a>Quaternion对象与Vector3对象</h3><p>对于Quaternion对象与Vector3对象相乘主要用于自身移动变换，例如：</p>\n<pre><code class=\"c#\">transform.position += tansform.rotation * A;</code></pre>\n<p>其中A为Vector3的对象。transform对应的对象会沿着自身坐标系中向量A的方向移动A的模长的距离。transform.rotation与A相乘可以确定移动的方向和距离。</p>\n<p>实例演示</p>\n<pre><code class=\"c#\">\nusing UnityEngine;\nusing System.Collections;\n\npublic class Multiply2_ts : MonoBehaviour {\n    public Transform A;\n    float speed = 0.1f;\n\n    // Use this for initialization\n    void Start () {\n\n        A.position = Vector3.zero;\n        A.eulerAngles = new Vector3(0.0f, 45.0f, 0.0f);\n    }\n\n    // Update is called once per frame\n    void Update () {\n\n        A.position += A.rotation * (Vector3.forward * speed);\n        Debug.Log(A.position);\n    }\n}</code></pre>\n<p>运行截图:</p>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show6.png\" alt></p>\n</li>\n</ul>\n<ul>\n<li><h3 id=\"两个Quaternion对象相乘与Quaternion对象与Vector3对象相乘的异同\"><a href=\"#两个Quaternion对象相乘与Quaternion对象与Vector3对象相乘的异同\" class=\"headerlink\" title=\"两个Quaternion对象相乘与Quaternion对象与Vector3对象相乘的异同\"></a>两个Quaternion对象相乘与Quaternion对象与Vector3对象相乘的异同</h3><ul>\n<li>设A为两个两个Quaternion对象相乘的结果。B为Quaternion对象与Vector3对象相乘的结果。其中A为Quaternion类型，B为Vector3类型。</li>\n<li>A与B的相同之处是它们都通过自身坐标系的“相乘”方式来实现在世界坐标系中的变换。</li>\n<li>A主要用来实现transform绕自身坐标系的某个轴旋转，B主要用来实现transform沿着自身坐标系的某个方向移动。</li>\n<li>必须遵守Quaternion对象*Vector3对象的形式，不可以颠倒顺序。</li>\n</ul>\n<p>由于它们都是相对于自身坐标系进行的旋转或移动，所以当自身坐标系的轴向和世界坐标系的轴向不一致时，它们绕着自身坐标系中的某个轴向的变动都会影响到物体在世界坐标系中各个坐标轴的变动。</p>\n<p>　四元数quaternion的变换比较复杂，但是在unity中已经给我们写好了相应的函数实现对transform的操作。</p>\n<p>　　在最近的一个项目中，遇到了一个单手指滑动手机屏幕实现对模型的一个旋转操作，在尝试了各种unity中的旋转函数之后都没能够达到想要的效果之后，我选择了用Quaternion.AngleAxis的函数来实现旋转的操作效果。</p>\n<p>　　首先我们来分析一下Quaternion.AngleAxis(angle,axis)，参数angle和axis代表了物体的旋转角度和旋转轴心。如下图：红色箭头方向代表物体所围绕的旋转轴，旋转角度可以是自定义的。</p>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show7.jpg\" alt></p>\n<p>接下来，我们就要做两件事情，确定axis和计算angle。在这个项目中，我们是根据单个手指在手机屏幕上滑动，我们通过记录滑动的距离，X方向的增量，以及Y轴方向的增量来为后面计算axis和angle打下基础。unity的Input函数有GetTouch这个函数，我们只需要调用这个函数的相关方法就可以实现需求。</p>\n<p>　　现在，我们在unity中新建一个场景，在场景中新建一个立方块。</p>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show8.png\" alt></p>\n<p>注意立方块的世界坐标轴，Z轴的朝向应该是朝着摄像机的。根据之前对四元数脚本的分析，立方体的旋转脚本为：</p>\n<p>　　Gesture.cs:</p>\n<pre><code class=\"c#\">using UnityEngine;\n 2 using System.Collections;\n 3 \n 4 public class gesture : MonoBehaviour {\n 5     public Transform Cube;\n 6     private float radius = 1080;\n 7     private Vector3 originalDir = new Vector3(0f,0f,1080f);\n 8     private Vector3 CenterPos = new Vector3(0, 0, 0);\n 9     private Vector2 startPos;\n10     private Vector2 tempPos;\n11     private Vector3 tempVec;\n12     private Vector3 normalAxis;\n13     private float angle;\n14     // Use this for initialization\n15     void Start () {\n16         Cube = GameObject.Find(&quot;Cube&quot;).transform;\n17     }\n18     \n19     // Update is called once per frame\n20     void Update () {\n21         if (Input.touchCount == 1)\n22         {\n23             //Vector2 startPos = Input.compositionCursorPos;\n24             if (Input.GetTouch(0).phase == TouchPhase.Began)\n25             {\n26                 startPos = Input.GetTouch(0).position;\n27                 //tempPos = startPos;\n28             }\n29             //if (Input.GetTouch(0).phase == TouchPhase.Ended)\n30             //{\n31             //    tempPos = startPos;\n32             //}\n33             if (Input.GetTouch(0).phase == TouchPhase.Moved)\n34             {\n35                 tempPos = Event.current.mousePosition;\n36 \n37                 float tempX = tempPos.x - startPos.x;\n38                     \n39                 float tempY = tempPos.y - startPos.y;\n40 \n41                 //tempPos = Input.GetTouch(0).deltaPosition;\n42                 //float tempX = tempPos.x;\n43 \n44                 //float tempY = tempPos.y;\n45 \n46                 float tempZ = Mathf.Sqrt(radius * radius - tempX * tempX - tempY * tempY);\n47 \n48                 tempVec = new Vector3(tempX, tempY, tempZ);\n49 \n50                 angle = Mathf.Acos(Vector3.Dot(originalDir.normalized, tempVec.normalized)) * Mathf.Rad2Deg;\n51 \n52                 normalAxis = getNormal(CenterPos, originalDir, tempVec);\n53 \n54                 Cube.rotation = Quaternion.AngleAxis(2 *angle, normalAxis);\n55 \n56             }\n57         }\n58     }\n59 \n60     void OnGUI()\n61     {\n62         GUILayout.Label(&quot;StartPos 的坐标值为： &quot;+startPos);\n63         GUILayout.Label(&quot;tempPos 的坐标值为： &quot; + tempPos);\n64         GUILayout.Label(&quot;tempVec 的坐标值为： &quot; + tempVec);\n65         GUILayout.Label(&quot;normalAxis 的坐标值为： &quot; + normalAxis);\n66         GUILayout.Label(&quot;旋转角度的值为： &quot; + 2*angle);\n67         GUILayout.Label(&quot;Cube的四元数角度： &quot; + Cube.rotation);\n68         GUILayout.Label(&quot;Cube de rotation.x： &quot; + Cube.rotation.eulerAngles.x);\n69         GUILayout.Label(&quot;Cube de rotation.y： &quot; + Cube.rotation.eulerAngles.y);\n70         GUILayout.Label(&quot;Cube de rotation.z： &quot; + Cube.rotation.eulerAngles.z);\n71     }\n72 \n73     private Vector3 getNormal(Vector3 p1,Vector3 p2,Vector3 p3)\n74     {\n75         float a = ((p2.y - p1.y) * (p3.z - p1.z) - (p2.z - p1.z) * (p3.y - p1.y));\n76 \n77         float b = ((p2.z - p1.z) * (p3.x - p1.x) - (p2.x - p1.x) * (p3.z - p1.z));\n78 \n79         float c = ((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n80         //a对应的屏幕的垂直方向，b对应的屏幕的水平方向。\n81         return new Vector3(a, -b, c);\n82     }\n83 }</code></pre>\n<p>如果我们将这个在新机上运行，会发现在第一次手指滑动旋转是正常的，但是第二次就会有个跳动的过程。在这里我们需要注意一个问题，四元数函数Quaternion.AngleAxis是将立方体以初始的旋转角度来进行围绕着轴Axis旋转Angle角度，不是在上一个状态下的增量。如果需要延续上一次的旋转状态，就需要将这个物体的rotation恢复到初始的状态。按照这个思路，我在Cube添加了一个父对象，我们在操作的时候对这个父对象进行操作，然后手指在离开屏幕的时候，将Cube脱离父对象，然后将父对象的rotation进行还原，再将Cube绑定为父物体的子对象，在一下次手指旋转之后就会接着上一次的旋转状态进行旋转，实现了旋转的延续。</p>\n<p><img src=\"/2020/01/07/you-xi-zhong-de-si-yuan-shu/show9.png\" alt></p>\n<p>实现的代码为：</p>\n<pre><code class=\"c#\">using UnityEngine;\n 2 using System.Collections;\n 3 \n 4 public class gesture : MonoBehaviour {\n 5     public Transform Cube;\n 6     public Transform RotObj;\n 7     private float radius = 1080;\n 8     private Vector3 originalDir = new Vector3(0f,0f,1080f);\n 9     private Vector3 CenterPos = new Vector3(0, 0, 0);\n10     private Vector2 startPos;\n11     private Vector2 tempPos;\n12     private Vector3 tempVec;\n13     private Vector3 normalAxis;\n14     private float angle;\n15     // Use this for initialization\n16     void Start () {\n17         Cube = GameObject.Find(&quot;Cube&quot;).transform;\n18     }\n19     \n20     // Update is called once per frame\n21     void Update () {\n22         if (Input.touchCount == 1)\n23         {\n24             //Vector2 startPos = Input.compositionCursorPos;\n25             if (Input.GetTouch(0).phase == TouchPhase.Began)\n26             {\n27                 startPos = Input.GetTouch(0).position;\n28             }\n29             if (Input.GetTouch(0).phase == TouchPhase.Moved)\n30             {\n31                 tempPos = Event.current.mousePosition;\n32 \n33                 float tempX = tempPos.x - startPos.x;\n34                     \n35                 float tempY = tempPos.y - startPos.y;\n36 \n37                 float tempZ = Mathf.Sqrt(radius * radius - tempX * tempX - tempY * tempY);\n38 \n39                 tempVec = new Vector3(tempX, tempY, tempZ);\n40 \n41                 angle = Mathf.Acos(Vector3.Dot(originalDir.normalized, tempVec.normalized)) * Mathf.Rad2Deg;\n42 \n43                 normalAxis = getNormal(CenterPos, originalDir, tempVec);\n44 \n45                 RotObj.rotation = Quaternion.AngleAxis(2 *angle, normalAxis);\n46 \n47             }\n48             if (Input.GetTouch(0).phase == TouchPhase.Ended)\n49             {\n50                 Cube.transform.parent = null;\n51                 RotObj.rotation = Quaternion.identity;\n52                 Cube.parent = RotObj;\n53             }\n54         }\n55     }\n56 \n57     void OnGUI()\n58     {\n59         GUILayout.Label(&quot;StartPos 的坐标值为： &quot;+startPos);\n60         GUILayout.Label(&quot;tempPos 的坐标值为： &quot; + tempPos);\n61         GUILayout.Label(&quot;tempVec 的坐标值为： &quot; + tempVec);\n62         GUILayout.Label(&quot;normalAxis 的坐标值为： &quot; + normalAxis);\n63         GUILayout.Label(&quot;旋转角度的值为： &quot; + 2*angle);\n64         GUILayout.Label(&quot;Cube的四元数角度： &quot; + Cube.rotation);\n65         GUILayout.Label(&quot;Cube de rotation.x： &quot; + Cube.rotation.eulerAngles.x);\n66         GUILayout.Label(&quot;Cube de rotation.y： &quot; + Cube.rotation.eulerAngles.y);\n67         GUILayout.Label(&quot;Cube de rotation.z： &quot; + Cube.rotation.eulerAngles.z);\n68     }\n69 \n70     private Vector3 getNormal(Vector3 p1,Vector3 p2,Vector3 p3)\n71     {\n72         float a = ((p2.y - p1.y) * (p3.z - p1.z) - (p2.z - p1.z) * (p3.y - p1.y));\n73 \n74         float b = ((p2.z - p1.z) * (p3.x - p1.x) - (p2.x - p1.x) * (p3.z - p1.z));\n75 \n76         float c = ((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n77         //a对应的屏幕的垂直方向，b对应的屏幕的水平方向。\n78         return new Vector3(a, -b, c);\n79     }\n80 }</code></pre>\n<p>现在对应着手指的滑动距离，然后调整参数radius，就可以实现比较顺滑的旋转效果，真机实现的效果就不展示了。</p>\n</li>\n</ul>\n<p>老实说，图形学里面数学部分比较难懂的四元数应该算是一个，嗯，就到这吧。</p>\n"},{"title":"网络协议基础","date":"2020-01-21T11:10:32.000Z","_content":"\n## TCP协议\n\n![](/tcp.jpg)\n\n## HTTP协议\n\n`http`是一个简单的请求-响应协议，它封装在`TCP协议`之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。\n\n### http请求包体\n\n格式：\n\n> http包是在tcp协议上层进行的封装后的包体\n\n| 请求包体参数                                           | 含义                                                       |\n| :----------------------------------------------------- | ---------------------------------------------------------- |\n| GET /domains/example/ HTTP /1.1                        | //\t请求行: \t请求方法\t请求URI\tHTTP协议/协议版本 |\n| Host:www.rubyboy.cn                                    | //\t服务器端的主机名                                     |\n| User-Agent:Mozilla/5.0 (MacOS 10.14.5)\tsafari/537.8 | //\t浏览器信息                                           |\n| Accept:text/html,application/xhtml+xml,...             | //\t客户端能接受的MIME                                   |\n\n当服务器接收到请求包体以后进行响应，此时的响应包体则需遵循http特定的包体格式，如下：\n\n### 响应包体\n\n格式：\n\n| 包体参数                              | 含义                                                       |\n| :------------------------------------ | ---------------------------------------------------------- |\n| HTTP/1.1  200  ok                     | //\t状态行: \t请求方法\t请求URI\tHTTP协议/协议版本 |\n| Server: \tNginx/1.0.8               | //\t服务器端的服务器软件名字和版本                       |\n| Date:Date: Tue, 30...                 | //\t发送时间                                             |\n| Content-Type: text/html               | //\t服务器发送信息的类型                                 |\n| Transfer-Encoding:chunked             | //    表示http是分段发的                                   |\n| Connection:keep-alive                 | //    保持连接状态                                         |\n| Content-Length:90                     | //    主体内容长度                                         |\n| ----------空行----------------        | //    用来分隔消息体和主体                                 |\n| <DOCTYPE html PUBLIC \"-//Rubyboy....\" | //    消息主体                                             |\n\n\n\n### 一次完整的HTTP请求所经历的7个步骤\n\nHTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：\n\n**1. 建立TCP连接**\n\n在HTTP服务器工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。\n\n**2. Web浏览器向Web服务器发送请求命令** \n\n一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。\n\n**3. Web浏览器发送请求头信息** \n\n浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。 \n\n**4. Web服务器应答** \n\n客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。\n\n**5. Web服务器发送应答头信息** \n\n正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 \n\n**6. Web服务器向浏览器发送数据** \n\nWeb服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。\n\n**7. Web服务器关闭TCP连接** \n\n一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：\n\nConnection:keep-alive \n\nTCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。\n\n### 请求报文和响应报文\n\nHTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。\n\n### **HTTP请求报文**\n\n一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。\n\n![](/a.jpg)\n\n或者使用：\n\n```http\n＜request-line＞\n\n＜headers＞\n\n＜blank line＞\n\n[＜request-body＞\n```\n\n**1.请求头**\n\n请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。\n\nHTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。\n\n而常见的有如下几种：\n\n### **GET**\n\n最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。例如，/index.jsp?id=100&op=bind,这样通过GET方式传递的数据直接表示在地址中，所以我们可以把请求结果以链接的形式发送给好友。以用google搜索domety为例，Request格式如下：\n\n```http\nGET /search?hl=zh-CN&source=hp&q=domety&aq=f&oq= HTTP/1.1  \nAccept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, \napplication/msword, application/x-silverlight, application/x-shockwave-flash, */*  \nReferer: <a href=\"http://www.google.cn/\">http://www.google.cn/</a>  \nAccept-Language: zh-cn  \nAccept-Encoding: gzip, deflate  \nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  \nHost: <a href=\"http://www.google.cn\">www.google.cn</a>  \nConnection: Keep-Alive  \nCookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; \nNID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-\nFxlRugatx63JLv7CWMD6UB_O_r  \n```\n\n可以看到，GET方式的请求一般不包含”请求内容”部分，请求数据以地址的形式表现在请求行。地址链接如下：\n\n```http\n<a href=\"http://www.google.cn/search?hl=zh-CN&source=hp&q=domety&aq=f&oq=\">http://www.google.cn/search?hl=zh-CN&source=hp\n&q=domety&aq=f&oq=</a> \n```\n\n地址中”?”之后的部分就是通过GET发送的请求数据，我们可以在地址栏中清楚的看到，各个数据之间用”&”符号隔开。显然，这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送。\n\n### **POST**\n\n对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参 数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。还以上面 的搜索domety为例，如果使用POST方式的话，格式如下：大量数据的时候，也不适合使用GET方式。\n\n```http\nPOST /search HTTP/1.1  \nAccept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, \napplication/msword, application/x-silverlight, application/x-shockwave-flash, */*  \nReferer: <a href=\"http://www.google.cn/\">http://www.google.cn/</a>  \nAccept-Language: zh-cn  \nAccept-Encoding: gzip, deflate  \nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  \nHost: <a href=\"http://www.google.cn\">www.google.cn</a>  \nConnection: Keep-Alive  \nCookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; \nNID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-\nFxlRugatx63JLv7CWMD6UB_O_r  \n\nhl=zh-CN&source=hp&q=domety  \n```\n\n可以看到，POST方式请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&”符号隔开。POST方式大多用于页 面的表单中。因为POST也能完成GET的功能，因此多数人在设计表单的时候一律都使用POST方式，其实这是一个误区。GET方式也有自己的特点和优 势，我们应该根据不同的情况来选择是使用GET还是使用POST。\n\n### **HEAD**\n\nHEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。\n\n \n\n#### **请求头部**\n\n请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：\n\nUser-Agent：产生请求的浏览器类型。\n\nAccept：客户端可识别的内容类型列表。\n\nHost：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。\n\n \n\n#### **空行**\n\n最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。\n\n \n\n#### **请求数据**\n\n请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。\n\n \n\n### **HTTP报文**\n\nHTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。\n\n如下所示，HTTP响应的格式与请求的格式十分类似：\n\n```http\n＜status-line＞\n\n＜headers＞\n\n＜blank line＞\n\n[＜response-body＞]\n```\n\n正如你所见，在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。\n\n \n\n状态行格式如下：\n\nHTTP-Version Status-Code Reason-Phrase CRLF\n\n其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。\n\n- 1xx：指示信息--表示请求已接收，继续处理。\n- 2xx：成功--表示请求已被成功接收、理解、接受。\n- 3xx：重定向--要完成请求必须进行更进一步的操作。\n- 4xx：客户端错误--请求有语法错误或请求无法实现。\n- 5xx：服务器端错误--服务器未能实现合法的请求。\n\n常见状态代码、状态描述的说明如下。\n\n- 200 OK：客户端请求成功。\n- 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。\n- 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。\n- 403 Forbidden：服务器收到请求，但是拒绝提供服务。\n- 404 Not Found：请求资源不存在，举个例子：输入了错误的URL。\n- 500 Internal Server Error：服务器发生不可预期的错误。\n- 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。\n\n下面给出一个HTTP响应报文例子\n\n```http\nHTTP/1.1 200 OK\nDate: Sat, 31 Dec 2005 23:59:59 GMT\nContent-Type: text/html;charset=ISO-8859-1\nContent-Length: 122\n\n＜html＞\n＜head＞\n＜title＞Wrox Homepage＜/title＞\n＜/head＞\n＜body＞\n＜!-- body goes here --＞\n＜/body＞\n＜/html＞\n```\n\n### **关于HTTP请求GET和POST的区别**\n\n1.GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头＜request-line＞中）， 以?分割URL和传输数据，多个参数用&连接;例如：login.action?name=hyddd& password=idontknow&verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。\n\n POST提交：把提交的数据放置在是HTTP包的包体＜request-body＞中。上文示例中红色字体标明的就是实际的传输数据\n\n 因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。\n\n2.传输数据的大小：\n\n  首先声明,HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有：\n\n  GET:特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。\n\n  因此对于GET提交时，传输数据就会受到URL长度的限制。\n\n  POST:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。\n\n3.安全性：\n\n  POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。","source":"_posts/网络协议基础.md","raw":"---\ntitle: 网络协议基础\ndate: 2020-01-21 19:10:32\ntags: [服务端开发,网络协议]\ncategories: Go栈\n---\n\n## TCP协议\n\n![](/tcp.jpg)\n\n## HTTP协议\n\n`http`是一个简单的请求-响应协议，它封装在`TCP协议`之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。\n\n### http请求包体\n\n格式：\n\n> http包是在tcp协议上层进行的封装后的包体\n\n| 请求包体参数                                           | 含义                                                       |\n| :----------------------------------------------------- | ---------------------------------------------------------- |\n| GET /domains/example/ HTTP /1.1                        | //\t请求行: \t请求方法\t请求URI\tHTTP协议/协议版本 |\n| Host:www.rubyboy.cn                                    | //\t服务器端的主机名                                     |\n| User-Agent:Mozilla/5.0 (MacOS 10.14.5)\tsafari/537.8 | //\t浏览器信息                                           |\n| Accept:text/html,application/xhtml+xml,...             | //\t客户端能接受的MIME                                   |\n\n当服务器接收到请求包体以后进行响应，此时的响应包体则需遵循http特定的包体格式，如下：\n\n### 响应包体\n\n格式：\n\n| 包体参数                              | 含义                                                       |\n| :------------------------------------ | ---------------------------------------------------------- |\n| HTTP/1.1  200  ok                     | //\t状态行: \t请求方法\t请求URI\tHTTP协议/协议版本 |\n| Server: \tNginx/1.0.8               | //\t服务器端的服务器软件名字和版本                       |\n| Date:Date: Tue, 30...                 | //\t发送时间                                             |\n| Content-Type: text/html               | //\t服务器发送信息的类型                                 |\n| Transfer-Encoding:chunked             | //    表示http是分段发的                                   |\n| Connection:keep-alive                 | //    保持连接状态                                         |\n| Content-Length:90                     | //    主体内容长度                                         |\n| ----------空行----------------        | //    用来分隔消息体和主体                                 |\n| <DOCTYPE html PUBLIC \"-//Rubyboy....\" | //    消息主体                                             |\n\n\n\n### 一次完整的HTTP请求所经历的7个步骤\n\nHTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：\n\n**1. 建立TCP连接**\n\n在HTTP服务器工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。\n\n**2. Web浏览器向Web服务器发送请求命令** \n\n一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。\n\n**3. Web浏览器发送请求头信息** \n\n浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。 \n\n**4. Web服务器应答** \n\n客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。\n\n**5. Web服务器发送应答头信息** \n\n正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 \n\n**6. Web服务器向浏览器发送数据** \n\nWeb服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。\n\n**7. Web服务器关闭TCP连接** \n\n一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：\n\nConnection:keep-alive \n\nTCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。\n\n### 请求报文和响应报文\n\nHTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。\n\n### **HTTP请求报文**\n\n一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。\n\n![](/a.jpg)\n\n或者使用：\n\n```http\n＜request-line＞\n\n＜headers＞\n\n＜blank line＞\n\n[＜request-body＞\n```\n\n**1.请求头**\n\n请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。\n\nHTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。\n\n而常见的有如下几种：\n\n### **GET**\n\n最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。例如，/index.jsp?id=100&op=bind,这样通过GET方式传递的数据直接表示在地址中，所以我们可以把请求结果以链接的形式发送给好友。以用google搜索domety为例，Request格式如下：\n\n```http\nGET /search?hl=zh-CN&source=hp&q=domety&aq=f&oq= HTTP/1.1  \nAccept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, \napplication/msword, application/x-silverlight, application/x-shockwave-flash, */*  \nReferer: <a href=\"http://www.google.cn/\">http://www.google.cn/</a>  \nAccept-Language: zh-cn  \nAccept-Encoding: gzip, deflate  \nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  \nHost: <a href=\"http://www.google.cn\">www.google.cn</a>  \nConnection: Keep-Alive  \nCookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; \nNID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-\nFxlRugatx63JLv7CWMD6UB_O_r  \n```\n\n可以看到，GET方式的请求一般不包含”请求内容”部分，请求数据以地址的形式表现在请求行。地址链接如下：\n\n```http\n<a href=\"http://www.google.cn/search?hl=zh-CN&source=hp&q=domety&aq=f&oq=\">http://www.google.cn/search?hl=zh-CN&source=hp\n&q=domety&aq=f&oq=</a> \n```\n\n地址中”?”之后的部分就是通过GET发送的请求数据，我们可以在地址栏中清楚的看到，各个数据之间用”&”符号隔开。显然，这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送。\n\n### **POST**\n\n对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参 数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。还以上面 的搜索domety为例，如果使用POST方式的话，格式如下：大量数据的时候，也不适合使用GET方式。\n\n```http\nPOST /search HTTP/1.1  \nAccept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, \napplication/msword, application/x-silverlight, application/x-shockwave-flash, */*  \nReferer: <a href=\"http://www.google.cn/\">http://www.google.cn/</a>  \nAccept-Language: zh-cn  \nAccept-Encoding: gzip, deflate  \nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  \nHost: <a href=\"http://www.google.cn\">www.google.cn</a>  \nConnection: Keep-Alive  \nCookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; \nNID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-\nFxlRugatx63JLv7CWMD6UB_O_r  \n\nhl=zh-CN&source=hp&q=domety  \n```\n\n可以看到，POST方式请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&”符号隔开。POST方式大多用于页 面的表单中。因为POST也能完成GET的功能，因此多数人在设计表单的时候一律都使用POST方式，其实这是一个误区。GET方式也有自己的特点和优 势，我们应该根据不同的情况来选择是使用GET还是使用POST。\n\n### **HEAD**\n\nHEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。\n\n \n\n#### **请求头部**\n\n请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：\n\nUser-Agent：产生请求的浏览器类型。\n\nAccept：客户端可识别的内容类型列表。\n\nHost：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。\n\n \n\n#### **空行**\n\n最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。\n\n \n\n#### **请求数据**\n\n请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。\n\n \n\n### **HTTP报文**\n\nHTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。\n\n如下所示，HTTP响应的格式与请求的格式十分类似：\n\n```http\n＜status-line＞\n\n＜headers＞\n\n＜blank line＞\n\n[＜response-body＞]\n```\n\n正如你所见，在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。\n\n \n\n状态行格式如下：\n\nHTTP-Version Status-Code Reason-Phrase CRLF\n\n其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。\n\n- 1xx：指示信息--表示请求已接收，继续处理。\n- 2xx：成功--表示请求已被成功接收、理解、接受。\n- 3xx：重定向--要完成请求必须进行更进一步的操作。\n- 4xx：客户端错误--请求有语法错误或请求无法实现。\n- 5xx：服务器端错误--服务器未能实现合法的请求。\n\n常见状态代码、状态描述的说明如下。\n\n- 200 OK：客户端请求成功。\n- 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。\n- 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。\n- 403 Forbidden：服务器收到请求，但是拒绝提供服务。\n- 404 Not Found：请求资源不存在，举个例子：输入了错误的URL。\n- 500 Internal Server Error：服务器发生不可预期的错误。\n- 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。\n\n下面给出一个HTTP响应报文例子\n\n```http\nHTTP/1.1 200 OK\nDate: Sat, 31 Dec 2005 23:59:59 GMT\nContent-Type: text/html;charset=ISO-8859-1\nContent-Length: 122\n\n＜html＞\n＜head＞\n＜title＞Wrox Homepage＜/title＞\n＜/head＞\n＜body＞\n＜!-- body goes here --＞\n＜/body＞\n＜/html＞\n```\n\n### **关于HTTP请求GET和POST的区别**\n\n1.GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头＜request-line＞中）， 以?分割URL和传输数据，多个参数用&连接;例如：login.action?name=hyddd& password=idontknow&verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。\n\n POST提交：把提交的数据放置在是HTTP包的包体＜request-body＞中。上文示例中红色字体标明的就是实际的传输数据\n\n 因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。\n\n2.传输数据的大小：\n\n  首先声明,HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有：\n\n  GET:特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。\n\n  因此对于GET提交时，传输数据就会受到URL长度的限制。\n\n  POST:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。\n\n3.安全性：\n\n  POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。","slug":"网络协议基础","published":1,"updated":"2020-02-12T02:27:32.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7771rjv001zzd5bcujhad2j","content":"<h2 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h2><p><img src=\"/2020/01/21/wang-luo-xie-yi-ji-chu/tcp.jpg\" alt></p>\n<h2 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h2><p><code>http</code>是一个简单的请求-响应协议，它封装在<code>TCP协议</code>之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。</p>\n<h3 id=\"http请求包体\"><a href=\"#http请求包体\" class=\"headerlink\" title=\"http请求包体\"></a>http请求包体</h3><p>格式：</p>\n<blockquote>\n<p>http包是在tcp协议上层进行的封装后的包体</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">请求包体参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">GET /domains/example/ HTTP /1.1</td>\n<td>//    请求行:     请求方法    请求URI    HTTP协议/协议版本</td>\n</tr>\n<tr>\n<td align=\"left\">Host:<a href=\"http://www.rubyboy.cn\">www.rubyboy.cn</a></td>\n<td>//    服务器端的主机名</td>\n</tr>\n<tr>\n<td align=\"left\">User-Agent:Mozilla/5.0 (MacOS 10.14.5)    safari/537.8</td>\n<td>//    浏览器信息</td>\n</tr>\n<tr>\n<td align=\"left\">Accept:text/html,application/xhtml+xml,…</td>\n<td>//    客户端能接受的MIME</td>\n</tr>\n</tbody></table>\n<p>当服务器接收到请求包体以后进行响应，此时的响应包体则需遵循http特定的包体格式，如下：</p>\n<h3 id=\"响应包体\"><a href=\"#响应包体\" class=\"headerlink\" title=\"响应包体\"></a>响应包体</h3><p>格式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">包体参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">HTTP/1.1  200  ok</td>\n<td>//    状态行:     请求方法    请求URI    HTTP协议/协议版本</td>\n</tr>\n<tr>\n<td align=\"left\">Server:     Nginx/1.0.8</td>\n<td>//    服务器端的服务器软件名字和版本</td>\n</tr>\n<tr>\n<td align=\"left\">Date:Date: Tue, 30…</td>\n<td>//    发送时间</td>\n</tr>\n<tr>\n<td align=\"left\">Content-Type: text/html</td>\n<td>//    服务器发送信息的类型</td>\n</tr>\n<tr>\n<td align=\"left\">Transfer-Encoding:chunked</td>\n<td>//    表示http是分段发的</td>\n</tr>\n<tr>\n<td align=\"left\">Connection:keep-alive</td>\n<td>//    保持连接状态</td>\n</tr>\n<tr>\n<td align=\"left\">Content-Length:90</td>\n<td>//    主体内容长度</td>\n</tr>\n<tr>\n<td align=\"left\">———-空行—————-</td>\n<td>//    用来分隔消息体和主体</td>\n</tr>\n<tr>\n<td align=\"left\">&lt;DOCTYPE html PUBLIC “-//Rubyboy….”</td>\n<td>//    消息主体</td>\n</tr>\n</tbody></table>\n<h3 id=\"一次完整的HTTP请求所经历的7个步骤\"><a href=\"#一次完整的HTTP请求所经历的7个步骤\" class=\"headerlink\" title=\"一次完整的HTTP请求所经历的7个步骤\"></a>一次完整的HTTP请求所经历的7个步骤</h3><p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p>\n<p><strong>1. 建立TCP连接</strong></p>\n<p>在HTTP服务器工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</p>\n<p><strong>2. Web浏览器向Web服务器发送请求命令</strong> </p>\n<p>一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。</p>\n<p><strong>3. Web浏览器发送请求头信息</strong> </p>\n<p>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。 </p>\n<p><strong>4. Web服务器应答</strong> </p>\n<p>客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</p>\n<p><strong>5. Web服务器发送应答头信息</strong> </p>\n<p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 </p>\n<p><strong>6. Web服务器向浏览器发送数据</strong> </p>\n<p>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p>\n<p><strong>7. Web服务器关闭TCP连接</strong> </p>\n<p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</p>\n<p>Connection:keep-alive </p>\n<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>\n<h3 id=\"请求报文和响应报文\"><a href=\"#请求报文和响应报文\" class=\"headerlink\" title=\"请求报文和响应报文\"></a>请求报文和响应报文</h3><p>HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。</p>\n<h3 id=\"HTTP请求报文\"><a href=\"#HTTP请求报文\" class=\"headerlink\" title=\"HTTP请求报文\"></a><strong>HTTP请求报文</strong></h3><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。</p>\n<p><img src=\"/2020/01/21/wang-luo-xie-yi-ji-chu/a.jpg\" alt></p>\n<p>或者使用：</p>\n<pre class=\" language-http\"><code class=\"language-http\">＜request-line＞\n\n＜headers＞\n\n＜blank line＞\n\n[＜request-body＞</code></pre>\n<p><strong>1.请求头</strong></p>\n<p>请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。</p>\n<p>HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p>\n<p>而常见的有如下几种：</p>\n<h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a><strong>GET</strong></h3><p>最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。例如，/index.jsp?id=100&amp;op=bind,这样通过GET方式传递的数据直接表示在地址中，所以我们可以把请求结果以链接的形式发送给好友。以用google搜索domety为例，Request格式如下：</p>\n<pre class=\" language-http\"><code class=\"language-http\">GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1  \n<span class=\"token header-name keyword\">Accept:</span> image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, \napplication/msword, application/x-silverlight, application/x-shockwave-flash, */*  \n<span class=\"token header-name keyword\">Referer:</span> &lt;a href=\"http://www.google.cn/\">http://www.google.cn/&lt;/a>  \n<span class=\"token header-name keyword\">Accept-Language:</span> zh-cn  \n<span class=\"token header-name keyword\">Accept-Encoding:</span> gzip, deflate  \n<span class=\"token header-name keyword\">User-Agent:</span> Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  \n<span class=\"token header-name keyword\">Host:</span> &lt;a href=\"http://www.google.cn\">www.google.cn&lt;/a>  \n<span class=\"token header-name keyword\">Connection:</span> Keep-Alive  \n<span class=\"token header-name keyword\">Cookie:</span> PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; \nNID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-\nFxlRugatx63JLv7CWMD6UB_O_r  </code></pre>\n<p>可以看到，GET方式的请求一般不包含”请求内容”部分，请求数据以地址的形式表现在请求行。地址链接如下：</p>\n<pre class=\" language-http\"><code class=\"language-http\">&lt;a href=\"http://www.google.cn/search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq=\">http://www.google.cn/search?hl=zh-CN&amp;source=hp\n&amp;q=domety&amp;aq=f&amp;oq=&lt;/a> </code></pre>\n<p>地址中”?”之后的部分就是通过GET发送的请求数据，我们可以在地址栏中清楚的看到，各个数据之间用”&amp;”符号隔开。显然，这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送。</p>\n<h3 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a><strong>POST</strong></h3><p>对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参 数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。还以上面 的搜索domety为例，如果使用POST方式的话，格式如下：大量数据的时候，也不适合使用GET方式。</p>\n<pre class=\" language-http\"><code class=\"language-http\">POST /search HTTP/1.1  \n<span class=\"token header-name keyword\">Accept:</span> image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, \napplication/msword, application/x-silverlight, application/x-shockwave-flash, */*  \n<span class=\"token header-name keyword\">Referer:</span> &lt;a href=\"http://www.google.cn/\">http://www.google.cn/&lt;/a>  \n<span class=\"token header-name keyword\">Accept-Language:</span> zh-cn  \n<span class=\"token header-name keyword\">Accept-Encoding:</span> gzip, deflate  \n<span class=\"token header-name keyword\">User-Agent:</span> Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  \n<span class=\"token header-name keyword\">Host:</span> &lt;a href=\"http://www.google.cn\">www.google.cn&lt;/a>  \n<span class=\"token header-name keyword\">Connection:</span> Keep-Alive  \n<span class=\"token header-name keyword\">Cookie:</span> PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; \nNID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-\nFxlRugatx63JLv7CWMD6UB_O_r  \n\nhl=zh-CN&amp;source=hp&amp;q=domety  </code></pre>\n<p>可以看到，POST方式请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&amp;”符号隔开。POST方式大多用于页 面的表单中。因为POST也能完成GET的功能，因此多数人在设计表单的时候一律都使用POST方式，其实这是一个误区。GET方式也有自己的特点和优 势，我们应该根据不同的情况来选择是使用GET还是使用POST。</p>\n<h3 id=\"HEAD\"><a href=\"#HEAD\" class=\"headerlink\" title=\"HEAD\"></a><strong>HEAD</strong></h3><p>HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。</p>\n<h4 id=\"请求头部\"><a href=\"#请求头部\" class=\"headerlink\" title=\"请求头部\"></a><strong>请求头部</strong></h4><p>请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：</p>\n<p>User-Agent：产生请求的浏览器类型。</p>\n<p>Accept：客户端可识别的内容类型列表。</p>\n<p>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</p>\n<h4 id=\"空行\"><a href=\"#空行\" class=\"headerlink\" title=\"空行\"></a><strong>空行</strong></h4><p>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>\n<h4 id=\"请求数据\"><a href=\"#请求数据\" class=\"headerlink\" title=\"请求数据\"></a><strong>请求数据</strong></h4><p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>\n<h3 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a><strong>HTTP报文</strong></h3><p>HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。</p>\n<p>如下所示，HTTP响应的格式与请求的格式十分类似：</p>\n<pre class=\" language-http\"><code class=\"language-http\">＜status-line＞\n\n＜headers＞\n\n＜blank line＞\n\n[＜response-body＞]</code></pre>\n<p>正如你所见，在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。</p>\n<p>状态行格式如下：</p>\n<p>HTTP-Version Status-Code Reason-Phrase CRLF</p>\n<p>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。</p>\n<ul>\n<li>1xx：指示信息–表示请求已接收，继续处理。</li>\n<li>2xx：成功–表示请求已被成功接收、理解、接受。</li>\n<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>\n<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>\n<li>5xx：服务器端错误–服务器未能实现合法的请求。</li>\n</ul>\n<p>常见状态代码、状态描述的说明如下。</p>\n<ul>\n<li>200 OK：客户端请求成功。</li>\n<li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</li>\n<li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li>\n<li>403 Forbidden：服务器收到请求，但是拒绝提供服务。</li>\n<li>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</li>\n<li>500 Internal Server Error：服务器发生不可预期的错误。</li>\n<li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</li>\n</ul>\n<p>下面给出一个HTTP响应报文例子</p>\n<pre class=\" language-http\"><code class=\"language-http\"><span class=\"token response-status\">HTTP/1.1 <span class=\"token property\">200 OK</span></span>\n<span class=\"token header-name keyword\">Date:</span> Sat, 31 Dec 2005 23:59:59 GMT\n<span class=\"token header-name keyword\">Content-Type:</span> text/html;charset=ISO-8859-1\n<span class=\"token header-name keyword\">Content-Length:</span> 122<span class=\"token text/html\">\n\n＜html＞\n＜head＞\n＜title＞Wrox Homepage＜/title＞\n＜/head＞\n＜body＞\n＜!-- body goes here --＞\n＜/body＞\n＜/html＞</span></code></pre>\n<h3 id=\"关于HTTP请求GET和POST的区别\"><a href=\"#关于HTTP请求GET和POST的区别\" class=\"headerlink\" title=\"关于HTTP请求GET和POST的区别\"></a><strong>关于HTTP请求GET和POST的区别</strong></h3><p>1.GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头＜request-line＞中）， 以?分割URL和传输数据，多个参数用&amp;连接;例如：login.action?name=hyddd&amp; password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p>\n<p> POST提交：把提交的数据放置在是HTTP包的包体＜request-body＞中。上文示例中红色字体标明的就是实际的传输数据</p>\n<p> 因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。</p>\n<p>2.传输数据的大小：</p>\n<p>  首先声明,HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有：</p>\n<p>  GET:特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。</p>\n<p>  因此对于GET提交时，传输数据就会受到URL长度的限制。</p>\n<p>  POST:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p>\n<p>3.安全性：</p>\n<p>  POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}],"music":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://xxx.com/music1.mp3","cover":"http://xxx.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"/medias/music/music2.mp3","cover":"/medias/music/cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://xxx.com/music3.mp3","cover":"http://xxx.com/music-cover3.png"}]}},"excerpt":"","more":"<h2 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h2><p><img src=\"/2020/01/21/wang-luo-xie-yi-ji-chu/tcp.jpg\" alt></p>\n<h2 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h2><p><code>http</code>是一个简单的请求-响应协议，它封装在<code>TCP协议</code>之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。</p>\n<h3 id=\"http请求包体\"><a href=\"#http请求包体\" class=\"headerlink\" title=\"http请求包体\"></a>http请求包体</h3><p>格式：</p>\n<blockquote>\n<p>http包是在tcp协议上层进行的封装后的包体</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">请求包体参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">GET /domains/example/ HTTP /1.1</td>\n<td>//    请求行:     请求方法    请求URI    HTTP协议/协议版本</td>\n</tr>\n<tr>\n<td align=\"left\">Host:<a href=\"http://www.rubyboy.cn\">www.rubyboy.cn</a></td>\n<td>//    服务器端的主机名</td>\n</tr>\n<tr>\n<td align=\"left\">User-Agent:Mozilla/5.0 (MacOS 10.14.5)    safari/537.8</td>\n<td>//    浏览器信息</td>\n</tr>\n<tr>\n<td align=\"left\">Accept:text/html,application/xhtml+xml,…</td>\n<td>//    客户端能接受的MIME</td>\n</tr>\n</tbody></table>\n<p>当服务器接收到请求包体以后进行响应，此时的响应包体则需遵循http特定的包体格式，如下：</p>\n<h3 id=\"响应包体\"><a href=\"#响应包体\" class=\"headerlink\" title=\"响应包体\"></a>响应包体</h3><p>格式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">包体参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">HTTP/1.1  200  ok</td>\n<td>//    状态行:     请求方法    请求URI    HTTP协议/协议版本</td>\n</tr>\n<tr>\n<td align=\"left\">Server:     Nginx/1.0.8</td>\n<td>//    服务器端的服务器软件名字和版本</td>\n</tr>\n<tr>\n<td align=\"left\">Date:Date: Tue, 30…</td>\n<td>//    发送时间</td>\n</tr>\n<tr>\n<td align=\"left\">Content-Type: text/html</td>\n<td>//    服务器发送信息的类型</td>\n</tr>\n<tr>\n<td align=\"left\">Transfer-Encoding:chunked</td>\n<td>//    表示http是分段发的</td>\n</tr>\n<tr>\n<td align=\"left\">Connection:keep-alive</td>\n<td>//    保持连接状态</td>\n</tr>\n<tr>\n<td align=\"left\">Content-Length:90</td>\n<td>//    主体内容长度</td>\n</tr>\n<tr>\n<td align=\"left\">———-空行—————-</td>\n<td>//    用来分隔消息体和主体</td>\n</tr>\n<tr>\n<td align=\"left\">&lt;DOCTYPE html PUBLIC “-//Rubyboy….”</td>\n<td>//    消息主体</td>\n</tr>\n</tbody></table>\n<h3 id=\"一次完整的HTTP请求所经历的7个步骤\"><a href=\"#一次完整的HTTP请求所经历的7个步骤\" class=\"headerlink\" title=\"一次完整的HTTP请求所经历的7个步骤\"></a>一次完整的HTTP请求所经历的7个步骤</h3><p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p>\n<p><strong>1. 建立TCP连接</strong></p>\n<p>在HTTP服务器工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</p>\n<p><strong>2. Web浏览器向Web服务器发送请求命令</strong> </p>\n<p>一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。</p>\n<p><strong>3. Web浏览器发送请求头信息</strong> </p>\n<p>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。 </p>\n<p><strong>4. Web服务器应答</strong> </p>\n<p>客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</p>\n<p><strong>5. Web服务器发送应答头信息</strong> </p>\n<p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 </p>\n<p><strong>6. Web服务器向浏览器发送数据</strong> </p>\n<p>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p>\n<p><strong>7. Web服务器关闭TCP连接</strong> </p>\n<p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</p>\n<p>Connection:keep-alive </p>\n<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>\n<h3 id=\"请求报文和响应报文\"><a href=\"#请求报文和响应报文\" class=\"headerlink\" title=\"请求报文和响应报文\"></a>请求报文和响应报文</h3><p>HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。</p>\n<h3 id=\"HTTP请求报文\"><a href=\"#HTTP请求报文\" class=\"headerlink\" title=\"HTTP请求报文\"></a><strong>HTTP请求报文</strong></h3><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。</p>\n<p><img src=\"/2020/01/21/wang-luo-xie-yi-ji-chu/a.jpg\" alt></p>\n<p>或者使用：</p>\n<pre><code class=\"http\">＜request-line＞\n\n＜headers＞\n\n＜blank line＞\n\n[＜request-body＞</code></pre>\n<p><strong>1.请求头</strong></p>\n<p>请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。</p>\n<p>HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p>\n<p>而常见的有如下几种：</p>\n<h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a><strong>GET</strong></h3><p>最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。例如，/index.jsp?id=100&amp;op=bind,这样通过GET方式传递的数据直接表示在地址中，所以我们可以把请求结果以链接的形式发送给好友。以用google搜索domety为例，Request格式如下：</p>\n<pre><code class=\"http\">GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1  \nAccept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, \napplication/msword, application/x-silverlight, application/x-shockwave-flash, */*  \nReferer: &lt;a href=&quot;http://www.google.cn/&quot;&gt;http://www.google.cn/&lt;/a&gt;  \nAccept-Language: zh-cn  \nAccept-Encoding: gzip, deflate  \nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  \nHost: &lt;a href=&quot;http://www.google.cn&quot;&gt;www.google.cn&lt;/a&gt;  \nConnection: Keep-Alive  \nCookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; \nNID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-\nFxlRugatx63JLv7CWMD6UB_O_r  </code></pre>\n<p>可以看到，GET方式的请求一般不包含”请求内容”部分，请求数据以地址的形式表现在请求行。地址链接如下：</p>\n<pre><code class=\"http\">&lt;a href=&quot;http://www.google.cn/search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq=&quot;&gt;http://www.google.cn/search?hl=zh-CN&amp;source=hp\n&amp;q=domety&amp;aq=f&amp;oq=&lt;/a&gt; </code></pre>\n<p>地址中”?”之后的部分就是通过GET发送的请求数据，我们可以在地址栏中清楚的看到，各个数据之间用”&amp;”符号隔开。显然，这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送。</p>\n<h3 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a><strong>POST</strong></h3><p>对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参 数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。还以上面 的搜索domety为例，如果使用POST方式的话，格式如下：大量数据的时候，也不适合使用GET方式。</p>\n<pre><code class=\"http\">POST /search HTTP/1.1  \nAccept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, \napplication/msword, application/x-silverlight, application/x-shockwave-flash, */*  \nReferer: &lt;a href=&quot;http://www.google.cn/&quot;&gt;http://www.google.cn/&lt;/a&gt;  \nAccept-Language: zh-cn  \nAccept-Encoding: gzip, deflate  \nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  \nHost: &lt;a href=&quot;http://www.google.cn&quot;&gt;www.google.cn&lt;/a&gt;  \nConnection: Keep-Alive  \nCookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; \nNID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-\nFxlRugatx63JLv7CWMD6UB_O_r  \n\nhl=zh-CN&amp;source=hp&amp;q=domety  </code></pre>\n<p>可以看到，POST方式请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&amp;”符号隔开。POST方式大多用于页 面的表单中。因为POST也能完成GET的功能，因此多数人在设计表单的时候一律都使用POST方式，其实这是一个误区。GET方式也有自己的特点和优 势，我们应该根据不同的情况来选择是使用GET还是使用POST。</p>\n<h3 id=\"HEAD\"><a href=\"#HEAD\" class=\"headerlink\" title=\"HEAD\"></a><strong>HEAD</strong></h3><p>HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。</p>\n<h4 id=\"请求头部\"><a href=\"#请求头部\" class=\"headerlink\" title=\"请求头部\"></a><strong>请求头部</strong></h4><p>请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：</p>\n<p>User-Agent：产生请求的浏览器类型。</p>\n<p>Accept：客户端可识别的内容类型列表。</p>\n<p>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</p>\n<h4 id=\"空行\"><a href=\"#空行\" class=\"headerlink\" title=\"空行\"></a><strong>空行</strong></h4><p>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>\n<h4 id=\"请求数据\"><a href=\"#请求数据\" class=\"headerlink\" title=\"请求数据\"></a><strong>请求数据</strong></h4><p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>\n<h3 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a><strong>HTTP报文</strong></h3><p>HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。</p>\n<p>如下所示，HTTP响应的格式与请求的格式十分类似：</p>\n<pre><code class=\"http\">＜status-line＞\n\n＜headers＞\n\n＜blank line＞\n\n[＜response-body＞]</code></pre>\n<p>正如你所见，在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。</p>\n<p>状态行格式如下：</p>\n<p>HTTP-Version Status-Code Reason-Phrase CRLF</p>\n<p>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。</p>\n<ul>\n<li>1xx：指示信息–表示请求已接收，继续处理。</li>\n<li>2xx：成功–表示请求已被成功接收、理解、接受。</li>\n<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>\n<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>\n<li>5xx：服务器端错误–服务器未能实现合法的请求。</li>\n</ul>\n<p>常见状态代码、状态描述的说明如下。</p>\n<ul>\n<li>200 OK：客户端请求成功。</li>\n<li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</li>\n<li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li>\n<li>403 Forbidden：服务器收到请求，但是拒绝提供服务。</li>\n<li>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</li>\n<li>500 Internal Server Error：服务器发生不可预期的错误。</li>\n<li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</li>\n</ul>\n<p>下面给出一个HTTP响应报文例子</p>\n<pre><code class=\"http\">HTTP/1.1 200 OK\nDate: Sat, 31 Dec 2005 23:59:59 GMT\nContent-Type: text/html;charset=ISO-8859-1\nContent-Length: 122\n\n＜html＞\n＜head＞\n＜title＞Wrox Homepage＜/title＞\n＜/head＞\n＜body＞\n＜!-- body goes here --＞\n＜/body＞\n＜/html＞</code></pre>\n<h3 id=\"关于HTTP请求GET和POST的区别\"><a href=\"#关于HTTP请求GET和POST的区别\" class=\"headerlink\" title=\"关于HTTP请求GET和POST的区别\"></a><strong>关于HTTP请求GET和POST的区别</strong></h3><p>1.GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头＜request-line＞中）， 以?分割URL和传输数据，多个参数用&amp;连接;例如：login.action?name=hyddd&amp; password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p>\n<p> POST提交：把提交的数据放置在是HTTP包的包体＜request-body＞中。上文示例中红色字体标明的就是实际的传输数据</p>\n<p> 因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。</p>\n<p>2.传输数据的大小：</p>\n<p>  首先声明,HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有：</p>\n<p>  GET:特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。</p>\n<p>  因此对于GET提交时，传输数据就会受到URL长度的限制。</p>\n<p>  POST:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p>\n<p>3.安全性：</p>\n<p>  POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。</p>\n"}],"PostAsset":[{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png5.png","slug":"png5.png","post":"ck7771rji000xzd5b9abo2cx0","modified":0,"renderable":0},{"_id":"source/_posts/Go并发编程初探/png1.png","slug":"png1.png","post":"ck7771rj9000czd5baofh0kmt","modified":0,"renderable":0},{"_id":"source/_posts/Go并发编程初探/png9.png","slug":"png9.png","post":"ck7771rj9000czd5baofh0kmt","modified":0,"renderable":0},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png11.png","slug":"png11.png","post":"ck7771rji000xzd5b9abo2cx0","modified":0,"renderable":0},{"_id":"source/_posts/Go-defer-详解/defer.png","slug":"defer.png","post":"ck7771rj10006zd5bgibc7mc8","modified":0,"renderable":0},{"_id":"source/_posts/Go语言基础之并发/1.png","slug":"1.png","post":"ck7771rjb000dzd5b894i05um","modified":0,"renderable":0},{"_id":"source/_posts/Mac设置文件权限问题/1.png","slug":"1.png","post":"ck7771rjf000ozd5berps0dwe","modified":0,"renderable":0},{"_id":"source/_posts/服务器平滑升级-柔性重启/png1.png","slug":"png1.png","post":"ck7771rjs001pzd5b8g21hata","modified":0,"renderable":0},{"_id":"source/_posts/Delve调试工具/png10.png","slug":"png10.png","post":"ck7771ris0000zd5b7oe543tx","modified":0,"renderable":0},{"_id":"source/_posts/Delve调试工具/start.jpg","slug":"start.jpg","post":"ck7771ris0000zd5b7oe543tx","modified":0,"renderable":0},{"_id":"source/_posts/Go常用语法糖炮弹工具集/p1.jpg","slug":"p1.jpg","post":"ck7771rj60009zd5b1r4a6zfy","modified":0,"renderable":0},{"_id":"source/_posts/Go常用语法糖炮弹工具集/suga.jpg","slug":"suga.jpg","post":"ck7771rj60009zd5b1r4a6zfy","modified":0,"renderable":0},{"_id":"source/_posts/Kubernetes第一章-组件简介/dockerswarm.png","slug":"dockerswarm.png","post":"ck7771rjd000hzd5b32lsc3ew","modified":0,"renderable":0},{"_id":"source/_posts/Kubernetes第一章-组件简介/mesos.jpg","slug":"mesos.jpg","post":"ck7771rjd000hzd5b32lsc3ew","modified":0,"renderable":0},{"_id":"source/_posts/blender-学习章/end.jpg","slug":"end.jpg","post":"ck7771rjk0014zd5b5ki42s1m","modified":0,"renderable":0},{"_id":"source/_posts/blender-学习章/start.jpg","slug":"start.jpg","post":"ck7771rjk0014zd5b5ki42s1m","modified":0,"renderable":0},{"_id":"source/_posts/大话Tcp-Ip协议栈/1.jpg","slug":"1.jpg","post":"ck7771rjn001fzd5b2owr62or","modified":0,"renderable":0},{"_id":"source/_posts/大话Tcp-Ip协议栈/2.jpg","slug":"2.jpg","post":"ck7771rjn001fzd5b2owr62or","modified":0,"renderable":0},{"_id":"source/_posts/Hexo博客搭建/Hexo.jpg","slug":"Hexo.jpg","post":"ck7771rjd000kzd5balr467b9","modified":0,"renderable":0},{"_id":"source/_posts/Hexo博客搭建/hexo_config.png","slug":"hexo_config.png","post":"ck7771rjd000kzd5balr467b9","modified":0,"renderable":0},{"_id":"source/_posts/Hexo博客搭建/hexothemes.jpg","slug":"hexothemes.jpg","post":"ck7771rjd000kzd5balr467b9","modified":0,"renderable":0},{"_id":"source/_posts/Hexo博客搭建/start.png","slug":"start.png","post":"ck7771rjd000kzd5balr467b9","modified":0,"renderable":0},{"_id":"source/_posts/Nginx安装/bash.png","slug":"bash.png","post":"ck7771rjh000uzd5bh7h46q9h","modified":0,"renderable":0},{"_id":"source/_posts/Nginx安装/default.jpg","slug":"default.jpg","post":"ck7771rjh000uzd5bh7h46q9h","modified":0,"renderable":0},{"_id":"source/_posts/Nginx安装/nginx.jpg","slug":"nginx.jpg","post":"ck7771rjh000uzd5bh7h46q9h","modified":0,"renderable":0},{"_id":"source/_posts/Nginx安装/start.png","slug":"start.png","post":"ck7771rjh000uzd5bh7h46q9h","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-二-微服务注册和发现/1.png","slug":"1.png","post":"ck7771rjt001szd5bcg6k2vs9","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-二-微服务注册和发现/2.png","slug":"2.png","post":"ck7771rjt001szd5bcg6k2vs9","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-二-微服务注册和发现/3.jpg","slug":"3.jpg","post":"ck7771rjt001szd5bcg6k2vs9","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-二-微服务注册和发现/start.png","slug":"start.png","post":"ck7771rjt001szd5bcg6k2vs9","modified":0,"renderable":0},{"_id":"source/_posts/网络协议基础/a.jpg","slug":"a.jpg","post":"ck7771rjv001zzd5bcujhad2j","modified":0,"renderable":0},{"_id":"source/_posts/网络协议基础/http.jpg","slug":"http.jpg","post":"ck7771rjv001zzd5bcujhad2j","modified":0,"renderable":0},{"_id":"source/_posts/网络协议基础/level.jpg","slug":"level.jpg","post":"ck7771rjv001zzd5bcujhad2j","modified":0,"renderable":0},{"_id":"source/_posts/网络协议基础/tcp.jpg","slug":"tcp.jpg","post":"ck7771rjv001zzd5bcujhad2j","modified":0,"renderable":0},{"_id":"source/_posts/Go单元测试和压力测试/png1.png","slug":"png1.png","post":"ck7771rj30008zd5b68b83s0b","modified":0,"renderable":0},{"_id":"source/_posts/Go单元测试和压力测试/png2.png","slug":"png2.png","post":"ck7771rj30008zd5b68b83s0b","modified":0,"renderable":0},{"_id":"source/_posts/Go单元测试和压力测试/png3.png","slug":"png3.png","post":"ck7771rj30008zd5b68b83s0b","modified":0,"renderable":0},{"_id":"source/_posts/Go单元测试和压力测试/png4.png","slug":"png4.png","post":"ck7771rj30008zd5b68b83s0b","modified":0,"renderable":0},{"_id":"source/_posts/Go单元测试和压力测试/start.png","slug":"start.png","post":"ck7771rj30008zd5b68b83s0b","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-一/1.png","slug":"1.png","post":"ck7771rjq001izd5b59u67lwu","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-一/2.png","slug":"2.png","post":"ck7771rjq001izd5b59u67lwu","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-一/3.jpg","slug":"3.jpg","post":"ck7771rjq001izd5b59u67lwu","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-一/4.jpg","slug":"4.jpg","post":"ck7771rjq001izd5b59u67lwu","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-一/start.png","slug":"start.png","post":"ck7771rjq001izd5b59u67lwu","modified":0,"renderable":0},{"_id":"source/_posts/Go-ProtoBuf-和其他传输数据协议/jpg3.jpg","slug":"jpg3.jpg","post":"ck7771riy0002zd5b95zkenpp","modified":0,"renderable":0},{"_id":"source/_posts/Go-ProtoBuf-和其他传输数据协议/png1.png","slug":"png1.png","post":"ck7771riy0002zd5b95zkenpp","modified":0,"renderable":0},{"_id":"source/_posts/Go-ProtoBuf-和其他传输数据协议/png2.png","slug":"png2.png","post":"ck7771riy0002zd5b95zkenpp","modified":0,"renderable":0},{"_id":"source/_posts/Go-ProtoBuf-和其他传输数据协议/png4.png","slug":"png4.png","post":"ck7771riy0002zd5b95zkenpp","modified":0,"renderable":0},{"_id":"source/_posts/Go-ProtoBuf-和其他传输数据协议/png5.png","slug":"png5.png","post":"ck7771riy0002zd5b95zkenpp","modified":0,"renderable":0},{"_id":"source/_posts/Go-ProtoBuf-和其他传输数据协议/start.png","slug":"start.png","post":"ck7771riy0002zd5b95zkenpp","modified":0,"renderable":0},{"_id":"source/_posts/Go并发编程初探/lock.jpg","slug":"lock.jpg","post":"ck7771rj9000czd5baofh0kmt","modified":0,"renderable":0},{"_id":"source/_posts/Go并发编程初探/png2.png","slug":"png2.png","post":"ck7771rj9000czd5baofh0kmt","modified":0,"renderable":0},{"_id":"source/_posts/Go并发编程初探/png6.png","slug":"png6.png","post":"ck7771rj9000czd5baofh0kmt","modified":0,"renderable":0},{"_id":"source/_posts/Go并发编程初探/png7.png","slug":"png7.png","post":"ck7771rj9000czd5baofh0kmt","modified":0,"renderable":0},{"_id":"source/_posts/Go并发编程初探/png8.png","slug":"png8.png","post":"ck7771rj9000czd5baofh0kmt","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/10.jpg","slug":"10.jpg","post":"ck7771rjm001bzd5b03hc5j03","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/11.jpg","slug":"11.jpg","post":"ck7771rjm001bzd5b03hc5j03","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/12.jpg","slug":"12.jpg","post":"ck7771rjm001bzd5b03hc5j03","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/13.jpg","slug":"13.jpg","post":"ck7771rjm001bzd5b03hc5j03","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/3.jpg","slug":"3.jpg","post":"ck7771rjm001bzd5b03hc5j03","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/4.jpg","slug":"4.jpg","post":"ck7771rjm001bzd5b03hc5j03","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/5.jpg","slug":"5.jpg","post":"ck7771rjm001bzd5b03hc5j03","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/6.jpg","slug":"6.jpg","post":"ck7771rjm001bzd5b03hc5j03","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/7.jpg","slug":"7.jpg","post":"ck7771rjm001bzd5b03hc5j03","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/8.jpg","slug":"8.jpg","post":"ck7771rjm001bzd5b03hc5j03","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议栈-二-TCP和UDP协议详解/9.jpg","slug":"9.jpg","post":"ck7771rjm001bzd5b03hc5j03","modified":0,"renderable":0},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/pn4.png","slug":"pn4.png","post":"ck7771rji000xzd5b9abo2cx0","modified":0,"renderable":0},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png1.png","slug":"png1.png","post":"ck7771rji000xzd5b9abo2cx0","modified":0,"renderable":0},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png10.png","slug":"png10.png","post":"ck7771rji000xzd5b9abo2cx0","modified":0,"renderable":0},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png12.png","slug":"png12.png","post":"ck7771rji000xzd5b9abo2cx0","modified":0,"renderable":0},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png2.png","slug":"png2.png","post":"ck7771rji000xzd5b9abo2cx0","modified":0,"renderable":0},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png3.png","slug":"png3.png","post":"ck7771rji000xzd5b9abo2cx0","modified":0,"renderable":0},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png6.png","slug":"png6.png","post":"ck7771rji000xzd5b9abo2cx0","modified":0,"renderable":0},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png7.png","slug":"png7.png","post":"ck7771rji000xzd5b9abo2cx0","modified":0,"renderable":0},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png8.png","slug":"png8.png","post":"ck7771rji000xzd5b9abo2cx0","modified":0,"renderable":0},{"_id":"source/_posts/ShaderGraph无贴图自制蓝色火焰/png9.png","slug":"png9.png","post":"ck7771rji000xzd5b9abo2cx0","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/14.jpg","slug":"14.jpg","post":"ck7771rjl0017zd5b34ujhbdi","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/15.jpg","slug":"15.jpg","post":"ck7771rjl0017zd5b34ujhbdi","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/16.jpg","slug":"16.jpg","post":"ck7771rjl0017zd5b34ujhbdi","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/17.jpg","slug":"17.jpg","post":"ck7771rjl0017zd5b34ujhbdi","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/18.jpg","slug":"18.jpg","post":"ck7771rjl0017zd5b34ujhbdi","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/19.jpg","slug":"19.jpg","post":"ck7771rjl0017zd5b34ujhbdi","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/20.jpg","slug":"20.jpg","post":"ck7771rjl0017zd5b34ujhbdi","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/21.jpg","slug":"21.jpg","post":"ck7771rjl0017zd5b34ujhbdi","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/22.jpg","slug":"22.jpg","post":"ck7771rjl0017zd5b34ujhbdi","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/23.jpg","slug":"23.jpg","post":"ck7771rjl0017zd5b34ujhbdi","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/24.jpg","slug":"24.jpg","post":"ck7771rjl0017zd5b34ujhbdi","modified":0,"renderable":0},{"_id":"source/_posts/大话TCP-IP协议-三-IP协议/25.jpg","slug":"25.jpg","post":"ck7771rjl0017zd5b34ujhbdi","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-三-Raft协议/10.png","slug":"10.png","post":"ck7771rjq001lzd5belac2xt5","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-三-Raft协议/11.png","slug":"11.png","post":"ck7771rjq001lzd5belac2xt5","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-三-Raft协议/12.png","slug":"12.png","post":"ck7771rjq001lzd5belac2xt5","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-三-Raft协议/13.png","slug":"13.png","post":"ck7771rjq001lzd5belac2xt5","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-三-Raft协议/15.png","slug":"15.png","post":"ck7771rjq001lzd5belac2xt5","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-三-Raft协议/16.png","slug":"16.png","post":"ck7771rjq001lzd5belac2xt5","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-三-Raft协议/4.png","slug":"4.png","post":"ck7771rjq001lzd5belac2xt5","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-三-Raft协议/5.png","slug":"5.png","post":"ck7771rjq001lzd5belac2xt5","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-三-Raft协议/6.png","slug":"6.png","post":"ck7771rjq001lzd5belac2xt5","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-三-Raft协议/7.png","slug":"7.png","post":"ck7771rjq001lzd5belac2xt5","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-三-Raft协议/8.png","slug":"8.png","post":"ck7771rjq001lzd5belac2xt5","modified":0,"renderable":0},{"_id":"source/_posts/微服务架构-三-Raft协议/9.png","slug":"9.png","post":"ck7771rjq001lzd5belac2xt5","modified":0,"renderable":0},{"_id":"source/_posts/游戏中的四元数/rotation.jpg","slug":"rotation.jpg","post":"ck7771rju001wzd5bfc6o9v3i","modified":0,"renderable":0},{"_id":"source/_posts/游戏中的四元数/show.jpg","slug":"show.jpg","post":"ck7771rju001wzd5bfc6o9v3i","modified":0,"renderable":0},{"_id":"source/_posts/游戏中的四元数/show1.png","slug":"show1.png","post":"ck7771rju001wzd5bfc6o9v3i","modified":0,"renderable":0},{"_id":"source/_posts/游戏中的四元数/show2.png","slug":"show2.png","post":"ck7771rju001wzd5bfc6o9v3i","modified":0,"renderable":0},{"_id":"source/_posts/游戏中的四元数/show3.png","slug":"show3.png","post":"ck7771rju001wzd5bfc6o9v3i","modified":0,"renderable":0},{"_id":"source/_posts/游戏中的四元数/show4.png","slug":"show4.png","post":"ck7771rju001wzd5bfc6o9v3i","modified":0,"renderable":0},{"_id":"source/_posts/游戏中的四元数/show5.png","slug":"show5.png","post":"ck7771rju001wzd5bfc6o9v3i","modified":0,"renderable":0},{"_id":"source/_posts/游戏中的四元数/show6.png","slug":"show6.png","post":"ck7771rju001wzd5bfc6o9v3i","modified":0,"renderable":0},{"_id":"source/_posts/游戏中的四元数/show7.jpg","slug":"show7.jpg","post":"ck7771rju001wzd5bfc6o9v3i","modified":0,"renderable":0},{"_id":"source/_posts/游戏中的四元数/show8.png","slug":"show8.png","post":"ck7771rju001wzd5bfc6o9v3i","modified":0,"renderable":0},{"_id":"source/_posts/游戏中的四元数/show9.png","slug":"show9.png","post":"ck7771rju001wzd5bfc6o9v3i","modified":0,"renderable":0},{"_id":"source/_posts/游戏中的四元数/start.png","slug":"start.png","post":"ck7771rju001wzd5bfc6o9v3i","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ck7771rj30008zd5b68b83s0b","category_id":"ck7771rj00004zd5bbg119j56","_id":"ck7771rjc000ezd5b3n7u2pwx"},{"post_id":"ck7771ris0000zd5b7oe543tx","category_id":"ck7771rj00004zd5bbg119j56","_id":"ck7771rjd000izd5b6o1725gu"},{"post_id":"ck7771rj60009zd5b1r4a6zfy","category_id":"ck7771rj00004zd5bbg119j56","_id":"ck7771rje000lzd5b4fj1ho9y"},{"post_id":"ck7771rj9000czd5baofh0kmt","category_id":"ck7771rj00004zd5bbg119j56","_id":"ck7771rjf000pzd5bfmiufym0"},{"post_id":"ck7771riy0002zd5b95zkenpp","category_id":"ck7771rj00004zd5bbg119j56","_id":"ck7771rjg000rzd5bhro2790w"},{"post_id":"ck7771rjb000dzd5b894i05um","category_id":"ck7771rj00004zd5bbg119j56","_id":"ck7771rji000vzd5bh0d40rwo"},{"post_id":"ck7771rjd000hzd5b32lsc3ew","category_id":"ck7771rj00004zd5bbg119j56","_id":"ck7771rji000yzd5bak5h3vuo"},{"post_id":"ck7771rj10006zd5bgibc7mc8","category_id":"ck7771rj00004zd5bbg119j56","_id":"ck7771rjk0013zd5b23lk5euu"},{"post_id":"ck7771rjd000kzd5balr467b9","category_id":"ck7771rj00004zd5bbg119j56","_id":"ck7771rjk0015zd5b78rhc1h7"},{"post_id":"ck7771rjh000uzd5bh7h46q9h","category_id":"ck7771rj00004zd5bbg119j56","_id":"ck7771rjm0018zd5betfh6ekb"},{"post_id":"ck7771rjf000ozd5berps0dwe","category_id":"ck7771rjg000tzd5b5iu3crqa","_id":"ck7771rjn001czd5bak6xemww"},{"post_id":"ck7771rjk0014zd5b5ki42s1m","category_id":"ck7771rjk0012zd5bb9ef4pn9","_id":"ck7771rjo001gzd5bfynec41j"},{"post_id":"ck7771rjf000qzd5bhbys4j2l","category_id":"ck7771rjk0012zd5bb9ef4pn9","_id":"ck7771rjq001jzd5bglmr9wkr"},{"post_id":"ck7771rji000xzd5b9abo2cx0","category_id":"ck7771rjk0012zd5bb9ef4pn9","_id":"ck7771rjr001mzd5bdlhk19gc"},{"post_id":"ck7771rjq001izd5b59u67lwu","category_id":"ck7771rj00004zd5bbg119j56","_id":"ck7771rjt001tzd5bd5ow7fx7"},{"post_id":"ck7771rjl0017zd5b34ujhbdi","category_id":"ck7771rjo001hzd5bd5f718gk","_id":"ck7771rjv001xzd5bhl0se5ou"},{"post_id":"ck7771rjq001lzd5belac2xt5","category_id":"ck7771rj00004zd5bbg119j56","_id":"ck7771rjw0020zd5b1in6g8jl"},{"post_id":"ck7771rjs001pzd5b8g21hata","category_id":"ck7771rj00004zd5bbg119j56","_id":"ck7771rjw0023zd5bbmsq8gmm"},{"post_id":"ck7771rjm001bzd5b03hc5j03","category_id":"ck7771rjo001hzd5bd5f718gk","_id":"ck7771rjw0025zd5b4vyq2av7"},{"post_id":"ck7771rjt001szd5bcg6k2vs9","category_id":"ck7771rj00004zd5bbg119j56","_id":"ck7771rjx0028zd5bcd2rahww"},{"post_id":"ck7771rju001wzd5bfc6o9v3i","category_id":"ck7771rjk0012zd5bb9ef4pn9","_id":"ck7771rjx002azd5b4pbeae5x"},{"post_id":"ck7771rjn001fzd5b2owr62or","category_id":"ck7771rjo001hzd5bd5f718gk","_id":"ck7771rjx002dzd5bd1944rh8"},{"post_id":"ck7771rjv001zzd5bcujhad2j","category_id":"ck7771rj00004zd5bbg119j56","_id":"ck7771rjx002fzd5bhguqf80x"}],"PostTag":[{"post_id":"ck7771ris0000zd5b7oe543tx","tag_id":"ck7771rj10005zd5b7bldcapj","_id":"ck7771rjd000jzd5bbis0dc4f"},{"post_id":"ck7771ris0000zd5b7oe543tx","tag_id":"ck7771rj7000bzd5b17t84y80","_id":"ck7771rje000mzd5b6umx61qk"},{"post_id":"ck7771riy0002zd5b95zkenpp","tag_id":"ck7771rj10005zd5b7bldcapj","_id":"ck7771rji000wzd5b1r6pc4u5"},{"post_id":"ck7771riy0002zd5b95zkenpp","tag_id":"ck7771rje000nzd5be6yx16rg","_id":"ck7771rjj000zzd5b4upg4tad"},{"post_id":"ck7771rj10006zd5bgibc7mc8","tag_id":"ck7771rj10005zd5b7bldcapj","_id":"ck7771rjm001azd5b4ii4ci56"},{"post_id":"ck7771rj10006zd5bgibc7mc8","tag_id":"ck7771rj7000bzd5b17t84y80","_id":"ck7771rjn001dzd5b8njw6mqw"},{"post_id":"ck7771rj30008zd5b68b83s0b","tag_id":"ck7771rj10005zd5b7bldcapj","_id":"ck7771rjr001ozd5b9ut739wx"},{"post_id":"ck7771rj30008zd5b68b83s0b","tag_id":"ck7771rj7000bzd5b17t84y80","_id":"ck7771rjs001qzd5b8z98gvd5"},{"post_id":"ck7771rj30008zd5b68b83s0b","tag_id":"ck7771rjn001ezd5bh38l721q","_id":"ck7771rju001vzd5bb9660b4f"},{"post_id":"ck7771rj60009zd5b1r4a6zfy","tag_id":"ck7771rj10005zd5b7bldcapj","_id":"ck7771rjv001yzd5b09oh4873"},{"post_id":"ck7771rj60009zd5b1r4a6zfy","tag_id":"ck7771rj7000bzd5b17t84y80","_id":"ck7771rjw0022zd5bhvgz0n22"},{"post_id":"ck7771rjs001pzd5b8g21hata","tag_id":"ck7771rj10005zd5b7bldcapj","_id":"ck7771rjw0024zd5bgmmr0gkf"},{"post_id":"ck7771rjs001pzd5b8g21hata","tag_id":"ck7771rj7000bzd5b17t84y80","_id":"ck7771rjx0027zd5b5t9n6rz6"},{"post_id":"ck7771rj9000czd5baofh0kmt","tag_id":"ck7771rj10005zd5b7bldcapj","_id":"ck7771rjx0029zd5b0lioajry"},{"post_id":"ck7771rj9000czd5baofh0kmt","tag_id":"ck7771rj7000bzd5b17t84y80","_id":"ck7771rjx002czd5bcxro4xvy"},{"post_id":"ck7771rj9000czd5baofh0kmt","tag_id":"ck7771rjt001rzd5bd3j0dtce","_id":"ck7771rjx002ezd5b7v9w7zs1"},{"post_id":"ck7771rjv001zzd5bcujhad2j","tag_id":"ck7771rj7000bzd5b17t84y80","_id":"ck7771rjx002gzd5bcdp0es1u"},{"post_id":"ck7771rjv001zzd5bcujhad2j","tag_id":"ck7771rje000nzd5be6yx16rg","_id":"ck7771rjy002izd5b9sv3eu32"},{"post_id":"ck7771rjb000dzd5b894i05um","tag_id":"ck7771rj10005zd5b7bldcapj","_id":"ck7771rjy002jzd5bbr0n87ox"},{"post_id":"ck7771rjb000dzd5b894i05um","tag_id":"ck7771rjw0021zd5bddvu38le","_id":"ck7771rjy002lzd5b0ghu41dt"},{"post_id":"ck7771rjb000dzd5b894i05um","tag_id":"ck7771rjx0026zd5b7hxn6uov","_id":"ck7771rjy002mzd5b6ki49vfz"},{"post_id":"ck7771rjd000hzd5b32lsc3ew","tag_id":"ck7771rjx002bzd5b8538b0ar","_id":"ck7771rjy002ozd5b1gb32u2y"},{"post_id":"ck7771rjd000hzd5b32lsc3ew","tag_id":"ck7771rjy002hzd5b0esl6f9e","_id":"ck7771rjy002pzd5b13990m9b"},{"post_id":"ck7771rjd000hzd5b32lsc3ew","tag_id":"ck7771rjy002kzd5b4aph6kbq","_id":"ck7771rjz002rzd5bdv6w9lhm"},{"post_id":"ck7771rjf000ozd5berps0dwe","tag_id":"ck7771rjy002nzd5b4v7ofsc1","_id":"ck7771rjz002tzd5b91wz9eno"},{"post_id":"ck7771rjf000ozd5berps0dwe","tag_id":"ck7771rjy002qzd5bfygd331n","_id":"ck7771rjz002uzd5bewrhh3kf"},{"post_id":"ck7771rjh000uzd5bh7h46q9h","tag_id":"ck7771rj10005zd5b7bldcapj","_id":"ck7771rjz002wzd5bhrce0jm8"},{"post_id":"ck7771rjh000uzd5bh7h46q9h","tag_id":"ck7771rj7000bzd5b17t84y80","_id":"ck7771rjz002xzd5bb2bb3msa"},{"post_id":"ck7771rjh000uzd5bh7h46q9h","tag_id":"ck7771rjz002szd5bgbq6c2ps","_id":"ck7771rk0002zzd5b5tdffhh3"},{"post_id":"ck7771rjj0011zd5b3afo2yab","tag_id":"ck7771rjz002vzd5ba6mc737z","_id":"ck7771rk00030zd5bfjbzbpn9"},{"post_id":"ck7771rjk0014zd5b5ki42s1m","tag_id":"ck7771rjz002yzd5b1iy2bzua","_id":"ck7771rk00033zd5b34pvdoqf"},{"post_id":"ck7771rjk0014zd5b5ki42s1m","tag_id":"ck7771rk00031zd5bhu9784hr","_id":"ck7771rk00034zd5bh3ap43ct"},{"post_id":"ck7771rjl0017zd5b34ujhbdi","tag_id":"ck7771rk00032zd5b0h1udkql","_id":"ck7771rk10036zd5bhuzkbh0k"},{"post_id":"ck7771rjl0017zd5b34ujhbdi","tag_id":"ck7771rje000nzd5be6yx16rg","_id":"ck7771rk10037zd5bbz7d8r85"},{"post_id":"ck7771rjm001bzd5b03hc5j03","tag_id":"ck7771rk00032zd5b0h1udkql","_id":"ck7771rk10039zd5b46oiaklw"},{"post_id":"ck7771rjm001bzd5b03hc5j03","tag_id":"ck7771rje000nzd5be6yx16rg","_id":"ck7771rk1003azd5bfyf551cd"},{"post_id":"ck7771rjn001fzd5b2owr62or","tag_id":"ck7771rk00032zd5b0h1udkql","_id":"ck7771rk1003czd5bfiaph8dq"},{"post_id":"ck7771rjn001fzd5b2owr62or","tag_id":"ck7771rje000nzd5be6yx16rg","_id":"ck7771rk2003dzd5b1e3ccirk"},{"post_id":"ck7771rjq001izd5b59u67lwu","tag_id":"ck7771rj10005zd5b7bldcapj","_id":"ck7771rk2003gzd5bholr1gf0"},{"post_id":"ck7771rjq001izd5b59u67lwu","tag_id":"ck7771rjy002kzd5b4aph6kbq","_id":"ck7771rk2003hzd5b9qe49s6p"},{"post_id":"ck7771rjq001izd5b59u67lwu","tag_id":"ck7771rjy002hzd5b0esl6f9e","_id":"ck7771rk3003jzd5b92zof844"},{"post_id":"ck7771rjq001lzd5belac2xt5","tag_id":"ck7771rj10005zd5b7bldcapj","_id":"ck7771rk3003lzd5b3alw1bj4"},{"post_id":"ck7771rjq001lzd5belac2xt5","tag_id":"ck7771rjy002kzd5b4aph6kbq","_id":"ck7771rk3003mzd5b0mpaec5e"},{"post_id":"ck7771rjq001lzd5belac2xt5","tag_id":"ck7771rjy002hzd5b0esl6f9e","_id":"ck7771rk3003ozd5b215c03c4"},{"post_id":"ck7771rjt001szd5bcg6k2vs9","tag_id":"ck7771rj10005zd5b7bldcapj","_id":"ck7771rk4003qzd5bhc09fywy"},{"post_id":"ck7771rjt001szd5bcg6k2vs9","tag_id":"ck7771rjy002kzd5b4aph6kbq","_id":"ck7771rk4003rzd5b3pqjhrnx"},{"post_id":"ck7771rjt001szd5bcg6k2vs9","tag_id":"ck7771rjy002hzd5b0esl6f9e","_id":"ck7771rk4003tzd5b5b04925z"},{"post_id":"ck7771rju001wzd5bfc6o9v3i","tag_id":"ck7771rk3003pzd5b0qln9h1a","_id":"ck7771rk4003vzd5b5fpr87xx"},{"post_id":"ck7771rju001wzd5bfc6o9v3i","tag_id":"ck7771rk4003szd5b2ogjckys","_id":"ck7771rk4003wzd5b2z8hbsnq"},{"post_id":"ck7771rju001wzd5bfc6o9v3i","tag_id":"ck7771rk4003uzd5bhxz6gfg3","_id":"ck7771rk4003xzd5b30c9hkei"}],"Tag":[{"name":"Go","_id":"ck7771rj10005zd5b7bldcapj"},{"name":"服务端开发","_id":"ck7771rj7000bzd5b17t84y80"},{"name":"网络协议","_id":"ck7771rje000nzd5be6yx16rg"},{"name":"软件测试","_id":"ck7771rjn001ezd5bh38l721q"},{"name":"并发编程","_id":"ck7771rjt001rzd5bd3j0dtce"},{"name":"服务器编程","_id":"ck7771rjw0021zd5bddvu38le"},{"name":"并发","_id":"ck7771rjx0026zd5b7hxn6uov"},{"name":"Kubernetes","_id":"ck7771rjx002bzd5b8538b0ar"},{"name":"Micro Service","_id":"ck7771rjy002hzd5b0esl6f9e"},{"name":"微服务","_id":"ck7771rjy002kzd5b4aph6kbq"},{"name":"Mac","_id":"ck7771rjy002nzd5b4v7ofsc1"},{"name":"文件权限","_id":"ck7771rjy002qzd5bfygd331n"},{"name":"Ngix","_id":"ck7771rjz002szd5bgbq6c2ps"},{"name":"VMware fusion","_id":"ck7771rjz002vzd5ba6mc737z"},{"name":"游戏美术","_id":"ck7771rjz002yzd5b1iy2bzua"},{"name":"建模","_id":"ck7771rk00031zd5bhu9784hr"},{"name":"tcp/ip协议","_id":"ck7771rk00032zd5b0h1udkql"},{"name":"Unity","_id":"ck7771rk3003pzd5b0qln9h1a"},{"name":"游戏开发","_id":"ck7771rk4003szd5b2ogjckys"},{"name":"图形学","_id":"ck7771rk4003uzd5bhxz6gfg3"}]}}